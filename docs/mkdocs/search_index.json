{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nOpenBR is a framework for investigating new modalities, improving existing algorithms, interfacing with commercial systems, measuring recognition performance, and deploying automated biometric systems.\nThe project is designed to facilitate rapid algorithm prototyping, and features a mature core framework, flexible plugin system, and support for open and closed source development.\nOff-the-shelf algorithms are also available for specific modalities including \nface recognition\n, \nage estimation\n, and \ngender estimation\n. Please see the \nTutorials\n section for more information.\n\n\nOpenBR originated within The MITRE Corporation from a need to streamline the process of prototyping new algorithms.\nThe project was later published as open source software under the \nApache 2\n license and is \nfree for academic and commercial use\n.\n\n\nPlease read \nour paper\n for more information about OpenBR and kindly cite in your own work:\n\n\n\n\nJ. Klontz, B. Klare, S. Klum, E. Taborsky, M. Burge, A. Jain, \u201cOpen Source Biometric Recognition\u201d, Biometrics: Theory, Applications and Systems, 2013.\n\n\n\n\n\n\n\n  \n\n  \nThe two principal software artifacts are the shared library 'openbr' and command line application 'br'.\n\n\n\n\n\n\n\nInstall\n\n\nOpenBR is supported on multiple operating systems. Please select yours from the list below for installation instructions.\n\n\n\n\nLinux\n\n\nMac OSX\n\n\nWindows\n\n\nRaspian\n\n\n\n\n\n\nTutorials\n\n\nWe recommend that first-time users of the OpenBR framework look at the following tutorials before moving on to the more in-depth documentation below.\n\n\n\n\nQuick Start\n\n\nAlgorithms in OpenBR\n\n\nTraining Algorithms in OpenBR\n\n\nThe Evaluation Harness\n\n\nFace Recognition\n\n\nAge Estimation\n\n\nGender Estimation\n\n\n\n\n\n\nDocumentation\n\n\nHere is the complete documentation for OpenBR. Enjoy!\n\n\n\n\nThe C API\n\n\nThe C++ Plugin API\n\n\nThe Command Line Interface\n\n\n\n\n\n\nHelp\n\n\nStill have questions? Please reach out to us on our \ndeveloper mailing list\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#overview", 
            "text": "OpenBR is a framework for investigating new modalities, improving existing algorithms, interfacing with commercial systems, measuring recognition performance, and deploying automated biometric systems.\nThe project is designed to facilitate rapid algorithm prototyping, and features a mature core framework, flexible plugin system, and support for open and closed source development.\nOff-the-shelf algorithms are also available for specific modalities including  face recognition ,  age estimation , and  gender estimation . Please see the  Tutorials  section for more information.  OpenBR originated within The MITRE Corporation from a need to streamline the process of prototyping new algorithms.\nThe project was later published as open source software under the  Apache 2  license and is  free for academic and commercial use .  Please read  our paper  for more information about OpenBR and kindly cite in your own work:   J. Klontz, B. Klare, S. Klum, E. Taborsky, M. Burge, A. Jain, \u201cOpen Source Biometric Recognition\u201d, Biometrics: Theory, Applications and Systems, 2013.    \n   \n   The two principal software artifacts are the shared library 'openbr' and command line application 'br'.", 
            "title": "Overview"
        }, 
        {
            "location": "/#install", 
            "text": "OpenBR is supported on multiple operating systems. Please select yours from the list below for installation instructions.   Linux  Mac OSX  Windows  Raspian", 
            "title": "Install"
        }, 
        {
            "location": "/#tutorials", 
            "text": "We recommend that first-time users of the OpenBR framework look at the following tutorials before moving on to the more in-depth documentation below.   Quick Start  Algorithms in OpenBR  Training Algorithms in OpenBR  The Evaluation Harness  Face Recognition  Age Estimation  Gender Estimation", 
            "title": "Tutorials"
        }, 
        {
            "location": "/#documentation", 
            "text": "Here is the complete documentation for OpenBR. Enjoy!   The C API  The C++ Plugin API  The Command Line Interface", 
            "title": "Documentation"
        }, 
        {
            "location": "/#help", 
            "text": "Still have questions? Please reach out to us on our  developer mailing list .", 
            "title": "Help"
        }, 
        {
            "location": "/install/", 
            "text": "A hacker's guide to building, editing, and running OpenBR.\n\n\n\n\nLinux\n\n\n\n\n\n\nInstall GCC 4.9.2\n\n\n$ sudo apt-get update\n$ sudo apt-get install build-essential\n\n\n\n\n\n\n\nInstall CMake 3.0.2\n\n\n$ sudo apt-get install cmake cmake-curses-gui\n\n\n\n\n\n\n\nDownload OpenCV 2.4.11\n, \nnote\n \nBuild OpenCV with video support\n\n\n$ cd ~/Downloads\n$ unzip opencv-2.4.11.zip\n$ cd opencv-2.4.11\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make -j4\n$ sudo make install\n$ cd ../..\n$ rm -rf opencv-2.4.11*\n\n\n\n\n\n\n\nInstall Qt 5.4.1\n\n\n$ sudo apt-get install qt5-default libqt5svg5-dev qtcreator\n\n\n\n\n\n\n\nCreate a \nGitHub\n account, follow their instructions for \nsetting up Git\n.\n\n\n$ git clone https://github.com/biometrics/openbr.git\n$ cd openbr\n$ git checkout 0.5\n$ git submodule init\n$ git submodule update\n\n\n\n\n\n\n\nBuild OpenBR!\n\n\n$ mkdir build # from the OpenBR root directory\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make -j4\n$ sudo make install\n\n\n\n\n\n\n\nHack OpenBR!\n\n\n\n\n\n\nOpen Qt Creator IDE\n\n\n$ qtcreator \n\n\n\n\n\n\nFrom the Qt Creator \"File\" menu select \"Open File or Project...\".\n\n\n\n\nSelect \"openbr/CMakeLists.txt\" then \"Open\".\n\n\nBrowse to your pre-existing build directory \"openbr/build\" then select \"Next\".\n\n\nSelect \"Run CMake\" then \"Finish\".\n\n\nYou're all set! You can find more information on Qt Creator \nhere\n if you need it.\n\n\n\n\n\n\n\n\n(Optional) Test OpenBR!\n\n\n$ cd openbr/scripts\n$ ./downloadDatasets.sh\n$ cd ../build\n$ make test\n\n\n\n\n\n\n\n(Optional) Package OpenBR!\n\n\n$ cd openbr/build\n$ sudo cpack -G TGZ\n\n\n\n\n\n\n\n(Optional) Build OpenBR documentation!\n\n\n\n\n\n\nNeed to rewrite this step for the new docs!\n\n\n\n\nOSX\n\n\n\n\n\n\nDownload and install the latest \"XCode\" and \"Command Line Tools\" from the \nApple Developer Downloads\n page.\n\n\n\n\n\n\nDownload CMake 3.0.2\n\n\n    $ cd ~/Downloads\n    $ tar -xf cmake-2.8.11.2.tar.gz\n    $ cd cmake-2.8.11.2\n    $ ./configure\n    $ make -j4\n    $ sudo make install\n    $ cd ..\n    $ rm -rf cmake-2.8.11.2*\n\n\n\n\n\n\n\nDownload OpenCV 2.4.11\n\n\n$ cd ~/Downloads\n$ unzip opencv-2.4.11.zip\n$ cd opencv-2.4.11\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make -j4\n$ sudo make install\n$ cd ../..\n$ rm -rf opencv-2.4.11*\n\n\n\n\n\n\n\nDownload and install Qt 5.4.1\n\n\n\n\n\n\nCreate a \nGitHub\n account, follow their instructions for \nsetting up Git\n.\n\n\n$ git clone https://github.com/biometrics/openbr.git\n$ cd openbr\n$ git checkout 0.5\n$ git submodule init\n$ git submodule update\n\n\n\n\n\n\n\nBuild OpenBR!\n\n\n$ mkdir build # from the OpenBR root directory\n$ cd build\n$ cmake -DCMAKE_PREFIX_PATH=~/Qt/5.4.1/clang_64 -DCMAKE_BUILD_TYPE=Release ..\n$ make -j4\n$ sudo make install\n\n\n\n\n\n\n\nHack OpenBR!\n\n\n\n\n\n\nOpen Qt Creator IDE\n\n\n$ open ~/Qt/Qt\\ Creator.app\n\n\n\n\n\n\n\nFrom the Qt Creator \"File\" menu select \"Open File or Project...\".\n\n\n\n\nSelect \"openbr/CMakeLists.txt\" then \"Open\".\n\n\nBrowse to your pre-existing build directory \"openbr/build\" then select \"Continue\".\n\n\nSelect \"Run CMake\" then \"Done\".\n\n\nYou're all set! You can find more information on Qt Creator \nhere\n if you need it.\n\n\n\n\n\n\n\n\n(Optional) Test OpenBR!\n\n\n$ cd openbr/scripts\n$ ./downloadDatasets.sh\n$ cd ../build\n$ make test\n\n\n\n\n\n\n\n(Optional) Package OpenBR!\n\n\n$ cd openbr/build\n$ sudo cpack -G TGZ\n\n\n\n\n\n\n\n(Optional) Build OpenBR documentation!\n\n\n\n\n\n\nNeed to remake this step with the new docs!\n\n\n\n\nWindows\n\n\n\n\n\n\nDownload Visual Studio Express 2013 for Windows Desktop\n and install. You will have to register with Microsoft, but it's free.\n\n\n\n\n\n\nDownload and Install CMake 3.0.2\n\n\n\n\nDuring installation setup select \"Add CMake to PATH\".\n\n\n\n\n\n\n\n\nDownload OpenCV 2.4.11\n\n\n\n\nConsider the free open source program \n7-Zip\n if you need a program to unarchive tarballs.\n\n\nMove the \"opencv-2.4.11\" folder to \"C:\\\".\n\n\nOpen \"VS2013 x64 Cross Tools Command Prompt\" (from the Start Menu, select \"All Programs\" -\n \"Microsoft Visual Studio 2013\" -\n \"Visual Studio Tools\" -\n \"VS2013 x64 Cross Tools Command Prompt\") and enter:\n$ cd C:\\opencv-2.4.11\n$ mkdir build-msvc2013\n$ cd build-msvc2013\n$ cmake -G \"NMake Makefiles\" -DBUILD_PERF_TESTS=OFF -DBUILD_TESTS=OFF -DWITH_FFMPEG=OFF -DCMAKE_BUILD_TYPE=Debug ..\n$ nmake\n$ nmake install\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ nmake\n$ nmake install\n$ nmake clean\n\n\n\n\n\n\n\n\n\n\n\nDownload and Install Qt 5.4.1\n\n\n\n\n\n\nCreate a \nGitHub\n account and follow their instructions for \nsetting up Git\n.\n\n\n\n\nLaunch \"Git Bash\" from the Desktop and clone OpenBR:\n$ cd /c\n$ git clone https://github.com/biometrics/openbr.git\n$ cd openbr\n$ git checkout 0.5\n$ git submodule init\n$ git submodule update\n\n\n\n\n\n\n\n\n\n\n\nBuild OpenBR!\n\n\n\n\n\n\nFrom the VS2013 x64 Cross Tools Command Prompt:\n\n\n$ cd C:\\openbr\n$ mkdir build-msvc2013\n$ cd build-msvc2013\n$ cmake -G \"CodeBlocks - NMake Makefiles\" -DCMAKE_PREFIX_PATH=\"C:/opencv-2.4.11/build/install;C:/Qt/Qt5.4.1/5.4/msvc2013_64\" -DCMAKE_INSTALL_PREFIX=\"./install\" -DBR_INSTALL_DEPENDENCIES=ON -DCMAKE_BUILD_TYPE=Release ..\n$ nmake\n$ nmake install\n\n\n\n\n\n\n\nCheck out the \"install\" folder.\n\n\n\n\n\n\n\n\n\n\nHack OpenBR!\n\n\n\n\nFrom the VS2013 x64 Cross Tools Command Prompt:\n    $ C:\\Qt\\Qt5.4.1\\Tools\\QtCreator\\bin\\qtcreator.exe\n\n\nFrom the Qt Creator \"Tools\" menu select \"Options...\"\n\n\nUnder \"Kits\" select \"Desktop (default)\"\n\n\nFor \"Compiler:\" select \"Microsoft Visual C++ Compiler 11.0 (x86_amd64)\" and click \"OK\"\n\n\nFrom the Qt Creator \"File\" menu select \"Open File or Project...\".\n\n\nSelect \"C:\\openbr\\CMakeLists.txt\" then \"Open\".\n\n\nIf prompted for the location of CMake, enter \"C:\\Program Files (x86)\\CMake 3.0.2\\bin\\cmake.exe\".\n\n\nBrowse to your pre-existing build directory \"C:\\openbr\\build-msvc2013\" then select \"Next\".\n\n\nSelect \"Run CMake\" then \"Finish\".\n\n\nYou're all set! You can find more information on Qt Creator \nhere\n if you need.\n\n\n\n\n\n\n\n\n(Optional) Package OpenBR!\n\n\n\n\nFrom the VS2013 x64 Cross Tools Command Prompt:\n    $ cd C:\\openbr\\build-msvc2013\n    $ cpack -G ZIP\n\n\n\n\n\n\n\n\n\n\nRaspian\n\n\n\n\n\n\nInstall CMake 2.8.9\n\n\n$ sudo apt-get install cmake\n\n\n\n\n\n\n\nDownload OpenCV 2.4.9\n\n\n$ wget http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.9/opencv-2.4.9.zip\n$ unzip opencv-2.4.9.zip\n$ cd opencv-2.4.9\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make\n$ sudo make install\n$ cd ../..\n$ rm -rf opencv-2.4.9*\n\n\n\n\n\n\n\nInstall Qt5\n\n\n\n\n\n\nModify source list\n\n\n$ nano /etc/apt/sources.list\n\n\n\nby changing:\n\n\n$ deb http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi\n\n\n\nto:\n\n\n$ deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi\n\n\n\n\n\n\n\n\n\n\n\nUpdate apt-get\n\n\n$ sudo apt-get update\n\n\n\n\n\n\n\nInstall packages\n\n\n$ sudo apt-get install qt5-default libqt5svg5-dev\n\n\n\n\n\n\n\nCreate a \nGitHub\n account, follow their instructions for \nsetting up Git\n.\n\n\n$ git clone https://github.com/biometrics/openbr.git\n$ cd openbr\n$ git checkout 0.5\n$ git submodule init\n$ git submodule update\n\n\n\n\n\n\n\nBuild OpenBR!\n\n\n$ mkdir build # from the OpenBR root directory\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make\n$ sudo make install\n\n\n\n\n\n\n\n(Optional) Test OpenBR!\n\n\n$ cd openbr/scripts\n$ ./downloadDatasets.sh\n$ cd ../build\n$ make test", 
            "title": "Install"
        }, 
        {
            "location": "/install/#linux", 
            "text": "Install GCC 4.9.2  $ sudo apt-get update\n$ sudo apt-get install build-essential    Install CMake 3.0.2  $ sudo apt-get install cmake cmake-curses-gui    Download OpenCV 2.4.11 ,  note   Build OpenCV with video support  $ cd ~/Downloads\n$ unzip opencv-2.4.11.zip\n$ cd opencv-2.4.11\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make -j4\n$ sudo make install\n$ cd ../..\n$ rm -rf opencv-2.4.11*    Install Qt 5.4.1  $ sudo apt-get install qt5-default libqt5svg5-dev qtcreator    Create a  GitHub  account, follow their instructions for  setting up Git .  $ git clone https://github.com/biometrics/openbr.git\n$ cd openbr\n$ git checkout 0.5\n$ git submodule init\n$ git submodule update    Build OpenBR!  $ mkdir build # from the OpenBR root directory\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make -j4\n$ sudo make install    Hack OpenBR!    Open Qt Creator IDE  $ qtcreator     From the Qt Creator \"File\" menu select \"Open File or Project...\".   Select \"openbr/CMakeLists.txt\" then \"Open\".  Browse to your pre-existing build directory \"openbr/build\" then select \"Next\".  Select \"Run CMake\" then \"Finish\".  You're all set! You can find more information on Qt Creator  here  if you need it.     (Optional) Test OpenBR!  $ cd openbr/scripts\n$ ./downloadDatasets.sh\n$ cd ../build\n$ make test    (Optional) Package OpenBR!  $ cd openbr/build\n$ sudo cpack -G TGZ    (Optional) Build OpenBR documentation!    Need to rewrite this step for the new docs!", 
            "title": "Linux"
        }, 
        {
            "location": "/install/#osx", 
            "text": "Download and install the latest \"XCode\" and \"Command Line Tools\" from the  Apple Developer Downloads  page.    Download CMake 3.0.2      $ cd ~/Downloads\n    $ tar -xf cmake-2.8.11.2.tar.gz\n    $ cd cmake-2.8.11.2\n    $ ./configure\n    $ make -j4\n    $ sudo make install\n    $ cd ..\n    $ rm -rf cmake-2.8.11.2*    Download OpenCV 2.4.11  $ cd ~/Downloads\n$ unzip opencv-2.4.11.zip\n$ cd opencv-2.4.11\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make -j4\n$ sudo make install\n$ cd ../..\n$ rm -rf opencv-2.4.11*    Download and install Qt 5.4.1    Create a  GitHub  account, follow their instructions for  setting up Git .  $ git clone https://github.com/biometrics/openbr.git\n$ cd openbr\n$ git checkout 0.5\n$ git submodule init\n$ git submodule update    Build OpenBR!  $ mkdir build # from the OpenBR root directory\n$ cd build\n$ cmake -DCMAKE_PREFIX_PATH=~/Qt/5.4.1/clang_64 -DCMAKE_BUILD_TYPE=Release ..\n$ make -j4\n$ sudo make install    Hack OpenBR!    Open Qt Creator IDE  $ open ~/Qt/Qt\\ Creator.app    From the Qt Creator \"File\" menu select \"Open File or Project...\".   Select \"openbr/CMakeLists.txt\" then \"Open\".  Browse to your pre-existing build directory \"openbr/build\" then select \"Continue\".  Select \"Run CMake\" then \"Done\".  You're all set! You can find more information on Qt Creator  here  if you need it.     (Optional) Test OpenBR!  $ cd openbr/scripts\n$ ./downloadDatasets.sh\n$ cd ../build\n$ make test    (Optional) Package OpenBR!  $ cd openbr/build\n$ sudo cpack -G TGZ    (Optional) Build OpenBR documentation!    Need to remake this step with the new docs!", 
            "title": "OSX"
        }, 
        {
            "location": "/install/#windows", 
            "text": "Download Visual Studio Express 2013 for Windows Desktop  and install. You will have to register with Microsoft, but it's free.    Download and Install CMake 3.0.2   During installation setup select \"Add CMake to PATH\".     Download OpenCV 2.4.11   Consider the free open source program  7-Zip  if you need a program to unarchive tarballs.  Move the \"opencv-2.4.11\" folder to \"C:\\\".  Open \"VS2013 x64 Cross Tools Command Prompt\" (from the Start Menu, select \"All Programs\" -  \"Microsoft Visual Studio 2013\" -  \"Visual Studio Tools\" -  \"VS2013 x64 Cross Tools Command Prompt\") and enter: $ cd C:\\opencv-2.4.11\n$ mkdir build-msvc2013\n$ cd build-msvc2013\n$ cmake -G \"NMake Makefiles\" -DBUILD_PERF_TESTS=OFF -DBUILD_TESTS=OFF -DWITH_FFMPEG=OFF -DCMAKE_BUILD_TYPE=Debug ..\n$ nmake\n$ nmake install\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ nmake\n$ nmake install\n$ nmake clean      Download and Install Qt 5.4.1    Create a  GitHub  account and follow their instructions for  setting up Git .   Launch \"Git Bash\" from the Desktop and clone OpenBR: $ cd /c\n$ git clone https://github.com/biometrics/openbr.git\n$ cd openbr\n$ git checkout 0.5\n$ git submodule init\n$ git submodule update      Build OpenBR!    From the VS2013 x64 Cross Tools Command Prompt:  $ cd C:\\openbr\n$ mkdir build-msvc2013\n$ cd build-msvc2013\n$ cmake -G \"CodeBlocks - NMake Makefiles\" -DCMAKE_PREFIX_PATH=\"C:/opencv-2.4.11/build/install;C:/Qt/Qt5.4.1/5.4/msvc2013_64\" -DCMAKE_INSTALL_PREFIX=\"./install\" -DBR_INSTALL_DEPENDENCIES=ON -DCMAKE_BUILD_TYPE=Release ..\n$ nmake\n$ nmake install    Check out the \"install\" folder.      Hack OpenBR!   From the VS2013 x64 Cross Tools Command Prompt:\n    $ C:\\Qt\\Qt5.4.1\\Tools\\QtCreator\\bin\\qtcreator.exe  From the Qt Creator \"Tools\" menu select \"Options...\"  Under \"Kits\" select \"Desktop (default)\"  For \"Compiler:\" select \"Microsoft Visual C++ Compiler 11.0 (x86_amd64)\" and click \"OK\"  From the Qt Creator \"File\" menu select \"Open File or Project...\".  Select \"C:\\openbr\\CMakeLists.txt\" then \"Open\".  If prompted for the location of CMake, enter \"C:\\Program Files (x86)\\CMake 3.0.2\\bin\\cmake.exe\".  Browse to your pre-existing build directory \"C:\\openbr\\build-msvc2013\" then select \"Next\".  Select \"Run CMake\" then \"Finish\".  You're all set! You can find more information on Qt Creator  here  if you need.     (Optional) Package OpenBR!   From the VS2013 x64 Cross Tools Command Prompt:\n    $ cd C:\\openbr\\build-msvc2013\n    $ cpack -G ZIP", 
            "title": "Windows"
        }, 
        {
            "location": "/install/#raspian", 
            "text": "Install CMake 2.8.9  $ sudo apt-get install cmake    Download OpenCV 2.4.9  $ wget http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.9/opencv-2.4.9.zip\n$ unzip opencv-2.4.9.zip\n$ cd opencv-2.4.9\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make\n$ sudo make install\n$ cd ../..\n$ rm -rf opencv-2.4.9*    Install Qt5    Modify source list  $ nano /etc/apt/sources.list  by changing:  $ deb http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi  to:  $ deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi      Update apt-get  $ sudo apt-get update    Install packages  $ sudo apt-get install qt5-default libqt5svg5-dev    Create a  GitHub  account, follow their instructions for  setting up Git .  $ git clone https://github.com/biometrics/openbr.git\n$ cd openbr\n$ git checkout 0.5\n$ git submodule init\n$ git submodule update    Build OpenBR!  $ mkdir build # from the OpenBR root directory\n$ cd build\n$ cmake -DCMAKE_BUILD_TYPE=Release ..\n$ make\n$ sudo make install    (Optional) Test OpenBR!  $ cd openbr/scripts\n$ ./downloadDatasets.sh\n$ cd ../build\n$ make test", 
            "title": "Raspian"
        }, 
        {
            "location": "/tutorials/", 
            "text": "Welcome to OpenBR! Here we have a series of tutorials designed to get you up to speed on what OpenBR is, how it works, and its command line interface. These tutorials aren't meant to be completed in a specific order so feel free to hop around. If you need help, feel free to \ncontact us\n.\n\n\n\n\nQuick Start\n\n\nThis tutorial is meant to familiarize you with the ideas, objects and motivations behind OpenBR using some fun examples. \nNote that parts of this tutorial require a webcam.\n\n\nOpenBR is a C++ library built on top of \nQt\n, \nOpenCV\n, and \nEigen\n. It can either be used from the command line using the \nbr\n application, or from interfacing with the \nC++\n or \nC\n APIs. Using the \nbr\n application is the easiest and fastest way to get started and this tutorial will use it for all of the examples.\n\n\nFirst, make sure that OpenBR has been installed on your system using the steps described in the \ninstallation section\n.\n\n\nOpen up your terminal or command prompt and enter:\n\n\n$ br -gui -algorithm \"Show(false)\" -enroll 0.webcam\n\n\n\nIf everything has gone according to plan, your webcam should be on and capturing video. Congratulations, you are using OpenBR!\n\n\nLet's talk about what's happening in the above command. \n-gui\n, \n-algorithm\n, and \n-enroll\n are examples of OpenBR's flags and are used to specify instructions to \nbr\n. OpenBR expects flags to be prepended by a \n-\n and arguments that follow the flags to be separated by spaces. Flags normally require a specific number of arguments. All of the possible flags and their values are \ndocumented here\n. Let's step through the individual arguments and values:\n\n\n\n\n-gui\n is the flag that tells OpenBR to open up a GUI window. Note that when \n-gui\n is used, it must be the first flag passed to \nbr\n.\n\n\n-algorithm\n is one of the most important flags in OpenBR. It expects one argument, referred to as the \nalgorithm string\n. This string determines the pipeline through which images and metadata propagate. It is composed of \nTransforms\n, which are described in detail later in this tutorial.\n\n\n-enroll\n reads files from a \nGallery\n or a \nFormat\n and \nenrolls\n them through the algorithm pipeline and serializes them to another \nGallery\n or \nFormat\n. \n-enroll\n takes one input argument (\n0.webcam\n in this example) and an optional output argument. OpenBR supports multiple formats including \n.jpg\n, \n.png\n, \n.csv\n, and \n.xml\n. The \n.webcam\n \nFormat\n tells OpenBR to enroll frames from the computer's webcam.\n\n\n\n\nLet's try a slightly more complicated example. After all, OpenBR can do way more then just open webcams! Fire up the terminal again and enter:\n\n\n$ br -gui -algorithm \"Cvt(Gray)+Show(false)\" -enroll 0.webcam\n\n\n\nHere, we took our normal BGR (OpenCV's alternative to RGB) image and converted it to a grayscale image simply by adding \nCvt(Gray)\n to the algorithm string. \nCvt\n, short for convert, is an example of an OpenBR \nTransform\n. \nShow\n is a \nTransform\n as well. In fact, every algorithm string in OpenBR is just a series of \nTransform\ns joined to form a pipeline; even the \n+\n symbol is shorthand for a \nPipe\n, another kind of OpenBR \nTransform\n.\n\n\nTypically, \nTransform\ns accept parameters.  We specify \nGray\n to \nCvt\n as a runtime parameter to tell the \nTransform\n which color space to convert the image to. We also could have written \nCvt(HSV)\n if we wanted to convert to the HSV color space or \nCvt(Luv)\n if we wanted to convert to LUV. Parameters can be provided as key-value pairs or as keyless values (\nCvt(Gray)\n is equivalent to \nCvt(colorSpace=Gray)\n) . Note that if you are supplying values only, the parameters are expected to be supplied in the order they are defined. Try changing the algorithm string above to include \nShow(true)\n to see how modifying the parameters affects the output of the command (Hint: hit a key to cycle through the images).\n\n\nLet's make this example a little bit more exciting and relevant to OpenBR's biometric roots. Face detection is normally the first step in a \nface recognition\n algorithm. Let's perform face detection in OpenBR. Back in the terminal enter:\n\n\n$ br -gui -algorithm \"Cvt(Gray)+Cascade(FrontalFace)+Draw(lineThickness=3)+Show(false)\" -enroll 0.webcam\n\n\n\nYou're webcam should be open again but this time a bounding-box should have appeared around your face! We added two new \nTransform\ns to our string: \nCascade\n and \nDraw\n. Let's walk through this \nTransform\n by \nTransform\n and see how it works:\n\n\n\n\nCvt(Gray)\n: Convert the image from BGR to grayscale. Grayscale is required for \nCascade\n to work properly.\n\n\nCascade(FrontalFace)\n: This is a wrapper on the OpenCV \nCascade Classification\n framework. It detects frontal faces using the \nFrontalFace\n model.\n\n\nDraw(lineThickness=3)\n: Take the rectangles detected by \nCascade\n and draw them onto the frame from the webcam. \nlineThickness\n determines the thickness of the drawn rectangle.\n\n\nShow(false)\n: Show the image in a GUI window. \nfalse\n indicates the images should be shown in succession without waiting for a key press.\n\n\n\n\nEach \nTransform\n completes one task and the passes the output on to the next \nTransform\n. You can pipe together as many \nTransform\ns as you like, but note that certain \nTransform\ns have specific expectations for their input.\n\n\nYou may be wondering what objects are actually being propagated through the algorithm pipeline. There are two objects that handle data in OpenBR:\n\n\n\n\nFile\ns are typically used to store the path to a file on disk with associated metadata (in the form of key-value pairs). In the example above, we store the rectangles detected by \nCascade\n as metadata which are then used by \nDraw\n for visualization.\n\n\nTemplate\ns are containers for images and \nFile\ns. Images in OpenBR are OpenCV Mats and are member variables of Templates. Templates can contain one or more images.\n\n\n\n\nIf you want to learn more about the \ncommand line\n or \nall of the plugins and the key data structures\n, please refer to the linked documentation.  The next few tutorials will explore algorithms and their use in more depth.\n\n\n\n\nAlgorithms in OpenBR\n\n\nOne advantage of OpenBR is the ease with which one can express biometrics algorithms in a consistent and simple way. In OpenBR, an algorithm string defines a technique for enrolling images and (optionally) a method for comparing them.\n\n\nInstead of storing the entire raw image for comparison, it is common practice to store an optimized representation, or \ntemplate\n, of the image for the task at hand. We note for the sake of clarity that while the OpenBR object \nTemplate\n gets it name from this concept, \ntemplate\n is a more general biometrics concept. The process of generating this optimized representation is called \ntemplate enrollment\n or \ntemplate generation\n. Given two templates, \ntemplate comparison\n computes the similarity between them, where the higher values indicate more probable matches. Operationally, one seeks to generate templates that are small, accurate, and fast to compare.\n\n\nAs previously noted, an algorithm is defined in OpenBR through an algorithm string. There are several advantages in mandating that algorithms are defined from strings, the most important of which are the following:\n\n\n\n\nIt ensures good software development practices by forcibly decoupling the development of each step in an algorithm, facilitating the modification of algorithms and the re-use of individual steps.\n\n\nIt spares the creation and maintenance of a lot of very similar header files that would otherwise be needed for each step in an algorithm (observe the absence of headers in \nopenbr/plugins\n files).\n\n\nIt allows for algorithm parameter tuning without recompiling.\n\n\nIt is completely unambiguous, both the OpenBR interpreter and anyone familiar with the project can understand exactly what your algorithm does just from this description.\n\n\n\n\nOpenBR provides a syntax for setting plugin property values and creating concise algorithm strings. The relevant symbols are:\n\n\n\n\n\n\n\n\nSymbol\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nPluginName(property1=value1,...propertyN=valueN)\n\n\nA plugin is described by its name (without the abstraction) and a list of properties and values. Properties of a plugin that are not specified are set to their default values.\n\n\n\n\n\n\n:\n\n\nSeperates \ntemplate enrollment\n from \ntemplate comparison\n. Enrollment is on the left of the colon in the algorithm string, while comparison is on the right. Defining an algorithm with a template comparison step is optional.\n\n\n\n\n\n\n+\n\n\nAbbreviation for a \nPipe\n. Joins \nTransform\ns together and projects input through them in series. The output of a \nTransform\n to the left of + become the input of the Transform to the right.\n\n\n\n\n\n\n/\n\n\nAbbreviation for a \nFork\n. Joins \nTransform\ns together and projects input through them in parallel. All \nTransform\ns receive the same input, the output of which is concatenated together.\n\n\n\n\n\n\n{}\n\n\nAbbreviation for \nCache\n. Cache the output of a plugin in memory for quick lookups later on.\n\n\n\n\n\n\n>\n\n\nAbbreviation for \nLoadStore\n. Parameters for \nTransform\ns inside the brackets are stored on disk after training and loaded from disk before projection.\n\n\n\n\n\n\n()\n\n\nOrder of operations. Change the order of operations using parantheses.\n\n\n\n\n\n\n\n\nLet's look at some of the important parts of the codebase that make this possible:\n\n\nIn \nAlgorithmCore::init()\n in \nopenbr/core/core.cpp\n you can see the code for splitting the algorithm description at the colon.\nShortly thereafter in this function we \nmake\n the template generation and comparison objects.\nThese \nmake\n calls are defined in the public \nC++ plugin API\n and can also be called from end user code.\n\n\nBelow we discuss some of the source code for \nTransform::make\n in \nopenbr/openbr_plugin.cpp\n.\nNote, the \nmake\n functions for other plugin types are similar in spirit and will not be covered.\n\n\nOne of the first steps when converting the template generation description into \nTransform\ns is to replace the operators, like '+', with their full form:\n\n\n{ // Check for use of '+' as shorthand for Pipe(...)\n     QStringList words = parse(str, '+');\n     if (words.size() \n 1)\n         return make(\"Pipe([\" + words.join(\",\") + \"])\", parent);\n}\n\n\n\nAfter operator expansion, the template enrollment description forms a tree, and the \nTransform\n is constructed from this description recursively, starting at the root of the tree:\n\n\nTransform *transform = Factory\nTransform\n::make(\".\" + str);\n\n\n\nLet's use the algorithm in \nscripts/helloWorld.sh\n as an example. The algorithm is:\n\n\nOpen+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95):Dist(L2)\n\n\n\nLet's expand this using our new knowledge of OpenBR's algorithm syntax. First, the algorithm will be split into enrollment and comparison portions at the \n:\n. So enrollment becomes:\n\n\nOpen+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95)\n\n\n\nand comparison is:\n\n\nDist(L2)\n\n\n\nOn the enrollment side, \nTransform\ns joined by the \n+\n operators are converted into children of a \nPipe\n. Thus, the enrollment algorithm is constructed as:\n\n\nPipe(transforms=[Open,Cvt(Gray),Cascade(FrontalFace),ASEFEyes,Affine(128,128,0.33,0.45,CvtFloat,PCA(0.95)])\n\n\n\nLow-level detail of the operations involved in this algorithm can be found in the \nproject\n function implemented by each of these \nTransform\ns.\nTo briefly summarize:\n\n\n1. Reads the image from disk\n2. Converts the image to grayscale\n3. Detects faces\n4. Detects eyes in detected faces\n5. Normalize the face with respect to rotation and scale using the eye locations\n6. Converts the image to floating point format\n7. Embeds the image in a PCA subspace trained on face images\n\n\n\nIf you are familiar with face recognition, you will likely recognize this as the Eigenfaces\n1\n algorithm.\n\n\nAs a final note, the Eigenfaces algorithms uses the Euclidean distance (or L2-norm) to compare templates.\nSince OpenBR expects similarity values when comparing templates and not dissimilarity values, the \nDistDistance\n will return \n-log(distance+1)\n by default so that smaller distances (in the Euclidean sense) indicate higher similarity.\nNote that \nNegativeLogPlusOne\n distance also exists such that you can convert the output of any distance using the above function.\n\n\n\n\nTraining Algorithms\n\n\nOpenBR makes it easy to create and train your own algorithms on custom datasets. Let's start with the algorithm string for the Eigenfaces\n1\n algorithm described in the \nAlgorithms\n tutorial. Recall that the algorithm is:\n\n\n$ Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95)\n\n\n\nSuppose we want to train this algorithm on some data we gathered. First, let's examine some of the underlying principles of training in OpenBR. Recall that every algorithm is composed of \nTransforms\n but not all \nTransforms\n need to be trained. In our example, \nCvt(Gray)\n, which converts the image to grayscale, does not need to be trained at all, and neither does \nOpen\n, \nASEFEyes\n, \nAffine(128,128,0.33,0.45)\n or \nCvtFloat\n. These are \nUntrainableTransforms\n (a subclass of \nTransform\n). \nCascade(FrontalFace)\n is a special case; it is a \nTransform\n and therefore can be trained. However, we have passed it an argument indicating it should use pre-trained model (\nFrontalFace\n). Thus, \nPCA(0.95)\n is the only trainable \nTransform\n in our algorithm string.  For the sake of completeness, we note that this transform is performing principal component analysis and retaining dimensions that account for 95% of the variance.\n\n\nOf course, we need to supply data to train our algorithm. Let's step back and consider the full training command. An example of this might be:\n\n\n$ br -algorithm \"Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95)\" -train training_data.csv EigenFaces\n\n\n\nNotice the \n-train\n flag used in the algorithm. \n-train\n requires at least one argument, a training \nGallery\n. Note that certain \nTransform\ns expect \nlabelled\n training data. While \n-train\n needs only a single gallery \nGallery\n, more than one can be provided:\n\n\n$ br -algorithm \"Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95)\" -train training_data1.csv training_data2.csv EigenFaces\n\n\n\n-train\n has an optional second argument: the name for a trained model (\nEigenFaces\n in the example above). The optional model file is a serialized and compressed binary file that stores the parameters learned during algorithm training.  The model file should only be considered optional when your algorithm string uses a \nLoadStoreTransform\n (discussed in depth later in this tutorial).  Otherwise, none of the parameters learned during algorithm training will be stored!\n\n\nAs was briefly discussed above, each \nTransform\n in is either \ntrainable\n or not (in our case only \nPCA(0.95)\n is trainable). At train time, the training data is projected through each \nUntrainableTransform\n in sequence, just as it would be at test time. When the data reaches a trainable transform, the \ntrain\n method is called with the data projected through the preceding \nTransforms\n as its input. After training, the project method is called on the newly trained transform and the data continues to propagate through the algorithm.\n\n\nAfter training is complete the algorithm is serialized to a model file (if you have specified one). The algorithm string is serialized first such that the algorithm can be recreated, followed by the parameters for each transform using the \nstore\n method. Note that only trainable \nTransforms\n need to implement \nstore\n because \nUntrainableTransforms\n can be recreated solely from their algorithm string descriptions.\n\n\nWe can then \n-enroll\n images using the trained algorithm by replacing the algorithm string with the model file:\n\n\n$ br -algorithm EigenFaces -enroll enroll_data.csv enroll_data.gal\n\n\n\nIn the case that we want our training and testing algorithms to be different, we can use \nLoadStoreTransform\n to serialize specific parts of the algorithm string. Reusing our EigenFaces example, we could specify that only \nCvtFloat\n and \nPCA(0.95)\n should be serialized to the model, allowing the other algorithmic steps to be specified at test time. The command to accomplish this is:\n\n\n$ br -algorithm \"Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+\nCvtFloat+PCA(0.95),EigenFaces\n\" -train training_data.csv\n\n\n\nRecall from the \nAlgorithms\n tutorial that \n is shorthand for a \nLoadStoreTransform\n. Also note that the \nLoadStoreTransform\n takes two arguments: the algorithm string and an optional model name. If a name is not provided, a random name is created. Using this model would like this:\n\n\n$ br -algorithm \"Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.2,0.55)+\nEigenFaces\n\"\n\n\n\nSince we haven't serialized that portion of the algorithm, the parameters of \nAffine\n, for example, can now be changed at test time! Note that, in this contrived example, changing the \nAffine\n parameters will severely degrade performance. As a final note, when a \nLoadStoreTransform\n is present in the algorithm string used for training, OpenBR will not overwrite the specified model file if it already exists. Instead, it will load the old model file and treat the associated \nTransforms\n as untrainable (as they have already been trained!). This can helpful when you want to isolate a particular algorithmic step (e.g. to explore parameters) but don't want to retrain every part of the algorithm during each iteration.\n\n\nNow that we've covered training a generic algorithm, the next tutorials will cover popular use cases supported by OpenBR including \nFaceRecognition\n, \nAge Estimation\n, and \nGender Estimation\n.\n\n\n\n\nFace Recognition\n\n\nThis tutorial gives an example on how to perform face recognition in OpenBR. OpenBR implements the 4SF\n2\n algorithm to perform face recognition. Please read the paper for more specific algorithm details.\n\n\nTo start, lets run face recognition from the command line. Open the terminal and enter\n\n\n$ br -algorithm FaceRecognition \\\n    -compare ../data/MEDS/img/S354-01-t10_01.jpg ../data/MEDS/img/S354-02-t10_01.jpg \\\n     -compare ../data/MEDS/img/S354-01-t10_01.jpg ../data/MEDS/img/S386-04-t10_01.jpg\n\n\n\nEasy enough? You should see results printed to terminal that look like\n\n\n$ Set algorithm to FaceRecognition\n$ Loading /usr/local/share/openbr/models/algorithms/FaceRecognition\n$ Loading /usr/local/share/openbr/models/transforms//FaceRecognitionExtraction\n$ Loading /usr/local/share/openbr/models/transforms//FaceRecognitionEmbedding\n$ Loading /usr/local/share/openbr/models/transforms//FaceRecognitionQuantization\n$ Comparing ../data/MEDS/img/S354-01-t10_01.jpg and ../data/MEDS/img/S354-02-t10_01.jpg\n$ Enrolling ../data/MEDS/img/S354-01-t10_01.jpg to S354-01-t10_01r7Rv4W.mem\n$ 100.00%  ELAPSED=00:00:00  REMAINING=00:00:00  COUNT=1\n$ 100.00%  ELAPSED=00:00:00  REMAINING=00:00:00  COUNT=1\n$ 1.8812\n$ Comparing ../data/MEDS/img/S354-01-t10_01.jpg and ../data/MEDS/img/S386-04-t10_01.jpg\n$ Enrolling ../data/MEDS/img/S354-01-t10_01.jpg to S354-01-t10_01r7Rv4W.mem\n$ 100.00%  ELAPSED=00:00:00  REMAINING=00:00:00  COUNT=1\n$ 100.00%  ELAPSED=00:00:00  REMAINING=00:00:00  COUNT=1\n$ 0.571219\n\n\n\nSo, what is \nFaceRecognition\n? It's an abbrieviation to simplify execution of the algorithm. All of the algorithm abbreviations are located in \nopenbr/plugins/core/algorithms.cpp\n.\n\n\nIt is also possible to:\n\n\n\n\n\n\nEvaluate face recognition performance (Note that this requires \nR\n to be installed):\n\n\n$ br -algorithm FaceRecognition -path ../data/MEDS/img/ \\\n-enroll ../data/MEDS/sigset/MEDS_frontal_target.xml target.gal \\\n-enroll ../data/MEDS/sigset/MEDS_frontal_query.xml query.gal \\\n-compare target.gal query.gal scores.mtx \\\n-makeMask ../data/MEDS/sigset/MEDS_frontal_target.xml ../data/MEDS/sigset/MEDS_frontal_query.xml MEDS.mask \\\n-eval scores.mtx MEDS.mask Algorithm_Dataset/FaceRecognition_MEDS.csv \\\n-plot Algorithm_Dataset/FaceRecognition_MEDS.csv MEDS\n\n\n\n\n\n\n\nPerform a 1:N face recognition search:\n\n\n$ br -algorithm FaceRecognition -enrollAll -enroll ../data/MEDS/img 'meds.gal'\n$ br -algorithm FaceRecognition -compare meds.gal ../data/MEDS/img/S001-01-t10_01.jpg match_scores.csv\n\n\n\n\n\n\n\nTrain a new face recognition algorithm (on a different dataset):\n\n\n$ br -algorithm 'Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+(Grid(10,10)+SIFTDescriptor(12)+ByRow)/(Blur(1.1)+Gamma(0.2)+DoG(1,2)+ContrastEq(0.1,10)+LBP(1,2)+RectRegions(8,8,6,6)+Hist(59))+PCA(0.95)+Normalize(L2)+Dup(12)+RndSubspace(0.05,1)+LDA(0.98)+Cat+PCA(0.95)+Normalize(L1)+Quantize:NegativeLogPlusOne(ByteL1)' -train ../data/ATT/img FaceRecognitionATT\n\n\n\n\n\n\n\nThe entire command line API is documented \nhere\n.\n\n\n\n\nAge Estimation\n\n\nAge estimation is very similar in spirit to \nFace Recognition\n and will be covered in far less detail.\n\n\nTo perform age estimation from the command line you can run:\n\n\n$ br -algorithm AgeEstimation \\\n    -enroll ../data/MEDS/img/S354-01-t10_01.jpg ../data/MEDS/img/S001-01-t10_01.jpg metadata.csv\n\n\n\nThe results will be stored in metadata.csv under the key 'Age'. Remember from the \nFace Recognition\n tutorial that \nAgeEstimation\n is just an abbreviation for the full algorithm description.\n\n\nThe source code to run age estimation as an application is in \napp/examples/age_estimation.cpp\n\n\n\n\nGender Estimation\n\n\nAs with age estimation, gender estimation is very similar in spirit to \nFace Recognition\n and will be covered in far less detail.\n\n\nTo perform gender estimation from the command line you can run:\n\n\n$ br -algorithm GenderEstimation \\\n    -enroll ../data/MEDS/img/S354-01-t10_01.jpg ../data/MEDS/img/S001-01-t10_01.jpg metadata.csv\n\n\n\nThe results will be stored in metadata.csv under the key 'Gender'. Remember from the \nFace Recognition\n tutorial that \nGenderEstimation\n is just an abbreviation for the full algorithm description.\n\n\nThe source code to run gender estimation as an application is in \napp/examples/gender_estimation.cpp\n\n\n\n\nOpenBR as a Library\n\n\nOpenBR exposes a \nC++ API\n that can be embedded into your own applications. Let's step through the example code at \napp/example/face_recognition.cpp\n and learn about using OpenBR as a library.\n\n\nOur main function starts with:\n\n\nbr::Context::initialize(argc, argv)\n\n\n\nThis is the first step in any OpenBR-based application, it initializes the global context.\n\n\nQSharedPointer\nbr::Transform\n transform = br::Transform::fromAlgorithm(\"FaceRecognition\");\nQSharedPointer\nbr::Distance\n distance = br::Distance::fromAlgorithm(\"FaceRecognition\");\n\n\n\nHere, we split our algorithm into \nenrollment\n (\nTransform\n::\nfromAlgorithm\n) and \ncomparison\n (\nDistance\n::\nfromAlgorithm\n)\n\n\nbr::Template queryA(\"../data/MEDS/img/S354-01-t10_01.jpg\");\nbr::Template queryB(\"../data/MEDS/img/S382-08-t10_01.jpg\");\nbr::Template target(\"../data/MEDS/img/S354-02-t10_01.jpg\");\n\n\n\nThese lines create our \nTemplate\ns for enrollment. At this point, the Templates simply store the file path to the specified image on disk. In this example, \nqueryA\n depicts the same person as \ntarget\n (often referred to as a \ngenuine match\n) and \nqueryB\n depicts a different person from \ntarget\n (often referred to as an \nimpostor match\n).\n\n\nqueryA \n *transform;\nqueryB \n *transform;\ntarget \n *transform;\n\n\n\n is a convienience operator for enrolling \nTemplate\ns in \nTransform\ns. Thus, at this stage, our \nTemplate\ns now store the images enrolled via the \nFaceRecognition\n algorithm.\n\n\nfloat comparisonA = distance-\ncompare(target, queryA);\nfloat comparisonB = distance-\ncompare(target, queryB);\n\n\n\nWe then compare our query \nTemplate\ns against the target \nTemplate\n. The result is a floating point value indicating similarity.\n\n\nprintf(\"Genuine match score: %.3f\\n\", comparisonA);\nprintf(\"Impostor match score: %.3f\\n\", comparisonB);\n\n\n\nAfter printing the results, you can see that \ncomparisonA\n (between \nqueryA\n and \ntarget\n) has a higher similarity score then \ncomparisonB\n, which is exactly what we expect!\n\n\nbr::Context::finalize();\n\n\n\nThe last line in any OpenBR application has to be call to \nfinalize\n. This functions performs the clean up of OpenBR.\n\n\nThat's it! You can now embed face recognition into all of your applications.\n\n\n\n\nThe Evaluation Harness\n\n\nOpenBR implements a complete, \nNIST\n compliant, evaluation harness for evaluating face recognition, face detection, and facial landmarking. The goal is to provide a consistent environment for the repeatable evaluation of algorithms to the academic and open source communities. To accompish this OpenBR defines the following portions of the biometrics evaluation environment (BEE) standard-\n\n\n\n\n\n\nSignature set - A signature set (or \nsigset\n) is an XML file-list specified on page 9 of the \nMBGC File Overview\n and is implemented in \nxmlGallery\n. Sigsets are identified with an \n.xml\n extension.\n\n\n\n\n\n\nSimilarity matrix - A similarity matrix (or \nsimmat\n) is a binary score matrix specified on page 12 of the \nMBGC File Overview\n and is implemented in \nmtxOutput\n. Simmats are identified with a \n.mtx\n extension. See \nbr_eval\n for more information.\n\n\n\n\n\n\nMask matrix - A mask matrix (or \nmask\n) is a binary matrix specified on page 14 of the \nMBGC File Overview\n identifying the genuine and impostor matches within a corresponding \nsimmat\n. Masks are identified with a \n.mask\n extension. See \nbr_make_mask\n and \nbr_combine_masks\n for more information.\n\n\n\n\n\n\nThe evaluation harness is also accessible from the command line. See \n-eval\n, \n-evalDetection\n, \n-evalLandmarking\n, \n-evalClassification\n, \n-evalClustering\n, or \n-evalRegression\n for relevant information.\n\n\n\n\n\n\n\n\n\n\nMatthew Turk and Alex Pentland.\n\n\nEigenfaces for recognition.\n\nJournal of Cognitive Neuroscience, 71\n86, 1991 \n\n\n\n\n\n\nB. Klare.\n\n\nSpectrally sampled structural subspace features (4SF).\n\nIn Michigan State University Technical Report, MSUCSE-11-16, 2011", 
            "title": "Tutorials"
        }, 
        {
            "location": "/tutorials/#quick-start", 
            "text": "This tutorial is meant to familiarize you with the ideas, objects and motivations behind OpenBR using some fun examples.  Note that parts of this tutorial require a webcam.  OpenBR is a C++ library built on top of  Qt ,  OpenCV , and  Eigen . It can either be used from the command line using the  br  application, or from interfacing with the  C++  or  C  APIs. Using the  br  application is the easiest and fastest way to get started and this tutorial will use it for all of the examples.  First, make sure that OpenBR has been installed on your system using the steps described in the  installation section .  Open up your terminal or command prompt and enter:  $ br -gui -algorithm \"Show(false)\" -enroll 0.webcam  If everything has gone according to plan, your webcam should be on and capturing video. Congratulations, you are using OpenBR!  Let's talk about what's happening in the above command.  -gui ,  -algorithm , and  -enroll  are examples of OpenBR's flags and are used to specify instructions to  br . OpenBR expects flags to be prepended by a  -  and arguments that follow the flags to be separated by spaces. Flags normally require a specific number of arguments. All of the possible flags and their values are  documented here . Let's step through the individual arguments and values:   -gui  is the flag that tells OpenBR to open up a GUI window. Note that when  -gui  is used, it must be the first flag passed to  br .  -algorithm  is one of the most important flags in OpenBR. It expects one argument, referred to as the  algorithm string . This string determines the pipeline through which images and metadata propagate. It is composed of  Transforms , which are described in detail later in this tutorial.  -enroll  reads files from a  Gallery  or a  Format  and  enrolls  them through the algorithm pipeline and serializes them to another  Gallery  or  Format .  -enroll  takes one input argument ( 0.webcam  in this example) and an optional output argument. OpenBR supports multiple formats including  .jpg ,  .png ,  .csv , and  .xml . The  .webcam   Format  tells OpenBR to enroll frames from the computer's webcam.   Let's try a slightly more complicated example. After all, OpenBR can do way more then just open webcams! Fire up the terminal again and enter:  $ br -gui -algorithm \"Cvt(Gray)+Show(false)\" -enroll 0.webcam  Here, we took our normal BGR (OpenCV's alternative to RGB) image and converted it to a grayscale image simply by adding  Cvt(Gray)  to the algorithm string.  Cvt , short for convert, is an example of an OpenBR  Transform .  Show  is a  Transform  as well. In fact, every algorithm string in OpenBR is just a series of  Transform s joined to form a pipeline; even the  +  symbol is shorthand for a  Pipe , another kind of OpenBR  Transform .  Typically,  Transform s accept parameters.  We specify  Gray  to  Cvt  as a runtime parameter to tell the  Transform  which color space to convert the image to. We also could have written  Cvt(HSV)  if we wanted to convert to the HSV color space or  Cvt(Luv)  if we wanted to convert to LUV. Parameters can be provided as key-value pairs or as keyless values ( Cvt(Gray)  is equivalent to  Cvt(colorSpace=Gray) ) . Note that if you are supplying values only, the parameters are expected to be supplied in the order they are defined. Try changing the algorithm string above to include  Show(true)  to see how modifying the parameters affects the output of the command (Hint: hit a key to cycle through the images).  Let's make this example a little bit more exciting and relevant to OpenBR's biometric roots. Face detection is normally the first step in a  face recognition  algorithm. Let's perform face detection in OpenBR. Back in the terminal enter:  $ br -gui -algorithm \"Cvt(Gray)+Cascade(FrontalFace)+Draw(lineThickness=3)+Show(false)\" -enroll 0.webcam  You're webcam should be open again but this time a bounding-box should have appeared around your face! We added two new  Transform s to our string:  Cascade  and  Draw . Let's walk through this  Transform  by  Transform  and see how it works:   Cvt(Gray) : Convert the image from BGR to grayscale. Grayscale is required for  Cascade  to work properly.  Cascade(FrontalFace) : This is a wrapper on the OpenCV  Cascade Classification  framework. It detects frontal faces using the  FrontalFace  model.  Draw(lineThickness=3) : Take the rectangles detected by  Cascade  and draw them onto the frame from the webcam.  lineThickness  determines the thickness of the drawn rectangle.  Show(false) : Show the image in a GUI window.  false  indicates the images should be shown in succession without waiting for a key press.   Each  Transform  completes one task and the passes the output on to the next  Transform . You can pipe together as many  Transform s as you like, but note that certain  Transform s have specific expectations for their input.  You may be wondering what objects are actually being propagated through the algorithm pipeline. There are two objects that handle data in OpenBR:   File s are typically used to store the path to a file on disk with associated metadata (in the form of key-value pairs). In the example above, we store the rectangles detected by  Cascade  as metadata which are then used by  Draw  for visualization.  Template s are containers for images and  File s. Images in OpenBR are OpenCV Mats and are member variables of Templates. Templates can contain one or more images.   If you want to learn more about the  command line  or  all of the plugins and the key data structures , please refer to the linked documentation.  The next few tutorials will explore algorithms and their use in more depth.", 
            "title": "Quick Start"
        }, 
        {
            "location": "/tutorials/#algorithms-in-openbr", 
            "text": "One advantage of OpenBR is the ease with which one can express biometrics algorithms in a consistent and simple way. In OpenBR, an algorithm string defines a technique for enrolling images and (optionally) a method for comparing them.  Instead of storing the entire raw image for comparison, it is common practice to store an optimized representation, or  template , of the image for the task at hand. We note for the sake of clarity that while the OpenBR object  Template  gets it name from this concept,  template  is a more general biometrics concept. The process of generating this optimized representation is called  template enrollment  or  template generation . Given two templates,  template comparison  computes the similarity between them, where the higher values indicate more probable matches. Operationally, one seeks to generate templates that are small, accurate, and fast to compare.  As previously noted, an algorithm is defined in OpenBR through an algorithm string. There are several advantages in mandating that algorithms are defined from strings, the most important of which are the following:   It ensures good software development practices by forcibly decoupling the development of each step in an algorithm, facilitating the modification of algorithms and the re-use of individual steps.  It spares the creation and maintenance of a lot of very similar header files that would otherwise be needed for each step in an algorithm (observe the absence of headers in  openbr/plugins  files).  It allows for algorithm parameter tuning without recompiling.  It is completely unambiguous, both the OpenBR interpreter and anyone familiar with the project can understand exactly what your algorithm does just from this description.   OpenBR provides a syntax for setting plugin property values and creating concise algorithm strings. The relevant symbols are:     Symbol  Meaning      PluginName(property1=value1,...propertyN=valueN)  A plugin is described by its name (without the abstraction) and a list of properties and values. Properties of a plugin that are not specified are set to their default values.    :  Seperates  template enrollment  from  template comparison . Enrollment is on the left of the colon in the algorithm string, while comparison is on the right. Defining an algorithm with a template comparison step is optional.    +  Abbreviation for a  Pipe . Joins  Transform s together and projects input through them in series. The output of a  Transform  to the left of + become the input of the Transform to the right.    /  Abbreviation for a  Fork . Joins  Transform s together and projects input through them in parallel. All  Transform s receive the same input, the output of which is concatenated together.    {}  Abbreviation for  Cache . Cache the output of a plugin in memory for quick lookups later on.    >  Abbreviation for  LoadStore . Parameters for  Transform s inside the brackets are stored on disk after training and loaded from disk before projection.    ()  Order of operations. Change the order of operations using parantheses.     Let's look at some of the important parts of the codebase that make this possible:  In  AlgorithmCore::init()  in  openbr/core/core.cpp  you can see the code for splitting the algorithm description at the colon.\nShortly thereafter in this function we  make  the template generation and comparison objects.\nThese  make  calls are defined in the public  C++ plugin API  and can also be called from end user code.  Below we discuss some of the source code for  Transform::make  in  openbr/openbr_plugin.cpp .\nNote, the  make  functions for other plugin types are similar in spirit and will not be covered.  One of the first steps when converting the template generation description into  Transform s is to replace the operators, like '+', with their full form:  { // Check for use of '+' as shorthand for Pipe(...)\n     QStringList words = parse(str, '+');\n     if (words.size()   1)\n         return make(\"Pipe([\" + words.join(\",\") + \"])\", parent);\n}  After operator expansion, the template enrollment description forms a tree, and the  Transform  is constructed from this description recursively, starting at the root of the tree:  Transform *transform = Factory Transform ::make(\".\" + str);  Let's use the algorithm in  scripts/helloWorld.sh  as an example. The algorithm is:  Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95):Dist(L2)  Let's expand this using our new knowledge of OpenBR's algorithm syntax. First, the algorithm will be split into enrollment and comparison portions at the  : . So enrollment becomes:  Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95)  and comparison is:  Dist(L2)  On the enrollment side,  Transform s joined by the  +  operators are converted into children of a  Pipe . Thus, the enrollment algorithm is constructed as:  Pipe(transforms=[Open,Cvt(Gray),Cascade(FrontalFace),ASEFEyes,Affine(128,128,0.33,0.45,CvtFloat,PCA(0.95)])  Low-level detail of the operations involved in this algorithm can be found in the  project  function implemented by each of these  Transform s.\nTo briefly summarize:  1. Reads the image from disk\n2. Converts the image to grayscale\n3. Detects faces\n4. Detects eyes in detected faces\n5. Normalize the face with respect to rotation and scale using the eye locations\n6. Converts the image to floating point format\n7. Embeds the image in a PCA subspace trained on face images  If you are familiar with face recognition, you will likely recognize this as the Eigenfaces 1  algorithm.  As a final note, the Eigenfaces algorithms uses the Euclidean distance (or L2-norm) to compare templates.\nSince OpenBR expects similarity values when comparing templates and not dissimilarity values, the  DistDistance  will return  -log(distance+1)  by default so that smaller distances (in the Euclidean sense) indicate higher similarity.\nNote that  NegativeLogPlusOne  distance also exists such that you can convert the output of any distance using the above function.", 
            "title": "Algorithms in OpenBR"
        }, 
        {
            "location": "/tutorials/#training-algorithms", 
            "text": "OpenBR makes it easy to create and train your own algorithms on custom datasets. Let's start with the algorithm string for the Eigenfaces 1  algorithm described in the  Algorithms  tutorial. Recall that the algorithm is:  $ Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95)  Suppose we want to train this algorithm on some data we gathered. First, let's examine some of the underlying principles of training in OpenBR. Recall that every algorithm is composed of  Transforms  but not all  Transforms  need to be trained. In our example,  Cvt(Gray) , which converts the image to grayscale, does not need to be trained at all, and neither does  Open ,  ASEFEyes ,  Affine(128,128,0.33,0.45)  or  CvtFloat . These are  UntrainableTransforms  (a subclass of  Transform ).  Cascade(FrontalFace)  is a special case; it is a  Transform  and therefore can be trained. However, we have passed it an argument indicating it should use pre-trained model ( FrontalFace ). Thus,  PCA(0.95)  is the only trainable  Transform  in our algorithm string.  For the sake of completeness, we note that this transform is performing principal component analysis and retaining dimensions that account for 95% of the variance.  Of course, we need to supply data to train our algorithm. Let's step back and consider the full training command. An example of this might be:  $ br -algorithm \"Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95)\" -train training_data.csv EigenFaces  Notice the  -train  flag used in the algorithm.  -train  requires at least one argument, a training  Gallery . Note that certain  Transform s expect  labelled  training data. While  -train  needs only a single gallery  Gallery , more than one can be provided:  $ br -algorithm \"Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+CvtFloat+PCA(0.95)\" -train training_data1.csv training_data2.csv EigenFaces  -train  has an optional second argument: the name for a trained model ( EigenFaces  in the example above). The optional model file is a serialized and compressed binary file that stores the parameters learned during algorithm training.  The model file should only be considered optional when your algorithm string uses a  LoadStoreTransform  (discussed in depth later in this tutorial).  Otherwise, none of the parameters learned during algorithm training will be stored!  As was briefly discussed above, each  Transform  in is either  trainable  or not (in our case only  PCA(0.95)  is trainable). At train time, the training data is projected through each  UntrainableTransform  in sequence, just as it would be at test time. When the data reaches a trainable transform, the  train  method is called with the data projected through the preceding  Transforms  as its input. After training, the project method is called on the newly trained transform and the data continues to propagate through the algorithm.  After training is complete the algorithm is serialized to a model file (if you have specified one). The algorithm string is serialized first such that the algorithm can be recreated, followed by the parameters for each transform using the  store  method. Note that only trainable  Transforms  need to implement  store  because  UntrainableTransforms  can be recreated solely from their algorithm string descriptions.  We can then  -enroll  images using the trained algorithm by replacing the algorithm string with the model file:  $ br -algorithm EigenFaces -enroll enroll_data.csv enroll_data.gal  In the case that we want our training and testing algorithms to be different, we can use  LoadStoreTransform  to serialize specific parts of the algorithm string. Reusing our EigenFaces example, we could specify that only  CvtFloat  and  PCA(0.95)  should be serialized to the model, allowing the other algorithmic steps to be specified at test time. The command to accomplish this is:  $ br -algorithm \"Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+ CvtFloat+PCA(0.95),EigenFaces \" -train training_data.csv  Recall from the  Algorithms  tutorial that   is shorthand for a  LoadStoreTransform . Also note that the  LoadStoreTransform  takes two arguments: the algorithm string and an optional model name. If a name is not provided, a random name is created. Using this model would like this:  $ br -algorithm \"Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.2,0.55)+ EigenFaces \"  Since we haven't serialized that portion of the algorithm, the parameters of  Affine , for example, can now be changed at test time! Note that, in this contrived example, changing the  Affine  parameters will severely degrade performance. As a final note, when a  LoadStoreTransform  is present in the algorithm string used for training, OpenBR will not overwrite the specified model file if it already exists. Instead, it will load the old model file and treat the associated  Transforms  as untrainable (as they have already been trained!). This can helpful when you want to isolate a particular algorithmic step (e.g. to explore parameters) but don't want to retrain every part of the algorithm during each iteration.  Now that we've covered training a generic algorithm, the next tutorials will cover popular use cases supported by OpenBR including  FaceRecognition ,  Age Estimation , and  Gender Estimation .", 
            "title": "Training Algorithms"
        }, 
        {
            "location": "/tutorials/#face-recognition", 
            "text": "This tutorial gives an example on how to perform face recognition in OpenBR. OpenBR implements the 4SF 2  algorithm to perform face recognition. Please read the paper for more specific algorithm details.  To start, lets run face recognition from the command line. Open the terminal and enter  $ br -algorithm FaceRecognition \\\n    -compare ../data/MEDS/img/S354-01-t10_01.jpg ../data/MEDS/img/S354-02-t10_01.jpg \\\n     -compare ../data/MEDS/img/S354-01-t10_01.jpg ../data/MEDS/img/S386-04-t10_01.jpg  Easy enough? You should see results printed to terminal that look like  $ Set algorithm to FaceRecognition\n$ Loading /usr/local/share/openbr/models/algorithms/FaceRecognition\n$ Loading /usr/local/share/openbr/models/transforms//FaceRecognitionExtraction\n$ Loading /usr/local/share/openbr/models/transforms//FaceRecognitionEmbedding\n$ Loading /usr/local/share/openbr/models/transforms//FaceRecognitionQuantization\n$ Comparing ../data/MEDS/img/S354-01-t10_01.jpg and ../data/MEDS/img/S354-02-t10_01.jpg\n$ Enrolling ../data/MEDS/img/S354-01-t10_01.jpg to S354-01-t10_01r7Rv4W.mem\n$ 100.00%  ELAPSED=00:00:00  REMAINING=00:00:00  COUNT=1\n$ 100.00%  ELAPSED=00:00:00  REMAINING=00:00:00  COUNT=1\n$ 1.8812\n$ Comparing ../data/MEDS/img/S354-01-t10_01.jpg and ../data/MEDS/img/S386-04-t10_01.jpg\n$ Enrolling ../data/MEDS/img/S354-01-t10_01.jpg to S354-01-t10_01r7Rv4W.mem\n$ 100.00%  ELAPSED=00:00:00  REMAINING=00:00:00  COUNT=1\n$ 100.00%  ELAPSED=00:00:00  REMAINING=00:00:00  COUNT=1\n$ 0.571219  So, what is  FaceRecognition ? It's an abbrieviation to simplify execution of the algorithm. All of the algorithm abbreviations are located in  openbr/plugins/core/algorithms.cpp .  It is also possible to:    Evaluate face recognition performance (Note that this requires  R  to be installed):  $ br -algorithm FaceRecognition -path ../data/MEDS/img/ \\\n-enroll ../data/MEDS/sigset/MEDS_frontal_target.xml target.gal \\\n-enroll ../data/MEDS/sigset/MEDS_frontal_query.xml query.gal \\\n-compare target.gal query.gal scores.mtx \\\n-makeMask ../data/MEDS/sigset/MEDS_frontal_target.xml ../data/MEDS/sigset/MEDS_frontal_query.xml MEDS.mask \\\n-eval scores.mtx MEDS.mask Algorithm_Dataset/FaceRecognition_MEDS.csv \\\n-plot Algorithm_Dataset/FaceRecognition_MEDS.csv MEDS    Perform a 1:N face recognition search:  $ br -algorithm FaceRecognition -enrollAll -enroll ../data/MEDS/img 'meds.gal'\n$ br -algorithm FaceRecognition -compare meds.gal ../data/MEDS/img/S001-01-t10_01.jpg match_scores.csv    Train a new face recognition algorithm (on a different dataset):  $ br -algorithm 'Open+Cvt(Gray)+Cascade(FrontalFace)+ASEFEyes+Affine(128,128,0.33,0.45)+(Grid(10,10)+SIFTDescriptor(12)+ByRow)/(Blur(1.1)+Gamma(0.2)+DoG(1,2)+ContrastEq(0.1,10)+LBP(1,2)+RectRegions(8,8,6,6)+Hist(59))+PCA(0.95)+Normalize(L2)+Dup(12)+RndSubspace(0.05,1)+LDA(0.98)+Cat+PCA(0.95)+Normalize(L1)+Quantize:NegativeLogPlusOne(ByteL1)' -train ../data/ATT/img FaceRecognitionATT    The entire command line API is documented  here .", 
            "title": "Face Recognition"
        }, 
        {
            "location": "/tutorials/#age-estimation", 
            "text": "Age estimation is very similar in spirit to  Face Recognition  and will be covered in far less detail.  To perform age estimation from the command line you can run:  $ br -algorithm AgeEstimation \\\n    -enroll ../data/MEDS/img/S354-01-t10_01.jpg ../data/MEDS/img/S001-01-t10_01.jpg metadata.csv  The results will be stored in metadata.csv under the key 'Age'. Remember from the  Face Recognition  tutorial that  AgeEstimation  is just an abbreviation for the full algorithm description.  The source code to run age estimation as an application is in  app/examples/age_estimation.cpp", 
            "title": "Age Estimation"
        }, 
        {
            "location": "/tutorials/#gender-estimation", 
            "text": "As with age estimation, gender estimation is very similar in spirit to  Face Recognition  and will be covered in far less detail.  To perform gender estimation from the command line you can run:  $ br -algorithm GenderEstimation \\\n    -enroll ../data/MEDS/img/S354-01-t10_01.jpg ../data/MEDS/img/S001-01-t10_01.jpg metadata.csv  The results will be stored in metadata.csv under the key 'Gender'. Remember from the  Face Recognition  tutorial that  GenderEstimation  is just an abbreviation for the full algorithm description.  The source code to run gender estimation as an application is in  app/examples/gender_estimation.cpp", 
            "title": "Gender Estimation"
        }, 
        {
            "location": "/tutorials/#openbr-as-a-library", 
            "text": "OpenBR exposes a  C++ API  that can be embedded into your own applications. Let's step through the example code at  app/example/face_recognition.cpp  and learn about using OpenBR as a library.  Our main function starts with:  br::Context::initialize(argc, argv)  This is the first step in any OpenBR-based application, it initializes the global context.  QSharedPointer br::Transform  transform = br::Transform::fromAlgorithm(\"FaceRecognition\");\nQSharedPointer br::Distance  distance = br::Distance::fromAlgorithm(\"FaceRecognition\");  Here, we split our algorithm into  enrollment  ( Transform :: fromAlgorithm ) and  comparison  ( Distance :: fromAlgorithm )  br::Template queryA(\"../data/MEDS/img/S354-01-t10_01.jpg\");\nbr::Template queryB(\"../data/MEDS/img/S382-08-t10_01.jpg\");\nbr::Template target(\"../data/MEDS/img/S354-02-t10_01.jpg\");  These lines create our  Template s for enrollment. At this point, the Templates simply store the file path to the specified image on disk. In this example,  queryA  depicts the same person as  target  (often referred to as a  genuine match ) and  queryB  depicts a different person from  target  (often referred to as an  impostor match ).  queryA   *transform;\nqueryB   *transform;\ntarget   *transform;   is a convienience operator for enrolling  Template s in  Transform s. Thus, at this stage, our  Template s now store the images enrolled via the  FaceRecognition  algorithm.  float comparisonA = distance- compare(target, queryA);\nfloat comparisonB = distance- compare(target, queryB);  We then compare our query  Template s against the target  Template . The result is a floating point value indicating similarity.  printf(\"Genuine match score: %.3f\\n\", comparisonA);\nprintf(\"Impostor match score: %.3f\\n\", comparisonB);  After printing the results, you can see that  comparisonA  (between  queryA  and  target ) has a higher similarity score then  comparisonB , which is exactly what we expect!  br::Context::finalize();  The last line in any OpenBR application has to be call to  finalize . This functions performs the clean up of OpenBR.  That's it! You can now embed face recognition into all of your applications.", 
            "title": "OpenBR as a Library"
        }, 
        {
            "location": "/tutorials/#the-evaluation-harness", 
            "text": "OpenBR implements a complete,  NIST  compliant, evaluation harness for evaluating face recognition, face detection, and facial landmarking. The goal is to provide a consistent environment for the repeatable evaluation of algorithms to the academic and open source communities. To accompish this OpenBR defines the following portions of the biometrics evaluation environment (BEE) standard-    Signature set - A signature set (or  sigset ) is an XML file-list specified on page 9 of the  MBGC File Overview  and is implemented in  xmlGallery . Sigsets are identified with an  .xml  extension.    Similarity matrix - A similarity matrix (or  simmat ) is a binary score matrix specified on page 12 of the  MBGC File Overview  and is implemented in  mtxOutput . Simmats are identified with a  .mtx  extension. See  br_eval  for more information.    Mask matrix - A mask matrix (or  mask ) is a binary matrix specified on page 14 of the  MBGC File Overview  identifying the genuine and impostor matches within a corresponding  simmat . Masks are identified with a  .mask  extension. See  br_make_mask  and  br_combine_masks  for more information.    The evaluation harness is also accessible from the command line. See  -eval ,  -evalDetection ,  -evalLandmarking ,  -evalClassification ,  -evalClustering , or  -evalRegression  for relevant information.      Matthew Turk and Alex Pentland.  Eigenfaces for recognition. \nJournal of Cognitive Neuroscience, 71 86, 1991     B. Klare.  Spectrally sampled structural subspace features (4SF). \nIn Michigan State University Technical Report, MSUCSE-11-16, 2011", 
            "title": "The Evaluation Harness"
        }, 
        {
            "location": "/contribute/", 
            "text": "Contributing to OpenBR should be straightforward and enjoyable. This guide elucidates some guidelines such that your contribution fits nicely into our framework.\n\n\nContributing a Plugin\n\n\nYou should consider contributing a plugin (or plugins!) if you have an algorithm that you would like to express via OpenBR's algorithm grammar or you have an extension to an existing algorithm. Below are the steps for creating and contributing a plugin:\n\n\n\n\nCheck out the \nC++ Plugin API\n and decide which abstraction best suits the needs of your contribution.\n\n\nSelect a module in the \nopenbr/plugins/\n directory that describes your plugin, then create a new source (\n.cpp\n) file in that directory. Your file should have the same name as your plugin.\n\n\nImplement your plugin! Make sure to adhere to the \nStyle Guide\n to keep the code consistent within OpenBR. This increases overall readability and makes it easier for newcomers to learn!\n\n\n\n\nCommon Mistakes\n\n\nSome common mistakes that will stop your plugin from working:\n\n\n\n\n#include\n the  \nopenbr/plugins/openbr_internal.h\n header.\n\n\nThe entire plugin should be inside \nnamespace br\n.\n\n\nMake sure your plugin declares \nQ_OBJECT\n right after it's definition.\n\n\nRemember to call \nBR_REGISTER\n at the end of your plugin.\n\n\nRemeber to add \n#include \"module/filename.moc\"\n at the very bottom of your file.\n\n\n\n\nWhen in doubt, check out existing \nTransforms\n. \nMAddTransform\n is a simple and clear example of how a \nTransform\n should look.\n\n\nDocumenting\n\n\nDocumenting your plugin is very important. OpenBR supports custom, doxygen-style, in-code comments to make documentation simple, clear, and easy. Comments should be written as:\n\n\n    /*!\n     * ...\n     */\n\n\n\nComments are organized using tags, which are of the form \n\\tag\n. There are a few \nrequired\n tags that all OpenBR transforms must have:\n\n\n\n\n\n\n\n\nTag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\\ingroup\n\n\nThe abstraction to which your plugin belongs\n\n\n\n\n\n\n\\brief\n\n\nA description of your plugin\n\n\n\n\n\n\n\\author\n\n\nYour name\n\n\n\n\n\n\n\\cite\n\n\nThe citation link for the author. There must be citation tag for every author who appears. If you haven't already please add your information to \nopenbr/docs/docs/contributors.md\n\n\n\n\n\n\n\\br_property\n\n\nDescribes a \nBR_PROPERTY\n of your plugin. This should take the format \n\\br_property type name description\n. In certain cases, for enumerations for example, it is beneficial to add a bulleted list to the description. This is done using a comma seperated \n[]\n list. \n[item1,item2,item3]\n will appear like \nitem1\nitem2\nitem3\n Each property of the plugin must have a corresponding \\br_property tag.\n\n\n\n\n\n\n\n\nAt a minimum, a comment should look like this:\n\n\n    /*!\n     * \\ingroup abstraction group\n     * \\brief A description of the plugin\n     * \\author Your Name \\cite Your Citation\n     * \\br_property percentage float The percentage of something\n     * \\br_property enum choice A choice with possible values: [choice1, choice2, choice3]\n     */\n\n\n\nThere are also a few \noptional\n tags to provide more information:\n\n\n\n\n\n\n\n\nTag\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\\br_link\n\n\nA link to a webpage. It can take an optional preceding argument of a title for the link.\n\n\n\n\n\n\n\\br_paper\n\n\nAn academic paper your plugin needs to cite. This is a multi-line tag- The first line should contain the paper authors, the second line should contain the paper title, and the third should contain other information about the paper (for example conference and year). See below for an example.\n\n\n\n\n\n\n\\br_related_plugin\n\n\nLink to a related plugin within OpenBR. The full name of the plugin should be provided. Multiple plugins can be given and they should be seperated by a space.\n\n\n\n\n\n\n\\br_format\n\n\nA specifically formatted section that should be rendered as is. Everything following this tag (up to the next tag) is wrapped in an html \n block and is displayed exactly as it appears.\n\n\n\n\n\n\n\n\nOptional tags could look like this\n\n\n    /*!\n     * \\br_link http://www.openbiometrics.org\n     * \\br_link OpenBR http://www.openbiometrics.org\n     * \\br_paper Author1, Author2, Author3\n     *           Paper Title\n     *           Conference. Year\n     * \\br_related_plugin ExampleTransform ExampleDistance ExampleGallery\n     * \\br_format\n     * I will          show        up exactly\n     * like\n     * this\n     */\n\n\n\nTables are also supported within any of the tags defined above. Tables are created using the standard markdown syntax. For example, to add a table to a \\brief use code like the following-\n\n\n    /*!\n     * \\brief A short brief describing the plugin.\n     *\n     *     Table Header | Table Header\n     *     --- | ---\n     *     table content | table content\n     *     table content | table content\n     */\n\n\n\nFinally, OpenBR supports automatic linking for abstractions found in comments. For example, Transform will automatically become \nTransform\n.\n\n\n\n\nContributing to the API\n\n\nYou should contribute to the API if you want to add a new abstraction or extend an existing abstraction with new functionality. Please note, this occurs \nvery\n rarely. Our goal is to leave the core API as stable and consistent as possible and change only the surrounding plugins. If you believe your idea offers exciting new functionality or greatly increases efficiency please \nopen an issue\n so that it can be discussed as a community.\n\n\n\n\nStyle Guide\n\n\nThe most important rule is that \nnew code should be consistent with the existing code around it\n. The rules below illustrate the preferred style when cleaning up existing inconsistently-styled code.\n\n\nThese rules are a work in progress and are subject to additions. Changes to the style can be made with a pull request implementing the change across the entire repository.\n\n\nStructs \n Classes\n\n\nstruct FooBar\n{\n\n};\n\n\n\nFunctions\n\n\nint *fooBar(const int \nx, int *y, int z)\n{\n    *y = x + z;\n    return y;\n}\n\n\n\nVariables\n\n\nint x = 2;\nint *y = \nx;\nint \nz = x;\n\n\n\nLoops and Conditionals\n\n\nSingle-statement\n\n\nfor (int i=start; i\nend; i++)\n    foo();\n\n\n\nMultiple-statement\n\n\nfor (int i=start; i\nend; i++) {\n    foo();\n    bar();\n}\n\n\n\nConst\n\n\nUse \nconst\n whenever possible.\n\n\nStatic\n\n\nUse \nstatic\n function declarations whenever possible but \nstatic\n variables sparingly.\n\n\nUnused variables\n\n\nint foo(int used, int)\n{\n    // Unused variables are nameless in the function definition\n    return used;\n}\n\n\n\nIndentation\n\n\n4 spaces, no tabs.", 
            "title": "Contribute"
        }, 
        {
            "location": "/contribute/#contributing-a-plugin", 
            "text": "You should consider contributing a plugin (or plugins!) if you have an algorithm that you would like to express via OpenBR's algorithm grammar or you have an extension to an existing algorithm. Below are the steps for creating and contributing a plugin:   Check out the  C++ Plugin API  and decide which abstraction best suits the needs of your contribution.  Select a module in the  openbr/plugins/  directory that describes your plugin, then create a new source ( .cpp ) file in that directory. Your file should have the same name as your plugin.  Implement your plugin! Make sure to adhere to the  Style Guide  to keep the code consistent within OpenBR. This increases overall readability and makes it easier for newcomers to learn!   Common Mistakes  Some common mistakes that will stop your plugin from working:   #include  the   openbr/plugins/openbr_internal.h  header.  The entire plugin should be inside  namespace br .  Make sure your plugin declares  Q_OBJECT  right after it's definition.  Remember to call  BR_REGISTER  at the end of your plugin.  Remeber to add  #include \"module/filename.moc\"  at the very bottom of your file.   When in doubt, check out existing  Transforms .  MAddTransform  is a simple and clear example of how a  Transform  should look.  Documenting  Documenting your plugin is very important. OpenBR supports custom, doxygen-style, in-code comments to make documentation simple, clear, and easy. Comments should be written as:      /*!\n     * ...\n     */  Comments are organized using tags, which are of the form  \\tag . There are a few  required  tags that all OpenBR transforms must have:     Tag  Description      \\ingroup  The abstraction to which your plugin belongs    \\brief  A description of your plugin    \\author  Your name    \\cite  The citation link for the author. There must be citation tag for every author who appears. If you haven't already please add your information to  openbr/docs/docs/contributors.md    \\br_property  Describes a  BR_PROPERTY  of your plugin. This should take the format  \\br_property type name description . In certain cases, for enumerations for example, it is beneficial to add a bulleted list to the description. This is done using a comma seperated  []  list.  [item1,item2,item3]  will appear like  item1 item2 item3  Each property of the plugin must have a corresponding \\br_property tag.     At a minimum, a comment should look like this:      /*!\n     * \\ingroup abstraction group\n     * \\brief A description of the plugin\n     * \\author Your Name \\cite Your Citation\n     * \\br_property percentage float The percentage of something\n     * \\br_property enum choice A choice with possible values: [choice1, choice2, choice3]\n     */  There are also a few  optional  tags to provide more information:     Tag  Description      \\br_link  A link to a webpage. It can take an optional preceding argument of a title for the link.    \\br_paper  An academic paper your plugin needs to cite. This is a multi-line tag- The first line should contain the paper authors, the second line should contain the paper title, and the third should contain other information about the paper (for example conference and year). See below for an example.    \\br_related_plugin  Link to a related plugin within OpenBR. The full name of the plugin should be provided. Multiple plugins can be given and they should be seperated by a space.    \\br_format  A specifically formatted section that should be rendered as is. Everything following this tag (up to the next tag) is wrapped in an html   block and is displayed exactly as it appears.     Optional tags could look like this      /*!\n     * \\br_link http://www.openbiometrics.org\n     * \\br_link OpenBR http://www.openbiometrics.org\n     * \\br_paper Author1, Author2, Author3\n     *           Paper Title\n     *           Conference. Year\n     * \\br_related_plugin ExampleTransform ExampleDistance ExampleGallery\n     * \\br_format\n     * I will          show        up exactly\n     * like\n     * this\n     */  Tables are also supported within any of the tags defined above. Tables are created using the standard markdown syntax. For example, to add a table to a \\brief use code like the following-      /*!\n     * \\brief A short brief describing the plugin.\n     *\n     *     Table Header | Table Header\n     *     --- | ---\n     *     table content | table content\n     *     table content | table content\n     */  Finally, OpenBR supports automatic linking for abstractions found in comments. For example, Transform will automatically become  Transform .", 
            "title": "Contributing a Plugin"
        }, 
        {
            "location": "/contribute/#contributing-to-the-api", 
            "text": "You should contribute to the API if you want to add a new abstraction or extend an existing abstraction with new functionality. Please note, this occurs  very  rarely. Our goal is to leave the core API as stable and consistent as possible and change only the surrounding plugins. If you believe your idea offers exciting new functionality or greatly increases efficiency please  open an issue  so that it can be discussed as a community.", 
            "title": "Contributing to the API"
        }, 
        {
            "location": "/contribute/#style-guide", 
            "text": "The most important rule is that  new code should be consistent with the existing code around it . The rules below illustrate the preferred style when cleaning up existing inconsistently-styled code.  These rules are a work in progress and are subject to additions. Changes to the style can be made with a pull request implementing the change across the entire repository.  Structs   Classes  struct FooBar\n{\n\n};  Functions  int *fooBar(const int  x, int *y, int z)\n{\n    *y = x + z;\n    return y;\n}  Variables  int x = 2;\nint *y =  x;\nint  z = x;  Loops and Conditionals  Single-statement  for (int i=start; i end; i++)\n    foo();  Multiple-statement  for (int i=start; i end; i++) {\n    foo();\n    bar();\n}  Const  Use  const  whenever possible.  Static  Use  static  function declarations whenever possible but  static  variables sparingly.  Unused variables  int foo(int used, int)\n{\n    // Unused variables are nameless in the function definition\n    return used;\n}  Indentation  4 spaces, no tabs.", 
            "title": "Style Guide"
        }, 
        {
            "location": "/api_docs/c_api/", 
            "text": "C API\n\n\nThe C API is a high-level API for running algorithms and evaluating results.\n\n\nIn order to provide a high-level interface that is usable from the command line and callable from other programming languages, the API is designed to operate at the \"file system\" level.\nIn other words, arguments to many functions are file paths that specify either a source of input or a desired output.\nFile extensions are relied upon to determine \nhow\n files should be interpreted in the context of the function being called.\nThe \nC++ Plugin API\n should be used if more fine-grained control is required.\n\n\nImportant API Considerations\n\n\n\n\n\n\n\n\nName\n\n\nConsideration\n\n\n\n\n\n\n\n\n\n\nMemory\n\n\nMemory for \nconst char*\n return values is managed internally and guaranteed until the next call to the function\n\n\n\n\n\n\nInput String Buffers\n\n\nUsers should input a char * buffer and the size of that buffer. String data will be copied into the buffer, if the buffer is too small, only part of the string will be copied. Returns the buffer size required to contain the complete string.\n\n\n\n\n\n\n\n\nUsing the API\n\n\nTo use the API in your project include the following file:\n\n\n#include \nopenbr/openbr.h\n\n\n\n\nCMake\n developers may wish to the cmake configuration file found at:\n\n\nshare/openbr/cmake/OpenBRConfig.cmake\n\n\n\nPlease see the \ntutorials\n section for examples.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/c_api/#c-api", 
            "text": "The C API is a high-level API for running algorithms and evaluating results.  In order to provide a high-level interface that is usable from the command line and callable from other programming languages, the API is designed to operate at the \"file system\" level.\nIn other words, arguments to many functions are file paths that specify either a source of input or a desired output.\nFile extensions are relied upon to determine  how  files should be interpreted in the context of the function being called.\nThe  C++ Plugin API  should be used if more fine-grained control is required.", 
            "title": "C API"
        }, 
        {
            "location": "/api_docs/c_api/#important-api-considerations", 
            "text": "Name  Consideration      Memory  Memory for  const char*  return values is managed internally and guaranteed until the next call to the function    Input String Buffers  Users should input a char * buffer and the size of that buffer. String data will be copied into the buffer, if the buffer is too small, only part of the string will be copied. Returns the buffer size required to contain the complete string.", 
            "title": "Important API Considerations"
        }, 
        {
            "location": "/api_docs/c_api/#using-the-api", 
            "text": "To use the API in your project include the following file:  #include  openbr/openbr.h   CMake  developers may wish to the cmake configuration file found at:  share/openbr/cmake/OpenBRConfig.cmake  Please see the  tutorials  section for examples.", 
            "title": "Using the API"
        }, 
        {
            "location": "/api_docs/c_api/typedefs/", 
            "text": "void *br_template\n\n\nvoid *br_template_list\n\n\nvoid *br_gallery\n\n\nvoid *br_matrix_output", 
            "title": "Typedefs"
        }, 
        {
            "location": "/api_docs/c_api/typedefs/#br_template", 
            "text": "", 
            "title": "void *br_template"
        }, 
        {
            "location": "/api_docs/c_api/typedefs/#br_template_list", 
            "text": "", 
            "title": "void *br_template_list"
        }, 
        {
            "location": "/api_docs/c_api/typedefs/#br_gallery", 
            "text": "", 
            "title": "void *br_gallery"
        }, 
        {
            "location": "/api_docs/c_api/typedefs/#br_matrix_output", 
            "text": "", 
            "title": "void *br_matrix_output"
        }, 
        {
            "location": "/api_docs/c_api/functions/", 
            "text": "br_about\n\n\nCalls \nContext\n::\nabout\n.\n\n\n\n\n\n\nfunction definition:\n\n\nconst char *br_about()\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\noutput:\n (const char *) Returns a string describing OpenBR\n\n\nsee:\n \nbr_version\n\n\n\n\n\n\nbr_cat\n\n\nConcatenates a list of galleries into 1 gallery.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_cat(int num_input_galleries, const char *input_galleries[], const char *output_gallery)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_input_galleries\n\n\nint\n\n\nSize of input_galleries\n\n\n\n\n\n\ninput_galleries[]\n\n\nconst char *\n\n\nList of galleries\n\n\n\n\n\n\noutput_gallery\n\n\nconst char *\n\n\nPointer to store concatenated gallery\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n void\n\n\n\n\nsee:\n \nCat\n\n\n\n\n\n\nbr_deduplicate\n\n\nRemoves duplicate \ntemplates\n in a \ngallery\n. If a galley contains n duplicates, the first n-1 duplicates in the gallery will be removed and the nth will be kept. Users are encouraged to use binary gallery formats as the entire gallery is read into memory in one call to \nGallery\n::\nread\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_deduplicate(const char *input_gallery, const char *output_gallery, const char *threshold)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput_gallery\n\n\nconst char *\n\n\nGallery to be deduplicated\n\n\n\n\n\n\noutput_gallery\n\n\nconst char *\n\n\nDeduplicated gallery\n\n\n\n\n\n\nthreshold\n\n\nconst char *\n\n\nComparisons with a match score \n= this value are designated to be duplicates.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_cluster\n\n\nClusters one or more similarity matrices into a list of subjects. A \nsimilarity matrix\n is a type of \nOutput\n. The current clustering algorithm is a simplified implementation of the algorithm proposed by Zhu et al\n1\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_cluster(int num_simmats, const char *simmats[], float aggressiveness, const char *csv)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_simmats\n\n\nint\n\n\nSize of \nsimmats\n\n\n\n\n\n\nsimmats[]\n\n\nconst char *\n\n\nArray of \nsimmat\n composing one large self-similarity matrix arranged in row major order.\n\n\n\n\n\n\naggressiveness\n\n\nfloat\n\n\nThe higher the aggressiveness the larger the clusters. Suggested range is [0,10]\n\n\n\n\n\n\ncsv\n\n\nconst char *\n\n\nThe cluster results file to generate. Results are stored one row per cluster and use gallery indices.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_combine_masks\n\n\nCombines several equal-sized mask matrices. A comparison may not be simultaneously indentified as both a genuine and an imposter by different input masks.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_combine_masks(int num_input_masks, const char \ninput_masks[], const char \noutput_mask, const char *method)\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_input_masks\n\n\nint\n\n\nSize of \ninput_masks\n\n\n\n\n\n\ninput_masks[]\n\n\nconst char *\n\n\nArray of \nmask matrices\n to combine. All matrices must have the same dimensions.\n\n\n\n\n\n\noutput_mask\n\n\nconst char *\n\n\nThe file to contain the resulting \nmask matrix\n\n\n\n\n\n\nmethod\n\n\nconst char *\n\n\nPossible values are: \nAnd - Ignore comparison if \nany\n input masks ignore.\n \nOr - Ignore comparison if \nall\n input masks ignore.\n\n\n\n\n\n\n\n\n\n\n\n\nsee:\n \nbr_make_mask\n\n\n\n\n\n\n\n\nbr_compare\n\n\nCompares each \nTemplate\n in the query \nGallery\n to each \nTemplate\n  in the target \nGallery\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_compare(const char *target_gallery, const char *query_gallery, const char *output = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntarget_gallery\n\n\nconst char *\n\n\ntarget_gallery The \nGallery\n file whose templates make up the columns of the output.\n\n\n\n\n\n\nquery_gallery\n\n\nconst char *\n\n\nThe \nGallery\n file whose templates make up the rows of the output. A value of '.' reuses the target gallery as the query gallery.\n\n\n\n\n\n\noutput\n\n\nconst char *\n\n\n(Optional) The \nOutput\n file to contain the results of comparing the templates. The default behavior is to print scores to the terminal.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n br_enroll\n\n\n\n\n\n\nbr_compare_n\n\n\nConvenience function for comparing to multiple targets.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_compare_n(int num_targets, const char *target_galleries[], const char *query_gallery, const char *output)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_targets\n\n\nint\n\n\nSize of \ntarget_galleries\n\n\n\n\n\n\ntarget_galleries[]\n\n\nconst char *\n\n\nTarget galleries to compare against\n\n\n\n\n\n\nquery_gallery\n\n\nconst char *\n\n\nquery gallery for comparison.\n\n\n\n\n\n\noutput\n\n\nconst char *\n\n\n(Optional) \nOutput\n file to contain the results of comparing the templates. The default behavior is to print scores to the terminal.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n br_compare\n\n\n\n\n\n\nbr_pairwise_compare\n\n\nDOCUMENT ME!\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_pairwise_compare(const char *target_gallery, const char *query_gallery, const char *output = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntarget_gallery\n\n\nconst char *\n\n\nDOCUMENT ME\n\n\n\n\n\n\nquery_gallery\n\n\nconst char *\n\n\nDOCUMENT ME\n\n\n\n\n\n\noutput\n\n\nconst char *\n\n\nDOCUMENT ME\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_convert\n\n\nConvert a file to a different type. Files can only be converted to types within the same group. For example \nformats\n can only be converted to other \nformats\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_convert(const char *file_type, const char *input_file, const char *output_file)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile_type\n\n\nconst char *\n\n\nType of file to convert. Options are \nFormat\n, \nGallery\n or \nOutput\n.\n\n\n\n\n\n\ninput_file\n\n\nconst char *\n\n\nFile to convert.\n\n\n\n\n\n\noutput_file\n\n\nconst char *\n\n\nOutput file. Type is determined by the file extension.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_enroll\n\n\nConstructs \nTemplate(s)\n from an input.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_enroll(const char *input, const char *gallery = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nconst char *\n\n\nThe \nformat\n or \ngallery\n to enroll.\n\n\n\n\n\n\ngallery\n\n\nconst char *\n\n\n(Optional) The \nGallery\n file to contain the enrolled templates. By default the gallery will be held in memory and \ninput\n can used as a gallery in \nbr_compare\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_enroll_n\n\n\n\n\n\n\nbr_enroll_n\n\n\nConvenience function for enrolling multiple inputs.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_enroll_n(int num_inputs, const char *inputs[], const char *gallery = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_inputs\n\n\nint\n\n\nSize of \ninputs\n.\n\n\n\n\n\n\ninputs[]\n\n\nconst char *\n\n\nArray of inputs to enroll.\n\n\n\n\n\n\ngallery\n\n\nconst char *\n\n\n(Optional) The \nGallery\n file to contain the enroll templates.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_enroll\n\n\n\n\n\n\nbr_project\n\n\nA naive alternative to \nbr_enroll\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_project(const char *input, const char *output)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nconst char *\n\n\nThe \nformat\n or \ngallery\n to enroll.\n\n\n\n\n\n\noutput\n\n\nconst char *\n\n\nThe \nGallery\n file to contain the enrolled templates. By default the gallery will be held in memory and \ninput\n can used as a gallery in \nbr_compare\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_enroll\n\n\n\n\n\n\nbr_eval\n\n\nCreates a \n.csv\n file containing performance metrics from evaluating the similarity matrix using the mask matrix.\n\n\n\n\n\n\nfunction defintion:\n\n\nfloat br_eval(const char *simmat, const char *mask, const char *csv = \"\", int matches = 0)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsimmat\n\n\nconst char *\n\n\nThe \nsimmat\n to use\n\n\n\n\n\n\nmask\n\n\nconst char *\n\n\nThe \nmask\n to use.\n\n\n\n\n\n\ncsv\n\n\nconst char *\n\n\n(Optional) The \n.csv\n file to contain performance metrics.\n\n\n\n\n\n\nmatches\n\n\nint\n\n\n(Optional) An integer number of matches to output around the EER. Default is 0.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the true accept rate (TAR) at a false accept rate (FAR) of one in one thousand\n\n\n\n\nsee:\n \nbr_plot\n\n\n\n\n\n\nbr_assert_eval\n\n\nEvaluates the similarity matrix using the mask matrix.  Function aborts if TAR @ FAR = 0.001 does not meet an expected performance value.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_assert_eval(const char *simmat, const char *mask, const float accuracy)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsimmat\n\n\nconst char *\n\n\nThe \nsimmat\n to use\n\n\n\n\n\n\nmask\n\n\nconst char *\n\n\nThe \nmask\n\n\n\n\n\n\naccuracy\n\n\nconst float\n\n\nDesired true accept rate at false accept rate of one in one thousand.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_inplace_eval\n\n\nCreates a \n.csv\n file containing performance metrics from evaluating the similarity matrix using galleries containing ground truth labels.\n\n\n\n\n\n\nfunction definition:\n\n\nfloat br_inplace_eval(const char * simmat, const char *target, const char *query, const char *csv = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsimmat\n\n\nconst char *\n\n\nThe \nsimmat\n\n\n\n\n\n\ntarget\n\n\nconst char *\n\n\nThe name of a gallery containing metadata for the target set.\n\n\n\n\n\n\nquery\n\n\nconst char *\n\n\nThe name of a gallery containing metadata for the query set.\n\n\n\n\n\n\ncsv\n\n\nconst char *\n\n\n(Optional) The \n.csv\n file to contain performance metrics.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the true accept rate (TAR) at a false accept rate (FAR) of one in one thousand\n\n\n\n\nsee:\n \nbr_plot\n\n\n\n\n\n\nbr_eval_classification\n\n\nEvaluates and prints classification accuracy to terminal.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_eval_classification(const char *predicted_gallery, const char *truth_gallery, const char *predicted_property = \"\", const char *truth_property = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npredicted_gallery\n\n\nconst char *\n\n\nThe predicted \nGallery\n.\n\n\n\n\n\n\ntruth_gallery\n\n\nconst char *\n\n\nThe ground truth \nGallery\n.\n\n\n\n\n\n\npredicted_property\n\n\nconst char *\n\n\n(Optional) Which metadata key to use from the \npredicted_gallery\n.\n\n\n\n\n\n\ntruth_property\n\n\nconst char *\n\n\n(Optional) Which metadata key to use from the \ntruth_gallery\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_eval_clustering\n\n\nEvaluates and prints clustering accuracy to the terminal.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_eval_clustering(const char *csv, const char *gallery, const char * truth_property)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncsv\n\n\nconst char *\n\n\nThe cluster results file.\n\n\n\n\n\n\ngallery\n\n\nconst char *\n\n\nThe \nGallery\n used to generate the \nsimmat\n that was clustered.\n\n\n\n\n\n\ntruth_property\n\n\nconst char *\n\n\n(Optional) which metadata key to use from \ngallery\n, defaults to Label\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nbr_eval_detection\n\n\nEvaluates and prints detection accuracy to terminal.\n\n\n\n\n\n\nfunction definition:\n\n\nfloat br_eval_detection(const char *predicted_gallery, const char *truth_gallery, const char *csv = \"\", bool normalize = false, int minSize = 0, int maxSize = 0)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npredicted_gallery\n\n\nconst char *\n\n\nThe predicted \nGallery\n.\n\n\n\n\n\n\ntruth_gallery\n\n\nconst char *\n\n\nThe ground truth \nGallery\n.\n\n\n\n\n\n\ncsv\n\n\nconst char *\n\n\n(Optional) The \n.csv\n file to contain performance metrics.\n\n\n\n\n\n\nnormalize\n\n\nbool\n\n\n(Optional) Flag to normalize predicted bounding boxes for improved detection. Defaults to false.\n\n\n\n\n\n\nminSize\n\n\nint\n\n\n(Optional) Minimum size of faces to be considered in the evaluation. Size is applied to predicted and ground truth galleries. Defaults to -1 (no minimum size).\n\n\n\n\n\n\nmaxSize\n\n\nint\n\n\n(Optional) Maximum size if faces to be considered in the evaluation. Size is applied to predicted and ground truth galleries. Defaults to -1 (no maximum size).\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the true accept rate (TAR) at a false accept rate (FAR) of one in one thousand\n\n\n\n\n\n\n\n\nbr_eval_landmarking\n\n\nEvaluates and prints landmarking accuracy to terminal.\n\n\n\n\n\n\nfunction definition:\n\n\nfloat br_eval_landmarking(const char *predicted_gallery, const char *truth_gallery, const char *csv = \"\", int normalization_index_a = 0, int normalization_index_b = 1, int sample_index = 0, int total_examples = 5)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npredicted_gallery\n\n\nconst char *\n\n\nThe predicted \nGallery\n.\n\n\n\n\n\n\ntruth_gallery\n\n\nconst char *\n\n\nThe ground truth \nGallery\n.\n\n\n\n\n\n\ncsv\n\n\nconst char *\n\n\n(Optional) The \n.csv\n file to contain performance metrics.\n\n\n\n\n\n\nnormalization_index_a\n\n\nint\n\n\n(Optional) The first index in the list of points to use for normalization. Default is 0.\n\n\n\n\n\n\nnormalization_index_b\n\n\nint\n\n\n(Optional) The second index in the list of points to use for normalization. Default is 1.\n\n\n\n\n\n\nsample_index\n\n\nint\n\n\n(Optional) The index for sample landmark image in ground truth gallery. Default = 0.\n\n\n\n\n\n\ntotal_examples\n\n\nint\n\n\n(Optional) The number of accurate and inaccurate examples to display. Default is 5.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the true accept rate (TAR) at a false accept rate (FAR) of one in one thousand\n\n\n\n\n\n\n\n\nbr_eval_regression\n\n\nEvaluates regression accuracy to disk.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_eval_regression(const char *predicted_gallery, const char *truth_gallery, const char *predicted_property = \"\", const char *truth_property = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npredicted_gallery\n\n\nconst char *\n\n\nThe predicted \nGallery\n\n\n\n\n\n\ntruth_gallery\n\n\nconst char *\n\n\nThe ground truth \nGallery\n\n\n\n\n\n\npredicted_property\n\n\nconst char *\n\n\n(Optional) Which metadata key to use from \npredicted_gallery\n.\n\n\n\n\n\n\ntruth_property\n\n\nconst char *\n\n\n(Optional) Which metadata key to use from \ntruth_gallery\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_fuse\n\n\nPerform score level fusion on similarity matrices.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_fuse(int num_input_simmats, const char *input_simmats[], const char *normalization, const char *fusion, const char *output_simmat)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_input_simmats\n\n\nint\n\n\nSize of \ninput_simmats\n.\n\n\n\n\n\n\ninput_simmats[]\n\n\nconst char *\n\n\nArray of \nsimmats\n. All simmats must have the same dimensions.\n\n\n\n\n\n\nnormalization\n\n\nconst char *\n\n\nValid options are: \n \nNone - No score normalization.\n \nMinMax - Scores normalized to [0,1].\n \nZScore - Scores normalized to a standard normal curve.\n \n\n\n\n\n\n\nfusion\n\n\nconst char *\n\n\nValid options are: \n \nMin - Uses the minimum score.\n \nMax - Uses the maximum score.\n \nSum - Sums the scores. Sums can also be weighted: \nSumW1:W2:...:Wn\n.\n \nReplace - Replaces scores in the first matrix with scores in the second matrix when the mask is set.\n \n\n\n\n\n\n\noutput_simmat\n\n\nconst char *\n\n\nSimmat\n to contain the fused scores.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_initialize\n\n\nInitializes the \nContext\n. Required at the beginning of any OpenBR program.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_initialize(int \nargc, char *argv[], const char *sdk_path = \"\", bool use_gui = false)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargc\n\n\nint\n\n\nNumber of command line arguments.\n\n\n\n\n\n\nargv[]\n\n\nchar *\n\n\nArray of command line arguments.\n\n\n\n\n\n\nsdk_path\n\n\nconst char *\n\n\n(Optional) Path to the OpenBR sdk. If no path is provided OpenBR will try and find the sdk automatically.\n\n\n\n\n\n\nuse_gui\n\n\nbool\n\n\n(Optional) Enable OpenBR to use make GUI windows. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_finalize\n\n\n\n\n\n\nbr_initialize_default\n\n\nInitializes the \nContext\n with default arguments.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_initialize_default()\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\noutput:\n (void)\n\n\nsee:\n \nbr_finalize\n\n\n\n\n\n\nbr_finalize\n\n\nFinalizes the context. Required at the end of any OpenBR program.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_finalize()\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\noutput:\n (void)\n\n\nsee:\n \nbr_initialize\n\n\n\n\n\n\nbr_is_classifier\n\n\nChecks if the provided algorithm is a classifier. Wrapper of \nIsClassifier\n.\n\n\n\n\n\n\nfunction definition:\n\n\nbool br_is_classifier(const char *algorithm)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalgorithm\n\n\nconst char *\n\n\nAlgorithm to check.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the algorithm is a classifier (does not have an associated distance)\n\n\n\n\nsee:\n \nIsClassifier\n\n\n\n\n\n\nbr_make_mask\n\n\nConstructs a \nmask\n from target and query inputs.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_make_mask(const char *target_input, const char *query_input, const char *mask)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntarget_input\n\n\nconst char *\n\n\nThe target \nGallery\n\n\n\n\n\n\nquery_input\n\n\nconst char *\n\n\nThe query \nGallery\n\n\n\n\n\n\nmask\n\n\nconst char *\n\n\nThe file to contain the resulting \nmask\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_combine_masks\n\n\n\n\n\n\nbr_make_pairwise_mask\n\n\nConstructs a \nmask\n from target and query inputs considering the target and input sets to be definite pairwise comparisons.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_make_pairwise_mask(const char *target_input, const char *query_input, const char *mask)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntarget_input\n\n\nconst char *\n\n\nThe target \nGallery\n\n\n\n\n\n\nquery_input\n\n\nconst char *\n\n\nThe query \nGallery\n\n\n\n\n\n\nmask\n\n\nconst char *\n\n\nThe file to contain the resulting \nmask\n.\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\nsee:\n \nbr_combine_masks\n\n\n\n\n\n\nbr_most_recent_message\n\n\nReturns the most recent line sent to stderr. For information on input string buffers please look \nhere\n\n\n\n\n\n\nfunction definition:\n\n\nint br_most_recent_message(char * buffer, int buffer_length)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuffer\n\n\nchar *\n\n\nBuffer to store the last line in.\n\n\n\n\n\n\nbuffer_length\n\n\nint\n\n\nLength of the buffer.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the required size of the input buffer for the most recent message to fit completely\n\n\n\n\nsee:\n \nbr_progress\n, \nbr_time_remaining\n\n\n\n\n\n\nbr_objects\n\n\nReturns names and parameters for the requested objects. Each object is newline seperated. Arguments are seperated from the object name with a tab. This function uses \nQRegExp\n syntax.\n\n\n\n\n\n\nfunction definition:\n\n\nint br_objects(char * buffer, int buffer_length, const char *abstractions = \".*\", const char *implementations = \".*\", bool parameters = true)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuffer\n\n\nchar *\n\n\nOutput buffer for results.\n\n\n\n\n\n\nbuffer_length\n\n\nint\n\n\nLength of output buffer.\n\n\n\n\n\n\nabstractions\n\n\nconst char *\n\n\n(Optional) Regular expression of the abstractions to search. Default is \".*\".\n\n\n\n\n\n\nimplementations\n\n\nconst char *\n\n\n(Optional) Regular expression of the implementations to search. Default is \".*\".\n\n\n\n\n\n\nparameters\n\n\nbool\n\n\n(Optional) Include parameters after object name. Default is true.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the required size of the input buffer for the returned objects to fit completely\n\n\n\n\n\n\n\n\nbr_plot\n\n\nRenders recognition performance figures for a set of \n.csv\n files created by \nbr_eval\n.\n\n\nIn order of their output, the figures are:\n1. Metadata table\n2. Receiver Operating Characteristic (ROC)\n3. Detection Error Tradeoff (DET)\n4. Score Distribution (SD) histogram\n5. True Accept Rate Bar Chart (BC)\n6. Cumulative Match Characteristic (CMC)\n7. Error Rate (ERR) curve\n\n\nTwo files will be created:\n * \ndestination.R\n which is the auto-generated R script used to render the figures.\n * \ndestination.pdf\n which has all of the figures in one file multi-page file.\n\n\nOpenBR uses file and folder names to automatically determine the plot legend.\nFor example, let's consider the case where three algorithms (\nA\n, \nB\n, \n \nC\n) were each evaluated on two datasets (\nY\n \n \nZ\n).\nThe suggested way to plot these experiments on the same graph is to create a folder named \nAlgorithm_Dataset\n that contains the six \n.csv\n files produced by br_eval \nA_Y.csv\n, \nA_Z.csv\n, \nB_Y.csv\n, \nB_Z.csv\n, \nC_Y.csv\n, \n \nC_Z.csv\n.\nThe '\n_\n' character plays a special role in determining the legend title(s) and value(s).\nIn this case, \nA\n, \nB\n, \n \nC\n will be identified as different values of type \nAlgorithm\n, and each will be assigned its own color; \nY\n \n \nZ\n will be identified as different values of type Dataset, and each will be assigned its own line style.\nMatches around the EER will be displayed if the matches parameter is set in \nbr_eval\n.\n\n\nThis function requires a current \nR\n installation with the following packages:\n\n\n    install.packages(c(\"ggplot2\", \"gplots\", \"reshape\", \"scales\", \"jpg\", \"png\"))\n\n\n\n\n\n\n\nfunction definiton:\n\n\nbool br_plot(int num_files, const char *files[], const char *destination, bool show = false)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_files\n\n\nint\n\n\nNumber of \n.csv\n files.\n\n\n\n\n\n\nfiles[]\n\n\nconst char *\n\n\n.csv\n files created using \nbr_eval\n.\n\n\n\n\n\n\ndestination\n\n\nconst char *\n\n\nBasename for the resulting figures.\n\n\n\n\n\n\nshow\n\n\nbool\n\n\nOpen \ndestination.pdf\n using the system's default PDF viewer. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true on success. Returns false on a failure to compile the figures due to a missing, out of date, or incomplete \nR\n installation.\n\n\n\n\nsee:\n \nbr_eval\n\n\n\n\n\n\nbr_plot_detection\n\n\nRenders detection performance figures for a set of \n.csv\n files created by \nbr_eval_detection\n.\n\n\nIn order of their output, the figures are:\n1. Discrete Receiver Operating Characteristic (DiscreteROC)\n2. Continuous Receiver Operating Characteristic (ContinuousROC)\n3. Discrete Precision Recall (DiscretePR)\n4. Continuous Precision Recall (ContinuousPR)\n5. Bounding Box Overlap Histogram (Overlap)\n6. Average Overlap Table (AverageOverlap)\n7. Average Overlap Heatmap (AverageOverlap)\n\n\nDetection accuracy is measured with \noverlap fraction = bounding box intersection / union\n.\nWhen computing \ndiscrete\n curves, an overlap \n= 0.5 is considered a true positive, otherwise it is considered a false negative.\nWhen computing \ncontinuous\n curves, true positives and false negatives are measured fractionally as \noverlap\n and \n1-overlap\n respectively.\n\n\nThis function requires a current \nR\n installation with the following packages:\n\n\ninstall.packages(c(\"ggplot2\", \"gplots\", \"reshape\", \"scales\", \"jpg\", \"png\"))\n\n\n\n\n\n\n\nfunction definition:\n\n\nbool br_plot_detection(int num_files, const char *files[], const char *destination, bool show = false)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_files\n\n\nint\n\n\nNumber of \n.csv\n files.\n\n\n\n\n\n\nfiles[]\n\n\nconst char *\n\n\n.csv\n files created using \nbr_eval_detection\n.\n\n\n\n\n\n\ndestination\n\n\nconst char *\n\n\nBasename for the resulting figures.\n\n\n\n\n\n\nshow\n\n\nbool\n\n\nOpen \ndestination.pdf\n using the system's default PDF viewer. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true on success. Returns false on a failure to compile the figures due to a missing, out of date, or incomplete \nR\n installation.\n\n\n\n\nsee:\n \nbr_eval_detection\n, \nbr_plot\n\n\n\n\n\n\nbr_plot_landmarking\n\n\nRenders landmarking performance figures for a set of \n.csv\n files created by \nbr_eval_landmarking\n.\n\n\nIn order of their output, the figures are:\n1. Cumulative landmarks less than normalized error (CD)\n2. Normalized error box and whisker plots (Box)\n3. Normalized error violin plots (Violin)\n\n\nLandmarking error is normalized against the distance between two predifined points, usually inter-ocular distance (IOD).\n\n\n\n\n\n\nfunction definition:\n\n\nbool br_plot_landmarking(int num_files, const char *files[], const char *destination, bool show = false)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_files\n\n\nint\n\n\nNumber of \n.csv\n files.\n\n\n\n\n\n\nfiles[]\n\n\nconst char *\n\n\n.csv\n files created using \nbr_eval_landmarking\n.\n\n\n\n\n\n\ndestination\n\n\nconst char *\n\n\nBasename for the resulting figures.\n\n\n\n\n\n\nshow\n\n\nbool\n\n\nOpen \ndestination.pdf\n using the system's default PDF viewer. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true on success. Returns false on a failure to compile the figures due to a missing, out of date, or incomplete \nR\n installation.\n\n\n\n\nsee:\n \nbr_eval_landmarking\n, \nbr_plot\n\n\n\n\n\n\nbr_plot_metadata\n\n\nRenders metadata figures for a set of \n.csv\n files with specified columns.\n\n\n\n\n\n\nfunction definition:\n\n\nbool br_plot_metadata(int num_files, const char *files[], const char *columns, bool show = false)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_files\n\n\nint\n\n\nNumber of \n.csv\n files.\n\n\n\n\n\n\nfiles[]\n\n\nconst char *\n\n\n.csv\n files created by enrolling templates to \n.csv\n metadata files.\n\n\n\n\n\n\ncolumns\n\n\nconst char *\n\n\n';' seperated list of columns to plot.\n\n\n\n\n\n\nshow\n\n\nbool\n\n\nOpen \nPlotMetadata.pdf\n using the system's default PDF viewer.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true on success. Returns false on a failure to compile the figures due to a missing, out of date, or incomplete \nR\n installation.\n\n\n\n\nsee:\n \nbr_plot\n\n\n\n\n\n\nbr_progress\n\n\nReturns current progress from \nContext\n::\nprogress\n.\n\n\n\n\n\n\nfunction definition:\n\n\nfloat br_progress()\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\n\n\noutput:\n (float) Returns the completion percentage of the running process\n\n\n\n\nsee:\n \nbr_most_recent_message\n, \nbr_time_remaining\n\n\n\n\n\n\nbr_read_pipe\n\n\nRead and parse arguments from a named pipe. Used by the \ncommand line api\n to implement \n-daemon\n, generally not useful otherwise. Guaranteed to return at least one argument. For information on managed returned values see \nhere\n\n\n\n\n\n\nfunction defintion:\n\n\nvoid br_read_pipe(const char *pipe, int *argc, char ***argv)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npipe\n\n\nconst char *\n\n\nPipe name\n\n\n\n\n\n\nargc\n\n\nint *\n\n\nArgument count\n\n\n\n\n\n\nargv\n\n\nchar ***\n\n\nArgument list\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_scratch_path\n\n\nFills the buffer with the value of \nContext\n::\nscratchPath\n. For information on input string buffers see \nhere\n.\n\n\n\n\n\n\nfunction defintion:\n\n\nint br_scratch_path(char * buffer, int buffer_length)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuffer\n\n\nchar *\n\n\nBuffer for scratch path\n\n\n\n\n\n\nbuffer_length\n\n\nint\n\n\nLength of buffer.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the required size of the input buffer for the most recent message to fit completely\n\n\n\n\nsee:\n \nbr_version\n\n\n\n\n\n\nbr_sdk_path\n\n\nReturns the full path to the root of the SDK.\n\n\n\n\n\n\nfunction definition:\n\n\nconst char *br_sdk_path()\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\noutput:\n (const char *) Returns the full path to the root of the SDK\n\n\nsee:\n \nbr_initialize\n\n\n\n\n\n\nbr_get_header\n\n\nRetrieve the target and query inputs in the \nBEE matrix\n header. For information on managed return values see \nhere\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_get_header(const char *matrix, const char **target_gallery, const char **query_gallery)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmatrix\n\n\nconst char *\n\n\nThe \nBEE matrix\n file to modify\n\n\n\n\n\n\ntarget_gallery\n\n\nconst char **\n\n\nThe matrix target\n\n\n\n\n\n\nquery_gallery\n\n\nconst char **\n\n\nThe matrix query\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nset:\n \nbr_set_header\n\n\n\n\n\n\nbr_set_header\n\n\nUpdate the target and query inputs in the \nBEE matrix\n header.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_set_header(const char *matrix, const char *target_gallery, const char *query_gallery)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmatrix\n\n\nconst char *\n\n\nThe \nBEE matrix\n file to modify\n\n\n\n\n\n\ntarget_gallery\n\n\nconst char **\n\n\nThe matrix target\n\n\n\n\n\n\nquery_gallery\n\n\nconst char **\n\n\nThe matrix query\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_get_header\n\n\n\n\n\n\nbr_set_property\n\n\nAppends a provided value to the \nglobal metadata\n using a provided key.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_set_property(const char *key, const char *value)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst char *\n\n\nKey to append\n\n\n\n\n\n\nvalue\n\n\nconst char *\n\n\nValue to append\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_time_remaining\n\n\nReturns estimate of time remaining in the current process.\n\n\n\n\n\n\nfunction definition:\n\n\nint br_time_remaining()\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\noutput:\n (int) Returns an estimate of the time remaining\n\n\nsee:\n \nbr_most_recent_message\n, \nbr_progress\n\n\n\n\n\n\nbr_train\n\n\nTrains a provided model's \nTransform\n and \nDistance\n on the provided input.\n\n\n\n\n\n\nfunction definiton:\n\n\nvoid br_train(const char *input, const char *model = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nconst char *\n\n\nThe \nGallery\n to train on.\n\n\n\n\n\n\nmodel\n\n\nconst char *\n\n\n(Optional) String specifying the binary file to serialize training results to. The trained algorithm can be recovered by using this file as the algorithm. By default the trained algorithm will not be serialized to disk.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_train_n\n\n\n\n\n\n\nbr_train_n\n\n\nConvenience function for training on multiple inputs\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_train_n(int num_inputs, const char *inputs[], const char *model = \"\")\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnum_inputs\n\n\nint\n\n\nSize of \ninputs\n\n\n\n\n\n\ninputs[]\n\n\nconst char *\n\n\nAn array of \ngalleries\n to train on.\n\n\n\n\n\n\nmodel\n\n\nconst char *\n\n\n(Optional) String specifying the binary file to serialize training results to. The trained algorithm can be recovered by using this file as the algorithm. By default the trained algorithm will not be serialized to disk.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_train\n\n\n\n\n\n\nbr_version\n\n\nGet the current OpenBR version.\n\n\n\n\n\n\nfunction definition:\n\n\nconst char *br_version()\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\noutput:\n (const char *) Returns the current OpenBR version\n\n\nsee:\n \nbr_about\n, \nbr_scratch_path\n\n\n\n\n\n\nbr_slave_process\n\n\nFor internal use via \nProcessWrapperTransform\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_slave_process(const char * baseKey)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbaseKey\n\n\nconst char *\n\n\nbase key for the slave process\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_load_img\n\n\nLoad an image from a string buffer. This is an easy way to pass an image in memory from another programming language to openbr.\n\n\n\n\n\n\nfunction definition:\n\n\nbr_template br_load_img(const char *data, int len)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst char *\n\n\nThe image buffer.\n\n\n\n\n\n\nlen\n\n\nint\n\n\nThe length of the buffer.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nbr_template\n Returns a \nbr_template\n loaded with the provided image\n\n\n\n\nsee:\n \nbr_unload_img\n\n\n\n\n\n\nbr_unload_img\n\n\nUnload an image to a string buffer. This is an easy way to pass an image from openbr to another programming language.\n\n\n\n\n\n\nfunction definition:\n\n\nunsigned char* br_unload_img(br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (unsigned char*)  Returns a buffer loaded with the image data from tmpl\n\n\n\n\nsee:\n \nbr_load_img\n\n\n\n\n\n\nbr_template_list_from_buffer\n\n\nDeserialize a \nTemplateList\n from a buffer. Can be the buffer for a .gal file, since they are just a \nTemplateList\n serialized to disk.\n\n\n\n\n\n\nfunction definition:\n\n\nbr_template_list br_template_list_from_buffer(const char *buf, int len)\n\n\n\n\n\n\n\nreturn type:\n br_template_list\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuf\n\n\nconst char *\n\n\nThe buffer.\n\n\n\n\n\n\nlen\n\n\nint\n\n\nThe length of the buffer.\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nbr_template_list\n) Returns a pointer to a \nTemplateList\n created from the buffer.\n\n\n\n\n\n\nbr_free_template\n\n\nFree a \nTemplate's\n memory.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_free_template(br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to the \nTemplate\n to free.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_free_template_list\n\n\nFree a \nTemplateList's\n memory.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_free_template_list(br_template_list tl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntl\n\n\nbr_template_list\n\n\nPointer to the \nTemplateList\n to free.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_free_output\n\n\nFree a \nOutput's\n memory.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_free_output(br_matrix_output output)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noutput\n\n\nbr_matrix_output\n\n\nPointer to the\nOutput\n to free.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_img_rows\n\n\nReturns the number of rows in an image.\n\n\n\n\n\n\nfunction definition:\n\n\nint br_img_rows(br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the number of rows in an image\n\n\n\n\n\n\n\n\nbr_img_cols\n\n\nReturns the number of cols in an image.\n\n\n\n\n\n\nfunction definition:\n\n\nint br_img_cols(br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the number of columns in an image\n\n\n\n\n\n\n\n\nbr_img_channels\n\n\nReturns the number of channels in an image.\n\n\n\n\n\n\nfunction definition:\n\n\nint br_img_channels(br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the number of channels in an image\n\n\n\n\n\n\n\n\nbr_img_is_empty\n\n\nChecks if the image is empty.\n\n\n\n\n\n\nfunction definition:\n\n\nbool br_img_is_empty(br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the image is empty, false otherwise.\n\n\n\n\n\n\n\n\nbr_get_filename\n\n\nGet the name of the \nfile\n of a provided \nTemplate\n. For information on input string buffers please see \nhere\n\n\n\n\n\n\nfunction definition:\n\n\nint br_get_filename(char * buffer, int buffer_length, br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuffer\n\n\nchar *\n\n\nBuffer to hold the filename\n\n\n\n\n\n\nbuffer_length\n\n\nint\n\n\nLength of the buffer\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the size of the buffer required to hold the entire file name.\n\n\n\n\n\n\n\n\nbr_set_filename\n\n\nSet the name of the \nfile\n for a provided \nTemplate\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_set_filename(br_template tmpl, const char *filename)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n.\n\n\n\n\n\n\nfilename\n\n\nconst char *\n\n\nNew filename for the template.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_get_metadata_string\n\n\nGet the \nmetadata\n value as a string for a provided key in a provided \nTemplate\n.\n\n\n\n\n\n\nfunction definition:\n\n\nint br_get_metadata_string(char * buffer, int buffer_length, br_template tmpl, const char *key)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuffer\n\n\nchar *\n\n\nBuffer to hold the metadata string.\n\n\n\n\n\n\nbuffer_length\n\n\nint\n\n\nlength of the buffer.\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n.\n\n\n\n\n\n\nkey\n\n\nconst char *\n\n\nKey for the metadata lookup\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the size of the buffer required to hold the entire metadata string\n\n\n\n\n\n\n\n\nbr_enroll_template\n\n\nEnroll a \nTemplate\n from the C API!\n\n\n\n\n\n\nfunction definition:\n\n\nbr_template_list br_enroll_template(br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nbr_template_list\n) Returns a pointer to a \nTemplateList\n\n\n\n\n\n\n\n\nbr_enroll_template_list\n\n\nEnroll a \nTemplateList\n from the C API!\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_enroll_template_list(br_template_list tl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntl\n\n\nbr_template_list\n\n\nPointer to a \nTemplateList\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_compare_template_lists\n\n\nCompare \nTemplateLists\n from the C API!\n\n\n\n\n\n\nfunction definition:\n\n\nbr_matrix_output br_compare_template_lists(br_template_list target, br_template_list query)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntarget\n\n\nbr_template_list\n\n\nPointer to a \nTemplateList\n\n\n\n\n\n\nquery\n\n\nbr_template_list\n\n\nPointer to a \nTemplateList\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nbr_matrix_output\n) Returns a pointer to a \nMatrixOutput\n\n\n\n\n\n\n\n\nbr_get_matrix_output_at\n\n\nGet a value in a provided \nMatrixOutput\n.\n\n\n\n\n\n\nfunction definition:\n\n\nfloat br_get_matrix_output_at(br_matrix_output output, int row, int col)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noutput\n\n\nbr_matrix_output\n\n\nPointer to \nMatrixOutput\n\n\n\n\n\n\nrow\n\n\nint\n\n\nRow index for lookup\n\n\n\n\n\n\ncol\n\n\nint\n\n\nColumn index for lookup\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the value of the \nMatrixOutput\n at the provided indexes.\n\n\n\n\n\n\n\n\nbr_get_template\n\n\nGet a \nTemplate\n from a \nTemplateList\n at a specified index.\n\n\n\n\n\n\nfunction definition:\n\n\nbr_template br_get_template(br_template_list tl, int index)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntl\n\n\nbr_template_list\n\n\nPointer to a \nTemplateList\n\n\n\n\n\n\nindex\n\n\nint\n\n\nIndex into the template list. Should be in the range [0,len(tl) - 1].\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nbr_template\n) Returns a pointer to a \nTemplate\n\n\n\n\n\n\n\n\nbr_num_templates\n\n\nGet the number of \nTemplates\n in a \nTemplateList\n.\n\n\n\n\n\n\nfunction definition:\n\n\nint br_num_templates(br_template_list tl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntl\n\n\nbr_template_list\n\n\nPointer to a \nTemplateList\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (int) Returns the size of the provided \nTemplateList\n\n\n\n\n\n\n\n\nbr_make_gallery\n\n\nInitialize a \nGallery\n from a file.\n\n\n\n\n\n\nfunction definition:\n\n\nbr_gallery br_make_gallery(const char *gallery)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nconst char *\n\n\nString location of gallery on disk.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nbr_gallery\n) Returns a pointer to a \nGallery\n that has been created from the provided file\n\n\n\n\n\n\n\n\nbr_load_from_gallery\n\n\nRead a \nTemplateList\n from a \nGallery\n.\n\n\n\n\n\n\nfunction definition:\n\n\nbr_template_list br_load_from_gallery(br_gallery gallery)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nbr_gallery\n\n\nPointer to a \nGallery\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nbr_template_list\n) Returns a pointer to a \nTemplateList\n containing the data from the provided \nGallery\n\n\n\n\n\n\n\n\nbr_add_template_to_gallery\n\n\nWrite a \nTemplate\n to a \nGallery\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_add_template_to_gallery(br_gallery gallery, br_template tmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nbr_gallery\n\n\nPointer to a \nGallery\n\n\n\n\n\n\ntmpl\n\n\nbr_template\n\n\nPointer to a \nTemplate\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_add_template_list_to_gallery\n\n\nWrite a \nTemplateList\n to the \nGallery\n on disk.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_add_template_list_to_gallery(br_gallery gallery, br_template_list tl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nbr_gallery\n\n\nPointer to a \nGallery\n\n\n\n\n\n\ntl\n\n\nbr_template_list\n\n\nPointer to a \nTemplateList\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nbr_close_gallery\n\n\nClose a provided \nGallery\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid br_close_gallery(br_gallery gallery)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nbr_gallery\n\n\nPointer to a \nGallery\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZhu et al.\n\n\nA Rank-Order Distance based Clustering Algorithm for Face Tagging\n,\nCVPR 2011", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_about", 
            "text": "Calls  Context :: about .    function definition:  const char *br_about()    parameters:  None   output:  (const char *) Returns a string describing OpenBR  see:   br_version", 
            "title": "br_about"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_cat", 
            "text": "Concatenates a list of galleries into 1 gallery.    function definition:  void br_cat(int num_input_galleries, const char *input_galleries[], const char *output_gallery)    parameters:     Parameter  Type  Description      num_input_galleries  int  Size of input_galleries    input_galleries[]  const char *  List of galleries    output_gallery  const char *  Pointer to store concatenated gallery       output:  void   see:   Cat", 
            "title": "br_cat"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_deduplicate", 
            "text": "Removes duplicate  templates  in a  gallery . If a galley contains n duplicates, the first n-1 duplicates in the gallery will be removed and the nth will be kept. Users are encouraged to use binary gallery formats as the entire gallery is read into memory in one call to  Gallery :: read .    function definition:  void br_deduplicate(const char *input_gallery, const char *output_gallery, const char *threshold)    parameters:     Parameter  Type  Description      input_gallery  const char *  Gallery to be deduplicated    output_gallery  const char *  Deduplicated gallery    threshold  const char *  Comparisons with a match score  = this value are designated to be duplicates.       output:  (void)", 
            "title": "br_deduplicate"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_cluster", 
            "text": "Clusters one or more similarity matrices into a list of subjects. A  similarity matrix  is a type of  Output . The current clustering algorithm is a simplified implementation of the algorithm proposed by Zhu et al 1 .    function definition:  void br_cluster(int num_simmats, const char *simmats[], float aggressiveness, const char *csv)    parameters:     Parameter  Type  Description      num_simmats  int  Size of  simmats    simmats[]  const char *  Array of  simmat  composing one large self-similarity matrix arranged in row major order.    aggressiveness  float  The higher the aggressiveness the larger the clusters. Suggested range is [0,10]    csv  const char *  The cluster results file to generate. Results are stored one row per cluster and use gallery indices.       output:  (void)", 
            "title": "br_cluster"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_combine_masks", 
            "text": "Combines several equal-sized mask matrices. A comparison may not be simultaneously indentified as both a genuine and an imposter by different input masks.    function definition:  void br_combine_masks(int num_input_masks, const char  input_masks[], const char  output_mask, const char *method)    parameters:     Parameter  Type  Description      num_input_masks  int  Size of  input_masks    input_masks[]  const char *  Array of  mask matrices  to combine. All matrices must have the same dimensions.    output_mask  const char *  The file to contain the resulting  mask matrix    method  const char *  Possible values are:  And - Ignore comparison if  any  input masks ignore.   Or - Ignore comparison if  all  input masks ignore.       see:   br_make_mask", 
            "title": "br_combine_masks"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_compare", 
            "text": "Compares each  Template  in the query  Gallery  to each  Template   in the target  Gallery .    function definition:  void br_compare(const char *target_gallery, const char *query_gallery, const char *output = \"\")    parameters:     Parameter  Type  Description      target_gallery  const char *  target_gallery The  Gallery  file whose templates make up the columns of the output.    query_gallery  const char *  The  Gallery  file whose templates make up the rows of the output. A value of '.' reuses the target gallery as the query gallery.    output  const char *  (Optional) The  Output  file to contain the results of comparing the templates. The default behavior is to print scores to the terminal.       output:  (void)   see:  br_enroll", 
            "title": "br_compare"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_compare_n", 
            "text": "Convenience function for comparing to multiple targets.    function definition:  void br_compare_n(int num_targets, const char *target_galleries[], const char *query_gallery, const char *output)    parameters:     Parameter  Type  Description      num_targets  int  Size of  target_galleries    target_galleries[]  const char *  Target galleries to compare against    query_gallery  const char *  query gallery for comparison.    output  const char *  (Optional)  Output  file to contain the results of comparing the templates. The default behavior is to print scores to the terminal.       output:  (void)   see:  br_compare", 
            "title": "br_compare_n"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_pairwise_compare", 
            "text": "DOCUMENT ME!    function definition:  void br_pairwise_compare(const char *target_gallery, const char *query_gallery, const char *output = \"\")    parameters:     Parameter  Type  Description      target_gallery  const char *  DOCUMENT ME    query_gallery  const char *  DOCUMENT ME    output  const char *  DOCUMENT ME       output:  (void)", 
            "title": "br_pairwise_compare"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_convert", 
            "text": "Convert a file to a different type. Files can only be converted to types within the same group. For example  formats  can only be converted to other  formats .    function definition:  void br_convert(const char *file_type, const char *input_file, const char *output_file)    parameters:     Parameter  Type  Description      file_type  const char *  Type of file to convert. Options are  Format ,  Gallery  or  Output .    input_file  const char *  File to convert.    output_file  const char *  Output file. Type is determined by the file extension.       output:  (void)", 
            "title": "br_convert"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_enroll", 
            "text": "Constructs  Template(s)  from an input.    function definition:  void br_enroll(const char *input, const char *gallery = \"\")    parameters:     Parameter  Type  Description      input  const char *  The  format  or  gallery  to enroll.    gallery  const char *  (Optional) The  Gallery  file to contain the enrolled templates. By default the gallery will be held in memory and  input  can used as a gallery in  br_compare       output:  (void)   see:   br_enroll_n", 
            "title": "br_enroll"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_enroll_n", 
            "text": "Convenience function for enrolling multiple inputs.    function definition:  void br_enroll_n(int num_inputs, const char *inputs[], const char *gallery = \"\")    parameters:     Parameter  Type  Description      num_inputs  int  Size of  inputs .    inputs[]  const char *  Array of inputs to enroll.    gallery  const char *  (Optional) The  Gallery  file to contain the enroll templates.       output:  (void)   see:   br_enroll", 
            "title": "br_enroll_n"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_project", 
            "text": "A naive alternative to  br_enroll .    function definition:  void br_project(const char *input, const char *output)    parameters:     Parameter  Type  Description      input  const char *  The  format  or  gallery  to enroll.    output  const char *  The  Gallery  file to contain the enrolled templates. By default the gallery will be held in memory and  input  can used as a gallery in  br_compare       output:  (void)   see:   br_enroll", 
            "title": "br_project"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_eval", 
            "text": "Creates a  .csv  file containing performance metrics from evaluating the similarity matrix using the mask matrix.    function defintion:  float br_eval(const char *simmat, const char *mask, const char *csv = \"\", int matches = 0)    parameters:     Parameter  Type  Description      simmat  const char *  The  simmat  to use    mask  const char *  The  mask  to use.    csv  const char *  (Optional) The  .csv  file to contain performance metrics.    matches  int  (Optional) An integer number of matches to output around the EER. Default is 0.       output:  (float) Returns the true accept rate (TAR) at a false accept rate (FAR) of one in one thousand   see:   br_plot", 
            "title": "br_eval"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_assert_eval", 
            "text": "Evaluates the similarity matrix using the mask matrix.  Function aborts if TAR @ FAR = 0.001 does not meet an expected performance value.    function definition:  void br_assert_eval(const char *simmat, const char *mask, const float accuracy)    parameters:     Parameter  Type  Description      simmat  const char *  The  simmat  to use    mask  const char *  The  mask    accuracy  const float  Desired true accept rate at false accept rate of one in one thousand.       output:  (void)", 
            "title": "br_assert_eval"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_inplace_eval", 
            "text": "Creates a  .csv  file containing performance metrics from evaluating the similarity matrix using galleries containing ground truth labels.    function definition:  float br_inplace_eval(const char * simmat, const char *target, const char *query, const char *csv = \"\")    parameters:     Parameter  Type  Description      simmat  const char *  The  simmat    target  const char *  The name of a gallery containing metadata for the target set.    query  const char *  The name of a gallery containing metadata for the query set.    csv  const char *  (Optional) The  .csv  file to contain performance metrics.       output:  (float) Returns the true accept rate (TAR) at a false accept rate (FAR) of one in one thousand   see:   br_plot", 
            "title": "br_inplace_eval"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_eval_classification", 
            "text": "Evaluates and prints classification accuracy to terminal.    function definition:  void br_eval_classification(const char *predicted_gallery, const char *truth_gallery, const char *predicted_property = \"\", const char *truth_property = \"\")    parameters:     Parameter  Type  Description      predicted_gallery  const char *  The predicted  Gallery .    truth_gallery  const char *  The ground truth  Gallery .    predicted_property  const char *  (Optional) Which metadata key to use from the  predicted_gallery .    truth_property  const char *  (Optional) Which metadata key to use from the  truth_gallery .       output:  (void)", 
            "title": "br_eval_classification"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_eval_clustering", 
            "text": "Evaluates and prints clustering accuracy to the terminal.    function definition:  void br_eval_clustering(const char *csv, const char *gallery, const char * truth_property)    parameters:       Parameter  Type  Description      csv  const char *  The cluster results file.    gallery  const char *  The  Gallery  used to generate the  simmat  that was clustered.    truth_property  const char *  (Optional) which metadata key to use from  gallery , defaults to Label      output:  (void)", 
            "title": "br_eval_clustering"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_eval_detection", 
            "text": "Evaluates and prints detection accuracy to terminal.    function definition:  float br_eval_detection(const char *predicted_gallery, const char *truth_gallery, const char *csv = \"\", bool normalize = false, int minSize = 0, int maxSize = 0)    parameters:     Parameter  Type  Description      predicted_gallery  const char *  The predicted  Gallery .    truth_gallery  const char *  The ground truth  Gallery .    csv  const char *  (Optional) The  .csv  file to contain performance metrics.    normalize  bool  (Optional) Flag to normalize predicted bounding boxes for improved detection. Defaults to false.    minSize  int  (Optional) Minimum size of faces to be considered in the evaluation. Size is applied to predicted and ground truth galleries. Defaults to -1 (no minimum size).    maxSize  int  (Optional) Maximum size if faces to be considered in the evaluation. Size is applied to predicted and ground truth galleries. Defaults to -1 (no maximum size).       output:  (float) Returns the true accept rate (TAR) at a false accept rate (FAR) of one in one thousand", 
            "title": "br_eval_detection"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_eval_landmarking", 
            "text": "Evaluates and prints landmarking accuracy to terminal.    function definition:  float br_eval_landmarking(const char *predicted_gallery, const char *truth_gallery, const char *csv = \"\", int normalization_index_a = 0, int normalization_index_b = 1, int sample_index = 0, int total_examples = 5)    parameters:     Parameter  Type  Description      predicted_gallery  const char *  The predicted  Gallery .    truth_gallery  const char *  The ground truth  Gallery .    csv  const char *  (Optional) The  .csv  file to contain performance metrics.    normalization_index_a  int  (Optional) The first index in the list of points to use for normalization. Default is 0.    normalization_index_b  int  (Optional) The second index in the list of points to use for normalization. Default is 1.    sample_index  int  (Optional) The index for sample landmark image in ground truth gallery. Default = 0.    total_examples  int  (Optional) The number of accurate and inaccurate examples to display. Default is 5.       output:  (float) Returns the true accept rate (TAR) at a false accept rate (FAR) of one in one thousand", 
            "title": "br_eval_landmarking"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_eval_regression", 
            "text": "Evaluates regression accuracy to disk.    function definition:  void br_eval_regression(const char *predicted_gallery, const char *truth_gallery, const char *predicted_property = \"\", const char *truth_property = \"\")    parameters:     Parameter  Type  Description      predicted_gallery  const char *  The predicted  Gallery    truth_gallery  const char *  The ground truth  Gallery    predicted_property  const char *  (Optional) Which metadata key to use from  predicted_gallery .    truth_property  const char *  (Optional) Which metadata key to use from  truth_gallery .       output:  (void)", 
            "title": "br_eval_regression"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_fuse", 
            "text": "Perform score level fusion on similarity matrices.    function definition:  void br_fuse(int num_input_simmats, const char *input_simmats[], const char *normalization, const char *fusion, const char *output_simmat)    parameters:     Parameter  Type  Description      num_input_simmats  int  Size of  input_simmats .    input_simmats[]  const char *  Array of  simmats . All simmats must have the same dimensions.    normalization  const char *  Valid options are:    None - No score normalization.   MinMax - Scores normalized to [0,1].   ZScore - Scores normalized to a standard normal curve.      fusion  const char *  Valid options are:    Min - Uses the minimum score.   Max - Uses the maximum score.   Sum - Sums the scores. Sums can also be weighted:  SumW1:W2:...:Wn .   Replace - Replaces scores in the first matrix with scores in the second matrix when the mask is set.      output_simmat  const char *  Simmat  to contain the fused scores.       output:  (void)", 
            "title": "br_fuse"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_initialize", 
            "text": "Initializes the  Context . Required at the beginning of any OpenBR program.    function definition:  void br_initialize(int  argc, char *argv[], const char *sdk_path = \"\", bool use_gui = false)    parameters:     Parameter  Type  Description      argc  int  Number of command line arguments.    argv[]  char *  Array of command line arguments.    sdk_path  const char *  (Optional) Path to the OpenBR sdk. If no path is provided OpenBR will try and find the sdk automatically.    use_gui  bool  (Optional) Enable OpenBR to use make GUI windows. Default is false.       output:  (void)   see:   br_finalize", 
            "title": "br_initialize"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_initialize_default", 
            "text": "Initializes the  Context  with default arguments.    function definition:  void br_initialize_default()    parameters:  None   output:  (void)  see:   br_finalize", 
            "title": "br_initialize_default"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_finalize", 
            "text": "Finalizes the context. Required at the end of any OpenBR program.    function definition:  void br_finalize()    parameters:  None   output:  (void)  see:   br_initialize", 
            "title": "br_finalize"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_is_classifier", 
            "text": "Checks if the provided algorithm is a classifier. Wrapper of  IsClassifier .    function definition:  bool br_is_classifier(const char *algorithm)    parameters:     Parameter  Type  Description      algorithm  const char *  Algorithm to check.       output:  (bool) Returns true if the algorithm is a classifier (does not have an associated distance)   see:   IsClassifier", 
            "title": "br_is_classifier"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_make_mask", 
            "text": "Constructs a  mask  from target and query inputs.    function definition:  void br_make_mask(const char *target_input, const char *query_input, const char *mask)    parameters:     Parameter  Type  Description      target_input  const char *  The target  Gallery    query_input  const char *  The query  Gallery    mask  const char *  The file to contain the resulting  mask .       output:  (void)   see:   br_combine_masks", 
            "title": "br_make_mask"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_make_pairwise_mask", 
            "text": "Constructs a  mask  from target and query inputs considering the target and input sets to be definite pairwise comparisons.    function definition:  void br_make_pairwise_mask(const char *target_input, const char *query_input, const char *mask)    parameters:       Parameter  Type  Description      target_input  const char *  The target  Gallery    query_input  const char *  The query  Gallery    mask  const char *  The file to contain the resulting  mask .      output:  (void)  see:   br_combine_masks", 
            "title": "br_make_pairwise_mask"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_most_recent_message", 
            "text": "Returns the most recent line sent to stderr. For information on input string buffers please look  here    function definition:  int br_most_recent_message(char * buffer, int buffer_length)    parameters:     Parameter  Type  Description      buffer  char *  Buffer to store the last line in.    buffer_length  int  Length of the buffer.       output:  (int) Returns the required size of the input buffer for the most recent message to fit completely   see:   br_progress ,  br_time_remaining", 
            "title": "br_most_recent_message"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_objects", 
            "text": "Returns names and parameters for the requested objects. Each object is newline seperated. Arguments are seperated from the object name with a tab. This function uses  QRegExp  syntax.    function definition:  int br_objects(char * buffer, int buffer_length, const char *abstractions = \".*\", const char *implementations = \".*\", bool parameters = true)    parameters:     Parameter  Type  Description      buffer  char *  Output buffer for results.    buffer_length  int  Length of output buffer.    abstractions  const char *  (Optional) Regular expression of the abstractions to search. Default is \".*\".    implementations  const char *  (Optional) Regular expression of the implementations to search. Default is \".*\".    parameters  bool  (Optional) Include parameters after object name. Default is true.       output:  (int) Returns the required size of the input buffer for the returned objects to fit completely", 
            "title": "br_objects"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_plot", 
            "text": "Renders recognition performance figures for a set of  .csv  files created by  br_eval .  In order of their output, the figures are:\n1. Metadata table\n2. Receiver Operating Characteristic (ROC)\n3. Detection Error Tradeoff (DET)\n4. Score Distribution (SD) histogram\n5. True Accept Rate Bar Chart (BC)\n6. Cumulative Match Characteristic (CMC)\n7. Error Rate (ERR) curve  Two files will be created:\n *  destination.R  which is the auto-generated R script used to render the figures.\n *  destination.pdf  which has all of the figures in one file multi-page file.  OpenBR uses file and folder names to automatically determine the plot legend.\nFor example, let's consider the case where three algorithms ( A ,  B ,    C ) were each evaluated on two datasets ( Y     Z ).\nThe suggested way to plot these experiments on the same graph is to create a folder named  Algorithm_Dataset  that contains the six  .csv  files produced by br_eval  A_Y.csv ,  A_Z.csv ,  B_Y.csv ,  B_Z.csv ,  C_Y.csv ,    C_Z.csv .\nThe ' _ ' character plays a special role in determining the legend title(s) and value(s).\nIn this case,  A ,  B ,    C  will be identified as different values of type  Algorithm , and each will be assigned its own color;  Y     Z  will be identified as different values of type Dataset, and each will be assigned its own line style.\nMatches around the EER will be displayed if the matches parameter is set in  br_eval .  This function requires a current  R  installation with the following packages:      install.packages(c(\"ggplot2\", \"gplots\", \"reshape\", \"scales\", \"jpg\", \"png\"))    function definiton:  bool br_plot(int num_files, const char *files[], const char *destination, bool show = false)    parameters:     Parameter  Type  Description      num_files  int  Number of  .csv  files.    files[]  const char *  .csv  files created using  br_eval .    destination  const char *  Basename for the resulting figures.    show  bool  Open  destination.pdf  using the system's default PDF viewer. Default is false.       output:  (bool) Returns true on success. Returns false on a failure to compile the figures due to a missing, out of date, or incomplete  R  installation.   see:   br_eval", 
            "title": "br_plot"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_plot_detection", 
            "text": "Renders detection performance figures for a set of  .csv  files created by  br_eval_detection .  In order of their output, the figures are:\n1. Discrete Receiver Operating Characteristic (DiscreteROC)\n2. Continuous Receiver Operating Characteristic (ContinuousROC)\n3. Discrete Precision Recall (DiscretePR)\n4. Continuous Precision Recall (ContinuousPR)\n5. Bounding Box Overlap Histogram (Overlap)\n6. Average Overlap Table (AverageOverlap)\n7. Average Overlap Heatmap (AverageOverlap)  Detection accuracy is measured with  overlap fraction = bounding box intersection / union .\nWhen computing  discrete  curves, an overlap  = 0.5 is considered a true positive, otherwise it is considered a false negative.\nWhen computing  continuous  curves, true positives and false negatives are measured fractionally as  overlap  and  1-overlap  respectively.  This function requires a current  R  installation with the following packages:  install.packages(c(\"ggplot2\", \"gplots\", \"reshape\", \"scales\", \"jpg\", \"png\"))    function definition:  bool br_plot_detection(int num_files, const char *files[], const char *destination, bool show = false)    parameters:     Parameter  Type  Description      num_files  int  Number of  .csv  files.    files[]  const char *  .csv  files created using  br_eval_detection .    destination  const char *  Basename for the resulting figures.    show  bool  Open  destination.pdf  using the system's default PDF viewer. Default is false.       output:  (bool) Returns true on success. Returns false on a failure to compile the figures due to a missing, out of date, or incomplete  R  installation.   see:   br_eval_detection ,  br_plot", 
            "title": "br_plot_detection"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_plot_landmarking", 
            "text": "Renders landmarking performance figures for a set of  .csv  files created by  br_eval_landmarking .  In order of their output, the figures are:\n1. Cumulative landmarks less than normalized error (CD)\n2. Normalized error box and whisker plots (Box)\n3. Normalized error violin plots (Violin)  Landmarking error is normalized against the distance between two predifined points, usually inter-ocular distance (IOD).    function definition:  bool br_plot_landmarking(int num_files, const char *files[], const char *destination, bool show = false)    parameters:     Parameter  Type  Description      num_files  int  Number of  .csv  files.    files[]  const char *  .csv  files created using  br_eval_landmarking .    destination  const char *  Basename for the resulting figures.    show  bool  Open  destination.pdf  using the system's default PDF viewer. Default is false.       output:  (bool) Returns true on success. Returns false on a failure to compile the figures due to a missing, out of date, or incomplete  R  installation.   see:   br_eval_landmarking ,  br_plot", 
            "title": "br_plot_landmarking"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_plot_metadata", 
            "text": "Renders metadata figures for a set of  .csv  files with specified columns.    function definition:  bool br_plot_metadata(int num_files, const char *files[], const char *columns, bool show = false)    parameters:     Parameter  Type  Description      num_files  int  Number of  .csv  files.    files[]  const char *  .csv  files created by enrolling templates to  .csv  metadata files.    columns  const char *  ';' seperated list of columns to plot.    show  bool  Open  PlotMetadata.pdf  using the system's default PDF viewer.       output:  (bool) Returns true on success. Returns false on a failure to compile the figures due to a missing, out of date, or incomplete  R  installation.   see:   br_plot", 
            "title": "br_plot_metadata"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_progress", 
            "text": "Returns current progress from  Context :: progress .    function definition:  float br_progress()    parameters:  None    output:  (float) Returns the completion percentage of the running process   see:   br_most_recent_message ,  br_time_remaining", 
            "title": "br_progress"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_read_pipe", 
            "text": "Read and parse arguments from a named pipe. Used by the  command line api  to implement  -daemon , generally not useful otherwise. Guaranteed to return at least one argument. For information on managed returned values see  here    function defintion:  void br_read_pipe(const char *pipe, int *argc, char ***argv)    parameters:     Parameter  Type  Description      pipe  const char *  Pipe name    argc  int *  Argument count    argv  char ***  Argument list       output:  (void)", 
            "title": "br_read_pipe"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_scratch_path", 
            "text": "Fills the buffer with the value of  Context :: scratchPath . For information on input string buffers see  here .    function defintion:  int br_scratch_path(char * buffer, int buffer_length)    parameters:     Parameter  Type  Description      buffer  char *  Buffer for scratch path    buffer_length  int  Length of buffer.       output:  (int) Returns the required size of the input buffer for the most recent message to fit completely   see:   br_version", 
            "title": "br_scratch_path"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_sdk_path", 
            "text": "Returns the full path to the root of the SDK.    function definition:  const char *br_sdk_path()    parameters:  None   output:  (const char *) Returns the full path to the root of the SDK  see:   br_initialize", 
            "title": "br_sdk_path"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_get_header", 
            "text": "Retrieve the target and query inputs in the  BEE matrix  header. For information on managed return values see  here .    function definition:  void br_get_header(const char *matrix, const char **target_gallery, const char **query_gallery)    parameters:     Parameter  Type  Description      matrix  const char *  The  BEE matrix  file to modify    target_gallery  const char **  The matrix target    query_gallery  const char **  The matrix query       output:  (void)   set:   br_set_header", 
            "title": "br_get_header"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_set_header", 
            "text": "Update the target and query inputs in the  BEE matrix  header.    function definition:  void br_set_header(const char *matrix, const char *target_gallery, const char *query_gallery)    parameters:     Parameter  Type  Description      matrix  const char *  The  BEE matrix  file to modify    target_gallery  const char **  The matrix target    query_gallery  const char **  The matrix query       output:  (void)   see:   br_get_header", 
            "title": "br_set_header"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_set_property", 
            "text": "Appends a provided value to the  global metadata  using a provided key.    function definition:  void br_set_property(const char *key, const char *value)    parameters:     Parameter  Type  Description      key  const char *  Key to append    value  const char *  Value to append       output:  (void)", 
            "title": "br_set_property"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_time_remaining", 
            "text": "Returns estimate of time remaining in the current process.    function definition:  int br_time_remaining()    parameters:  None   output:  (int) Returns an estimate of the time remaining  see:   br_most_recent_message ,  br_progress", 
            "title": "br_time_remaining"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_train", 
            "text": "Trains a provided model's  Transform  and  Distance  on the provided input.    function definiton:  void br_train(const char *input, const char *model = \"\")    parameters:     Parameter  Type  Description      input  const char *  The  Gallery  to train on.    model  const char *  (Optional) String specifying the binary file to serialize training results to. The trained algorithm can be recovered by using this file as the algorithm. By default the trained algorithm will not be serialized to disk.       output:  (void)   see:   br_train_n", 
            "title": "br_train"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_train_n", 
            "text": "Convenience function for training on multiple inputs    function definition:  void br_train_n(int num_inputs, const char *inputs[], const char *model = \"\")    parameters:     Parameter  Type  Description      num_inputs  int  Size of  inputs    inputs[]  const char *  An array of  galleries  to train on.    model  const char *  (Optional) String specifying the binary file to serialize training results to. The trained algorithm can be recovered by using this file as the algorithm. By default the trained algorithm will not be serialized to disk.       output:  (void)   see:   br_train", 
            "title": "br_train_n"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_version", 
            "text": "Get the current OpenBR version.    function definition:  const char *br_version()    parameters:  None   output:  (const char *) Returns the current OpenBR version  see:   br_about ,  br_scratch_path", 
            "title": "br_version"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_slave_process", 
            "text": "For internal use via  ProcessWrapperTransform    function definition:  void br_slave_process(const char * baseKey)    parameters:     Parameter  Type  Description      baseKey  const char *  base key for the slave process       output:  (void)", 
            "title": "br_slave_process"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_load_img", 
            "text": "Load an image from a string buffer. This is an easy way to pass an image in memory from another programming language to openbr.    function definition:  br_template br_load_img(const char *data, int len)    parameters:     Parameter  Type  Description      data  const char *  The image buffer.    len  int  The length of the buffer.       output:  ( br_template  Returns a  br_template  loaded with the provided image   see:   br_unload_img", 
            "title": "br_load_img"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_unload_img", 
            "text": "Unload an image to a string buffer. This is an easy way to pass an image from openbr to another programming language.    function definition:  unsigned char* br_unload_img(br_template tmpl)    parameters:     Parameter  Type  Description      tmpl  br_template  Pointer to a  Template       output:  (unsigned char*)  Returns a buffer loaded with the image data from tmpl   see:   br_load_img", 
            "title": "br_unload_img"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_template_list_from_buffer", 
            "text": "Deserialize a  TemplateList  from a buffer. Can be the buffer for a .gal file, since they are just a  TemplateList  serialized to disk.    function definition:  br_template_list br_template_list_from_buffer(const char *buf, int len)    return type:  br_template_list   parameters:      Parameter  Type  Description      buf  const char *  The buffer.    len  int  The length of the buffer.      output:  ( br_template_list ) Returns a pointer to a  TemplateList  created from the buffer.", 
            "title": "br_template_list_from_buffer"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_free_template", 
            "text": "Free a  Template's  memory.    function definition:  void br_free_template(br_template tmpl)    parameters:     Parameter  Type  Description      tmpl  br_template  Pointer to the  Template  to free.       output:  (void)", 
            "title": "br_free_template"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_free_template_list", 
            "text": "Free a  TemplateList's  memory.    function definition:  void br_free_template_list(br_template_list tl)    parameters:     Parameter  Type  Description      tl  br_template_list  Pointer to the  TemplateList  to free.       output:  (void)", 
            "title": "br_free_template_list"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_free_output", 
            "text": "Free a  Output's  memory.    function definition:  void br_free_output(br_matrix_output output)    parameters:     Parameter  Type  Description      output  br_matrix_output  Pointer to the Output  to free.       output:  (void)", 
            "title": "br_free_output"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_img_rows", 
            "text": "Returns the number of rows in an image.    function definition:  int br_img_rows(br_template tmpl)    parameters:     Parameter  Type  Description      tmpl  br_template  Pointer to a  Template .       output:  (int) Returns the number of rows in an image", 
            "title": "br_img_rows"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_img_cols", 
            "text": "Returns the number of cols in an image.    function definition:  int br_img_cols(br_template tmpl)    parameters:     Parameter  Type  Description      tmpl  br_template  Pointer to a  Template .       output:  (int) Returns the number of columns in an image", 
            "title": "br_img_cols"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_img_channels", 
            "text": "Returns the number of channels in an image.    function definition:  int br_img_channels(br_template tmpl)    parameters:     Parameter  Type  Description      tmpl  br_template  Pointer to a  Template .       output:  (int) Returns the number of channels in an image", 
            "title": "br_img_channels"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_img_is_empty", 
            "text": "Checks if the image is empty.    function definition:  bool br_img_is_empty(br_template tmpl)    parameters:     Parameter  Type  Description      tmpl  br_template  Pointer to a  Template .       output:  (bool) Returns true if the image is empty, false otherwise.", 
            "title": "br_img_is_empty"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_get_filename", 
            "text": "Get the name of the  file  of a provided  Template . For information on input string buffers please see  here    function definition:  int br_get_filename(char * buffer, int buffer_length, br_template tmpl)    parameters:     Parameter  Type  Description      buffer  char *  Buffer to hold the filename    buffer_length  int  Length of the buffer    tmpl  br_template  Pointer to a  Template .       output:  (int) Returns the size of the buffer required to hold the entire file name.", 
            "title": "br_get_filename"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_set_filename", 
            "text": "Set the name of the  file  for a provided  Template .    function definition:  void br_set_filename(br_template tmpl, const char *filename)    parameters:     Parameter  Type  Description      tmpl  br_template  Pointer to a  Template .    filename  const char *  New filename for the template.       output:  (void)", 
            "title": "br_set_filename"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_get_metadata_string", 
            "text": "Get the  metadata  value as a string for a provided key in a provided  Template .    function definition:  int br_get_metadata_string(char * buffer, int buffer_length, br_template tmpl, const char *key)    parameters:     Parameter  Type  Description      buffer  char *  Buffer to hold the metadata string.    buffer_length  int  length of the buffer.    tmpl  br_template  Pointer to a  Template .    key  const char *  Key for the metadata lookup       output:  (int) Returns the size of the buffer required to hold the entire metadata string", 
            "title": "br_get_metadata_string"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_enroll_template", 
            "text": "Enroll a  Template  from the C API!    function definition:  br_template_list br_enroll_template(br_template tmpl)    parameters:     Parameter  Type  Description      tmpl  br_template  Pointer to a  Template .       output:  ( br_template_list ) Returns a pointer to a  TemplateList", 
            "title": "br_enroll_template"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_enroll_template_list", 
            "text": "Enroll a  TemplateList  from the C API!    function definition:  void br_enroll_template_list(br_template_list tl)    parameters:     Parameter  Type  Description      tl  br_template_list  Pointer to a  TemplateList       output:  (void)", 
            "title": "br_enroll_template_list"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_compare_template_lists", 
            "text": "Compare  TemplateLists  from the C API!    function definition:  br_matrix_output br_compare_template_lists(br_template_list target, br_template_list query)    parameters:     Parameter  Type  Description      target  br_template_list  Pointer to a  TemplateList    query  br_template_list  Pointer to a  TemplateList       output:  ( br_matrix_output ) Returns a pointer to a  MatrixOutput", 
            "title": "br_compare_template_lists"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_get_matrix_output_at", 
            "text": "Get a value in a provided  MatrixOutput .    function definition:  float br_get_matrix_output_at(br_matrix_output output, int row, int col)    parameters:     Parameter  Type  Description      output  br_matrix_output  Pointer to  MatrixOutput    row  int  Row index for lookup    col  int  Column index for lookup       output:  (float) Returns the value of the  MatrixOutput  at the provided indexes.", 
            "title": "br_get_matrix_output_at"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_get_template", 
            "text": "Get a  Template  from a  TemplateList  at a specified index.    function definition:  br_template br_get_template(br_template_list tl, int index)    parameters:     Parameter  Type  Description      tl  br_template_list  Pointer to a  TemplateList    index  int  Index into the template list. Should be in the range [0,len(tl) - 1].       output:  ( br_template ) Returns a pointer to a  Template", 
            "title": "br_get_template"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_num_templates", 
            "text": "Get the number of  Templates  in a  TemplateList .    function definition:  int br_num_templates(br_template_list tl)    parameters:     Parameter  Type  Description      tl  br_template_list  Pointer to a  TemplateList       output:  (int) Returns the size of the provided  TemplateList", 
            "title": "br_num_templates"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_make_gallery", 
            "text": "Initialize a  Gallery  from a file.    function definition:  br_gallery br_make_gallery(const char *gallery)    parameters:     Parameter  Type  Description      gallery  const char *  String location of gallery on disk.       output:  ( br_gallery ) Returns a pointer to a  Gallery  that has been created from the provided file", 
            "title": "br_make_gallery"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_load_from_gallery", 
            "text": "Read a  TemplateList  from a  Gallery .    function definition:  br_template_list br_load_from_gallery(br_gallery gallery)    parameters:     Parameter  Type  Description      gallery  br_gallery  Pointer to a  Gallery       output:  ( br_template_list ) Returns a pointer to a  TemplateList  containing the data from the provided  Gallery", 
            "title": "br_load_from_gallery"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_add_template_to_gallery", 
            "text": "Write a  Template  to a  Gallery    function definition:  void br_add_template_to_gallery(br_gallery gallery, br_template tmpl)    parameters:     Parameter  Type  Description      gallery  br_gallery  Pointer to a  Gallery    tmpl  br_template  Pointer to a  Template       output:  (void)", 
            "title": "br_add_template_to_gallery"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_add_template_list_to_gallery", 
            "text": "Write a  TemplateList  to the  Gallery  on disk.    function definition:  void br_add_template_list_to_gallery(br_gallery gallery, br_template_list tl)    parameters:     Parameter  Type  Description      gallery  br_gallery  Pointer to a  Gallery    tl  br_template_list  Pointer to a  TemplateList       output:  (void)", 
            "title": "br_add_template_list_to_gallery"
        }, 
        {
            "location": "/api_docs/c_api/functions/#br_close_gallery", 
            "text": "Close a provided  Gallery .    function definition:  void br_close_gallery(br_gallery gallery)    parameters:     Parameter  Type  Description      gallery  br_gallery  Pointer to a  Gallery       output:  (void)         Zhu et al.  A Rank-Order Distance based Clustering Algorithm for Face Tagging ,\nCVPR 2011", 
            "title": "br_close_gallery"
        }, 
        {
            "location": "/api_docs/cl_api/", 
            "text": "The command line API is a tool to run OpenBR from the command line. The command line is the easiest and fastest way to run OpenBR!\n\n\nThe following is a detailed description of the command line API. The command line API is really just a set of wrappers to call the \nC API\n. All of the flags in this API have a corresponding C API call. To help display the examples the following shorthand definitions will be used:\n\n\n\n\n\n\n\n\nShortcut\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\narg\n\n\n Represent an input argument\n\n\n\n\n\n\n{arg}\n\n\n{} Represent an output argument\n\n\n\n\n\n\n[arg]\n\n\n[] Represent an optional argument\n\n\n\n\n\n\n(arg0 \n ... \n argN)\n\n\n(... \n ...) Represent a choice.\n\n\n\n\n\n\n\n\nAlgorithms\n\n\nAlmost every command line process needs to specify an algorithm to work properly. Algorithms in OpenBR are described in detail \nhere\n. To specify algorithms to the command line use the \n-algorithm\n flag like so:\n\n\n    -algorithm \"AlgorithmString\"\n\n\n\nMake sure you use the quotes if your algorithm is longer than one plugin because special characters in OpenBR are also special characters (with very different meanings!) in Bash.\n\n\nCore Commands\n\n\n-train\n\n\nTrain a model\n\n\n\n\n\n\narguments:\n\n\n-train \ngallery\n ... \ngallery\n [{model}]\n\n\n\n\n\n\n\nwraps:\n \nbr_train_n\n\n\n\n\n\n\n-enroll\n\n\nEnroll a \nGallery\n through an algorithm\n\n\n\n\n\n\narguments:\n\n\n-enroll \ninput_gallery\n ... \ninput_gallery\n {output_gallery}\n\n\n\n\n\n\n\nwraps:\n \nbr_enroll\n or \nbr_enroll_n\n depending on the input size\n\n\n\n\n\n\n-compare\n\n\nCompare query \nTemplates\n against a target \nGallery\n\n\n\n\n\n\narguments:\n\n\n-compare \ntarget_gallery\n \nquery_gallery\n [{output}]\n\n\n\n\n\n\n\nwraps:\n \nbr_compare\n\n\n\n\n\n\n-pairwiseCompare\n\n\nDOCUMENT ME\n\n\n\n\n\n\narguments:\n\n\n-pairwiseCompare \ntarget_gallery\n \nquery_gallery\n [{output}]\n\n\n\n\n\n\n\nwraps:\n \nbr_pairwise_compare\n\n\n\n\n\n\n-eval\n\n\nEvaluate a similarity matrix\n\n\n\n\n\n\narguments:\n\n\n-eval \nsimmat\n [\nmask\n] [{csv}] [{matches}]\n\n\n\n\n\n\n\nwraps:\n \nbr_eval\n\n\n\n\n\n\n-inplaceEval\n\n\nDOCUMENT ME\n\n\n\n\n\n\narguments:\n\n\n-inplaceEval \nsimmat\n \ntarget\n \nquery\n [{output}]\n\n\n\n\n\n\n\nwraps:\n \nbr_inplace_eval\n\n\n\n\n\n\n-plot\n\n\nPlot the results of an evaluation\n\n\n\n\n\n\narguments:\n\n\n       -plot \nfile\n ... \nfile\n {destination}\n\n\n\n\n\n\n\nwraps:\n \nbr_plot\n\n\n\n\n\n\nOther Commands\n\n\n-fuse\n\n\nPerform score level fusion on similarity matrices.\n\n\n\n\n\n\narguments:\n\n\n-fuse \nsimmat\n ... \nsimmat\n (None|MinMax|ZScore|WScore) (Min|Max|Sum[W1:W2:...:Wn]|Replace|Difference|None) {simmat}\n\n\n\n\n\n\n\nwraps:\n \nbr_fuse\n\n\n\n\n\n\n-cluster\n\n\nClusters one or more similarity matrices into a list of subjects\n\n\n\n\n\n\narguments:\n\n\n-cluster \nsimmat\n ... \nsimmat\n \naggressiveness\n {csv}\n\n\n\n\n\n\n\nwraps:\n \nbr_cluster\n\n\n\n\n\n\n-makeMask\n\n\nConstructs a mask from target and query inputs\n\n\n\n\n\n\narguments:\n\n\n-makeMask \ntarget_gallery\n \nquery_gallery\n {mask}\n\n\n\n\n\n\n\nwraps:\n \nbr_make_mask\n\n\n\n\n\n\n-makePairwiseMask\n\n\nConstructs a mask from target and query inputs considering the target and input sets to be definite pairwise comparisons.\n\n\n\n\n\n\narguments:\n\n\n-makePairwiseMask \ntarget_gallery\n \nquery_gallery\n {mask}\n\n\n\n\n\n\n\nwraps:\n \nbr_make_pairwise_mask\n\n\n\n\n\n\n-combineMasks\n\n\nCombines several equal-sized mask matrices. A comparison may not be simultaneously indentified as both a genuine and an imposter by different input masks.\n\n\n\n\n\n\narguments:\n\n\n-combineMasks \nmask\n ... \nmask\n {mask} (And|Or)\n\n\n\n\n\n\n\nwraps:\n \nbr_combine_masks\n\n\n\n\n\n\n-cat\n\n\nConcatenates a list of galleries into 1 gallery\n\n\n\n\n\n\narguments:\n\n\n-cat \ngallery\n ... \ngallery\n {gallery}\n\n\n\n\n\n\n\nwraps:\n \nbr_cat\n\n\n\n\n\n\n-convert\n\n\nConvert a file to a different type. Files can only be converted to types within the same group. For example formats can only be converted to other formats.\n\n\n\n\n\n\narguments:\n\n\n-convert (Format|Gallery|Output) \ninput_file\n {output_file}\n\n\n\n\n\n\n\nwraps:\n \nbr_convert\n\n\n\n\n\n\n-evalClassification\n\n\nEvaluates and prints classification accuracy to terminal\n\n\n\n\n\n\narguments:\n\n\n-evalClassification \npredicted_gallery\n \ntruth_gallery\n \npredicted property name\n \nground truth property name\n\n\n\n\n\n\n\n\nwraps:\n \nbr_eval_classification\n\n\n\n\n\n\n-evalClustering\n\n\nEvaluates and prints clustering accuracy to the terminal\n\n\n\n\n\n\narguments:\n\n\n-evalClustering \nclusters\n \ngallery\n\n\n\n\n\n\n\n\nwraps:\n \nbr_eval_clustering\n\n\n\n\n\n\n-evalDetection\n\n\nEvaluates and prints detection accuracy to terminal\n\n\n\n\n\n\narguments:\n\n\n-evalDetection \npredicted_gallery\n \ntruth_gallery\n [{csv}] [{normalize}] [{minSize}] [{maxSize}]\n\n\n\n\n\n\n\nwraps:\n \nbr_eval_detection\n\n\n\n\n\n\n-evalLandmarking\n\n\nEvaluates and prints landmarking accuracy to terminal\n\n\n\n\n\n\narguments:\n\n\n-evalLandmarking \npredicted_gallery\n \ntruth_gallery\n [{csv} [\nnormalization_index_a\n \nnormalization_index_b\n] [sample_index] [total_examples]]\n\n\n\n\n\n\n\nwraps:\n \nbr_eval_landmarking\n\n\n\n\n\n\n-evalRegression\n\n\nEvaluates regression accuracy to disk\n\n\n\n\n\n\narguments:\n\n\n-evalRegression \npredicted_gallery\n \ntruth_gallery\n \npredicted property name\n \nground truth property name\n\n\n\n\n\n\n\n\nwraps:\n \nbr_eval_regression\n\n\n\n\n\n\n-assertEval\n\n\nEvaluates the similarity matrix using the mask matrix.  Function aborts if TAR @ FAR = 0.001 does not meet an expected performance value.\n\n\n\n\n\n\narguments:\n\n\n-assertEval \nsimmat\n \nmask\n \naccuracy\n\n\n\n\n\n\n\n\nwraps:\n \nbr_assert_eval\n\n\n\n\n\n\n-plotDetection\n\n\nRenders detection performance figures for a set of .csv files created by \n-evalDetection\n.\n\n\n\n\n\n\narguments:\n\n\n-plotDetection \nfile\n ... \nfile\n {destination}\n\n\n\n\n\n\n\nwraps:\n \nbr_plot_detection\n\n\n\n\n\n\n-plotLandmarking\n\n\nRenders landmarking performance figures for a set of .csv files created by \n-evalLandmarking\n\n\n\n\n\n\narguments:\n\n\n-plotLandmarking \nfile\n ... \nfile\n {destination}\n\n\n\n\n\n\n\nwraps:\n \nbr_plot_landmarking\n\n\n\n\n\n\n-plotMetadata\n\n\nRenders metadata figures for a set of .csv files with specified columns\n\n\n\n\n\n\narguments:\n\n\n-plotMetadata \nfile\n ... \nfile\n \ncolumns\n\n\n\n\n\n\n\n\nwraps:\n \nbr_plot_metadata\n\n\n\n\n\n\n-project\n\n\nA naive alternative to \n-enroll\n\n\n\n\n\n\narguments:\n\n\n-project \ninput_gallery\n {output_gallery}\n\n\n\n\n\n\n\nwraps:\n \nbr_project\n\n\n\n\n\n\n-getHeader\n\n\nRetrieve the target and query inputs in the \nBEE matrix\n header\n\n\n\n\n\n\narguments:\n\n\n-getHeader \nmatrix\n\n\n\n\n\n\n\n\nwraps:\n \nbr_get_header\n\n\n\n\n\n\n-setHeader\n\n\nUpdate the target and query inputs in the \nBEE matrix\n header\n\n\n\n\n\n\narguments:\n\n\n-setHeader {\nmatrix\n} \ntarget_gallery\n \nquery_gallery\n\n\n\n\n\n\n\n\nwraps:\n \nbr_set_header\n\n\n\n\n\n\n-\nkey\n \nvalue\n\n\nAppends a provided value to the \nglobal metadata\n using a provided key\n\n\n\n\n\n\narguments:\n\n\n-\nkey\n \nvalue\n\n\n\n\n\n\n\n\nwraps:\n \nbr_set_property\n\n\n\n\n\n\nMiscellaneous\n\n\n-help\n\n\nPrint command line API documentation to the terminal\n\n\n\n\n\n\narguments:\n\n\n-help\n\n\n\n\n\n\n\nwraps:\n N/A\n\n\n\n\n\n\n-gui\n\n\nIf this flag is set OpenBR will enable GUI windows to be launched. It must be the first flag set.\n\n\n\n\n\n\narguments:\n\n\nbr -gui\n\n\n\n\n\n\n\nwraps:\n N/A\n\n\n\n\n\n\n-objects\n\n\nReturns names and parameters for the requested objects. Each object is newline separated. Arguments are separated from the object name with a tab. This function uses \nQRegExp\n syntax\n\n\n\n\n\n\narguments:\n\n\n-objects [abstraction [implementation]]\n\n\n\n\n\n\n\nwraps:\n \nbr_objects\n\n\n\n\n\n\n-about\n\n\nGet a string with the name, version, and copyright of the project. This string is suitable for printing or terminal\n\n\n\n\n\n\narguments:\n\n\n-about\n\n\n\n\n\n\n\nwraps:\n \nbr_about\n\n\n\n\n\n\n-version\n\n\nGet the current OpenBR version\n\n\n\n\n\n\narguments:\n\n\n-version\n\n\n\n\n\n\n\nwraps:\n \nbr_version\n\n\n\n\n\n\n-slave\n\n\nFor internal use via \nProcessWrapperTransform\n\n\n\n\n\n\narguments:\n\n\n-slave \nbaseKey\n\n\n\n\n\n\n\n\nwraps:\n \nbr_slave_process\n\n\n\n\n\n\n-daemon\n\n\nDOCUMENT ME\n\n\n\n\n\n\narguments:\n\n\n-daemon \ndaemon_pipe\n\n\n\n\n\n\n\n\nwraps:\n N/A\n\n\n\n\n\n\n-exit\n\n\nExit the application\n\n\n\n\n\n\narguments:\n\n\n-exit\n\n\n\n\n\n\n\nwraps:\n N/A", 
            "title": "Command Line API"
        }, 
        {
            "location": "/api_docs/cl_api/#algorithms", 
            "text": "Almost every command line process needs to specify an algorithm to work properly. Algorithms in OpenBR are described in detail  here . To specify algorithms to the command line use the  -algorithm  flag like so:      -algorithm \"AlgorithmString\"  Make sure you use the quotes if your algorithm is longer than one plugin because special characters in OpenBR are also special characters (with very different meanings!) in Bash.", 
            "title": "Algorithms"
        }, 
        {
            "location": "/api_docs/cl_api/#core-commands", 
            "text": "-train  Train a model    arguments:  -train  gallery  ...  gallery  [{model}]    wraps:   br_train_n    -enroll  Enroll a  Gallery  through an algorithm    arguments:  -enroll  input_gallery  ...  input_gallery  {output_gallery}    wraps:   br_enroll  or  br_enroll_n  depending on the input size    -compare  Compare query  Templates  against a target  Gallery    arguments:  -compare  target_gallery   query_gallery  [{output}]    wraps:   br_compare    -pairwiseCompare  DOCUMENT ME    arguments:  -pairwiseCompare  target_gallery   query_gallery  [{output}]    wraps:   br_pairwise_compare    -eval  Evaluate a similarity matrix    arguments:  -eval  simmat  [ mask ] [{csv}] [{matches}]    wraps:   br_eval    -inplaceEval  DOCUMENT ME    arguments:  -inplaceEval  simmat   target   query  [{output}]    wraps:   br_inplace_eval    -plot  Plot the results of an evaluation    arguments:         -plot  file  ...  file  {destination}    wraps:   br_plot", 
            "title": "Core Commands"
        }, 
        {
            "location": "/api_docs/cl_api/#other-commands", 
            "text": "-fuse  Perform score level fusion on similarity matrices.    arguments:  -fuse  simmat  ...  simmat  (None|MinMax|ZScore|WScore) (Min|Max|Sum[W1:W2:...:Wn]|Replace|Difference|None) {simmat}    wraps:   br_fuse    -cluster  Clusters one or more similarity matrices into a list of subjects    arguments:  -cluster  simmat  ...  simmat   aggressiveness  {csv}    wraps:   br_cluster    -makeMask  Constructs a mask from target and query inputs    arguments:  -makeMask  target_gallery   query_gallery  {mask}    wraps:   br_make_mask    -makePairwiseMask  Constructs a mask from target and query inputs considering the target and input sets to be definite pairwise comparisons.    arguments:  -makePairwiseMask  target_gallery   query_gallery  {mask}    wraps:   br_make_pairwise_mask    -combineMasks  Combines several equal-sized mask matrices. A comparison may not be simultaneously indentified as both a genuine and an imposter by different input masks.    arguments:  -combineMasks  mask  ...  mask  {mask} (And|Or)    wraps:   br_combine_masks    -cat  Concatenates a list of galleries into 1 gallery    arguments:  -cat  gallery  ...  gallery  {gallery}    wraps:   br_cat    -convert  Convert a file to a different type. Files can only be converted to types within the same group. For example formats can only be converted to other formats.    arguments:  -convert (Format|Gallery|Output)  input_file  {output_file}    wraps:   br_convert    -evalClassification  Evaluates and prints classification accuracy to terminal    arguments:  -evalClassification  predicted_gallery   truth_gallery   predicted property name   ground truth property name     wraps:   br_eval_classification    -evalClustering  Evaluates and prints clustering accuracy to the terminal    arguments:  -evalClustering  clusters   gallery     wraps:   br_eval_clustering    -evalDetection  Evaluates and prints detection accuracy to terminal    arguments:  -evalDetection  predicted_gallery   truth_gallery  [{csv}] [{normalize}] [{minSize}] [{maxSize}]    wraps:   br_eval_detection    -evalLandmarking  Evaluates and prints landmarking accuracy to terminal    arguments:  -evalLandmarking  predicted_gallery   truth_gallery  [{csv} [ normalization_index_a   normalization_index_b ] [sample_index] [total_examples]]    wraps:   br_eval_landmarking    -evalRegression  Evaluates regression accuracy to disk    arguments:  -evalRegression  predicted_gallery   truth_gallery   predicted property name   ground truth property name     wraps:   br_eval_regression    -assertEval  Evaluates the similarity matrix using the mask matrix.  Function aborts if TAR @ FAR = 0.001 does not meet an expected performance value.    arguments:  -assertEval  simmat   mask   accuracy     wraps:   br_assert_eval    -plotDetection  Renders detection performance figures for a set of .csv files created by  -evalDetection .    arguments:  -plotDetection  file  ...  file  {destination}    wraps:   br_plot_detection    -plotLandmarking  Renders landmarking performance figures for a set of .csv files created by  -evalLandmarking    arguments:  -plotLandmarking  file  ...  file  {destination}    wraps:   br_plot_landmarking    -plotMetadata  Renders metadata figures for a set of .csv files with specified columns    arguments:  -plotMetadata  file  ...  file   columns     wraps:   br_plot_metadata    -project  A naive alternative to  -enroll    arguments:  -project  input_gallery  {output_gallery}    wraps:   br_project    -getHeader  Retrieve the target and query inputs in the  BEE matrix  header    arguments:  -getHeader  matrix     wraps:   br_get_header    -setHeader  Update the target and query inputs in the  BEE matrix  header    arguments:  -setHeader { matrix }  target_gallery   query_gallery     wraps:   br_set_header    - key   value  Appends a provided value to the  global metadata  using a provided key    arguments:  - key   value     wraps:   br_set_property", 
            "title": "Other Commands"
        }, 
        {
            "location": "/api_docs/cl_api/#miscellaneous", 
            "text": "-help  Print command line API documentation to the terminal    arguments:  -help    wraps:  N/A    -gui  If this flag is set OpenBR will enable GUI windows to be launched. It must be the first flag set.    arguments:  br -gui    wraps:  N/A    -objects  Returns names and parameters for the requested objects. Each object is newline separated. Arguments are separated from the object name with a tab. This function uses  QRegExp  syntax    arguments:  -objects [abstraction [implementation]]    wraps:   br_objects    -about  Get a string with the name, version, and copyright of the project. This string is suitable for printing or terminal    arguments:  -about    wraps:   br_about    -version  Get the current OpenBR version    arguments:  -version    wraps:   br_version    -slave  For internal use via  ProcessWrapperTransform    arguments:  -slave  baseKey     wraps:   br_slave_process    -daemon  DOCUMENT ME    arguments:  -daemon  daemon_pipe     wraps:  N/A    -exit  Exit the application    arguments:  -exit    wraps:  N/A", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/api_docs/python_api/", 
            "text": "Python API\n\n\nThe Python API is a light wrapper of the C API. It creates an object that has \nall the C functions\n:\n\n\nfrom brpy import init_brpy\n\n# br_loc is /usr/local/lib by default,\n# you may change this by passing a different path to the shared objects\nbr = init_brpy(br_loc='/path/to/libopenbr')\nbr.br_initialize_default()\n\nimg = open('catpic.jpg','rb').read()\n\nbr.br_set_property('algorithm','MyCatFaceDetectionModel')\nbr.br_set_property('enrollAll','true')\n\ntmpl = br.br_load_img(img, len(img))\ncatfaces = br.br_enroll_template(tmpl)\n\nprint('This pic has %i cats in it!' % br.br_num_templates(catfaces))\n\nbr.br_free_template(tmpl)\nbr.br_free_template_list(catfaces)\nbr.br_finalize()\n\n\n\nTo enable the module, add \n-DBR_INSTALL_BRPY=ON\n to your cmake command (or use the ccmake GUI - highly recommended).\n\n\nCurrently only OS X and Linux are supported.", 
            "title": "Python Wrapper API"
        }, 
        {
            "location": "/api_docs/python_api/#python-api", 
            "text": "The Python API is a light wrapper of the C API. It creates an object that has  all the C functions :  from brpy import init_brpy\n\n# br_loc is /usr/local/lib by default,\n# you may change this by passing a different path to the shared objects\nbr = init_brpy(br_loc='/path/to/libopenbr')\nbr.br_initialize_default()\n\nimg = open('catpic.jpg','rb').read()\n\nbr.br_set_property('algorithm','MyCatFaceDetectionModel')\nbr.br_set_property('enrollAll','true')\n\ntmpl = br.br_load_img(img, len(img))\ncatfaces = br.br_enroll_template(tmpl)\n\nprint('This pic has %i cats in it!' % br.br_num_templates(catfaces))\n\nbr.br_free_template(tmpl)\nbr.br_free_template_list(catfaces)\nbr.br_finalize()  To enable the module, add  -DBR_INSTALL_BRPY=ON  to your cmake command (or use the ccmake GUI - highly recommended).  Currently only OS X and Linux are supported.", 
            "title": "Python API"
        }, 
        {
            "location": "/api_docs/cpp_api/", 
            "text": "C++ Plugin API\n\n\nThe C++ Plugin API is a pluggable API designed to allow the succinct expression of biometrics algorithms as a series of independent plugins. The API exposes a number of data structures and plugin abstractions to use as simple building blocks for complex algorithms.\n\n\nData Structures\n\n\nThe API defines two data structures:\n\n\n\n\nFile\ns are typically used to store the path to a file on disk with associated metadata (in the form of key-value pairs). In the example above, we store the rectangles detected by \nCascade\n as metadata which are then used by \nDraw\n for visualization.\n\n\nTemplate\ns are containers for images and \nFile\ns. Images in OpenBR are OpenCV Mats and are member variables of Templates. Templates can contain one or more images.\n\n\n\n\nPlugin Abstractions\n\n\nA plugin in OpenBR is defined as \nclasses which modify, interpret, or assist with the modification of OpenBR compatible images and/or metadata\n. All OpenBR plugins have a common ancestor, \nObject\n, and they all are constructed from string descriptions given by \nFiles\n. There are eight base abstractions that derive from \nObject\n, one of which should be the parent for all production plugins. They are:\n\n\n\n\n\n\n\n\nPlugin\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nInitializer\n\n\nInitializes shared contexts and variables at the launch of OpenBR. Typically used with third-party plugins.\n\n\n\n\n\n\nTransform\n\n\nThe most common plugin type in OpenBR. Provides the basis for algorithms by transforming images or metadata.\n\n\n\n\n\n\nDistance\n\n\nUsed to compute a distance metric between \nTemplate\ns.\n\n\n\n\n\n\nFormat\n\n\nUsed for I/O. Formats handle file types that correspond to single objects (e.g. .jpg, .png, etc.).\n\n\n\n\n\n\nGallery\n\n\nUsed for I/O. Galleries handle file types that correspond to many objects (e.g. .csv., .xml, etc.).\n\n\n\n\n\n\nOutput\n\n\nUsed for I/O. Outputs handle the results of \nDistance\n comparisons.\n\n\n\n\n\n\nRepresentation\n\n\nConverts images into feature vectors. Slightly different then \nTransform\ns in implementation and available API calls.\n\n\n\n\n\n\nClassifier\n\n\nClassifies feature vectors as members of specific classes or performs regression on them.\n\n\n\n\n\n\n\n\nAdditionally, there are several child-abstractions for specific use cases. A few examples are:\n\n\n\n\n\n\n\n\nPlugin\n\n\nParent\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nUntrainableTransform\n\n\nTransform\n\n\nA \nTransform\n that cannot be trained.\n\n\n\n\n\n\nMetaTransform\n\n\nTransform\n\n\nA \nTransform\n that is \nnot\n \nindependent\n.\n\n\n\n\n\n\nUntrainableMetaTransform\n\n\nUntrainableTransform\n\n\nA \nTransform\n that is \nnot\n \nindependent\n and cannot be trained.\n\n\n\n\n\n\nMetadataTransform\n\n\nTransform\n\n\nA \nTransform\n that operates only on \nTemplate\n \nmetadata\n.\n\n\n\n\n\n\nTimeVaryingTransform\n\n\nTransform\n\n\nA \nTransform\n that changes at runtime as a result of the input.\n\n\n\n\n\n\nUntrainableDistance\n\n\nDistance\n\n\nA \nDistance\n that cannot be trained.\n\n\n\n\n\n\nMatrixOutput\n\n\nOutput\n\n\nA \nOutput\n that outputs data as a matrix.\n\n\n\n\n\n\n\n\nAs previously mentioned, all plugins in OpenBR are constructed using strings stored as \nFiles\n. The construction is done at runtime by a \nFactory\n class\n1\n. The \nFactory\n expects strings of the form \nPluginName(property1=value1,property2=value2...propertyN=valueN)\n (value lists are also permitted). It looks up the \nPluginName\n in a static registry and builds the plugin if found. The registry is populated using a special macro \nBR_REGISTER\n; each plugin needs to register itself and its base abstraction in the factory to enable construction. The purpose of this is to allow algorithms to be described completely by strings. For more information on algorithms in OpenBR please see the \ntutorial\n\n\n\n\n\n\n\n\n\n\nIndustrial Strength Pluggable Factories", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/#c-plugin-api", 
            "text": "The C++ Plugin API is a pluggable API designed to allow the succinct expression of biometrics algorithms as a series of independent plugins. The API exposes a number of data structures and plugin abstractions to use as simple building blocks for complex algorithms.", 
            "title": "C++ Plugin API"
        }, 
        {
            "location": "/api_docs/cpp_api/#data-structures", 
            "text": "The API defines two data structures:   File s are typically used to store the path to a file on disk with associated metadata (in the form of key-value pairs). In the example above, we store the rectangles detected by  Cascade  as metadata which are then used by  Draw  for visualization.  Template s are containers for images and  File s. Images in OpenBR are OpenCV Mats and are member variables of Templates. Templates can contain one or more images.", 
            "title": "Data Structures"
        }, 
        {
            "location": "/api_docs/cpp_api/#plugin-abstractions", 
            "text": "A plugin in OpenBR is defined as  classes which modify, interpret, or assist with the modification of OpenBR compatible images and/or metadata . All OpenBR plugins have a common ancestor,  Object , and they all are constructed from string descriptions given by  Files . There are eight base abstractions that derive from  Object , one of which should be the parent for all production plugins. They are:     Plugin  Function      Initializer  Initializes shared contexts and variables at the launch of OpenBR. Typically used with third-party plugins.    Transform  The most common plugin type in OpenBR. Provides the basis for algorithms by transforming images or metadata.    Distance  Used to compute a distance metric between  Template s.    Format  Used for I/O. Formats handle file types that correspond to single objects (e.g. .jpg, .png, etc.).    Gallery  Used for I/O. Galleries handle file types that correspond to many objects (e.g. .csv., .xml, etc.).    Output  Used for I/O. Outputs handle the results of  Distance  comparisons.    Representation  Converts images into feature vectors. Slightly different then  Transform s in implementation and available API calls.    Classifier  Classifies feature vectors as members of specific classes or performs regression on them.     Additionally, there are several child-abstractions for specific use cases. A few examples are:     Plugin  Parent  Function      UntrainableTransform  Transform  A  Transform  that cannot be trained.    MetaTransform  Transform  A  Transform  that is  not   independent .    UntrainableMetaTransform  UntrainableTransform  A  Transform  that is  not   independent  and cannot be trained.    MetadataTransform  Transform  A  Transform  that operates only on  Template   metadata .    TimeVaryingTransform  Transform  A  Transform  that changes at runtime as a result of the input.    UntrainableDistance  Distance  A  Distance  that cannot be trained.    MatrixOutput  Output  A  Output  that outputs data as a matrix.     As previously mentioned, all plugins in OpenBR are constructed using strings stored as  Files . The construction is done at runtime by a  Factory  class 1 . The  Factory  expects strings of the form  PluginName(property1=value1,property2=value2...propertyN=valueN)  (value lists are also permitted). It looks up the  PluginName  in a static registry and builds the plugin if found. The registry is populated using a special macro  BR_REGISTER ; each plugin needs to register itself and its base abstraction in the factory to enable construction. The purpose of this is to allow algorithms to be described completely by strings. For more information on algorithms in OpenBR please see the  tutorial      Industrial Strength Pluggable Factories", 
            "title": "Plugin Abstractions"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/", 
            "text": "IsClassifier\n\n\nDetermines if the given algorithm is a classifier. A classifier is defined as a \nTransform\n with no associated \nDistance\n. Instead metadata fields with the predicted output classes are populated in \nTemplate\n \nfiles\n.\n\n\n\n\n\n\nfunction definition:\n\n\nbool IsClassifier(const QString \nalgorithm)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalgorithm\n\n\nconst \nQString\n \n\n\nAlgorithm to evaluate\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) True if the algorithm is a classifier and false otherwise\n\n\n\n\nsee:\n \nbr_is_classifier\n\n\nexample:\nIsClassifier(\"Identity\"); // returns true\nIsClassifier(\"Identity:Dist\"); // returns false\n\n\n\n\n\n\n\n\n\nTrain\n\n\nHigh level function for creating models.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid Train(const File \ninput, const File \nmodel)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nconst \nFile\n \n\n\nTraining data\n\n\n\n\n\n\nmodel\n\n\nconst \nFile\n \n\n\nModel file\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n The \ntraining tutorial\n for an example of training.\n\n\nexample:\nFile file(\"/path/to/images/or/gallery.gal\");\nFile model(\"/path/to/model/file\");\nTrain(file, model);\n\n\n\n\n\n\n\n\n\nEnroll\n\n\nHigh level function for creating \ngalleries\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid Enroll(const File \ninput, const File \ngallery = File())\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nconst \nFile\n \n\n\nPath to enrollment file\n\n\n\n\n\n\ngallery\n\n\nconst \nFile\n \n\n\n(Optional) Path to gallery file.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_enroll\n\n\nexample:\nFile file(\"/path/to/images/or/gallery.gal\");\nEnroll(file); // Don't need to specify a gallery file\nFile gallery(\"/path/to/gallery/file\");\nEnroll(file, gallery); // Will write to the specified gallery file\n\n\n\n\n\n\n\n\n\nEnroll\n\n\nHigh level function for enrolling templates. Templates are modified in place as they are projected through the algorithm.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid Enroll(TemplateList \ntmpl)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntmpl\n\n\nTemplateList\n \n\n\nData to enroll\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplateList tList = TemplateList() \n Template(\"picture1.jpg\")\n                                    \n Template(\"picture2.jpg\")\n                                    \n Template(\"picture3.jpg\");\nEnroll(tList);\n\n\n\n\n\n\n\n\n\nProject\n\n\nA naive alternative to \nEnroll\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid Project(const File \ninput, const File \noutput)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nconst \nFile\n \n\n\nPath to enrollment file\n\n\n\n\n\n\ngallery\n\n\nconst \nFile\n \n\n\nPath to gallery file.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nEnroll\n\n\nexample:\nFile file(\"/path/to/images/or/gallery.gal\");\nFile output(\"/path/to/gallery/file\");\nProject(file, gallery); // Will write to the specified gallery file\n\n\n\n\n\n\n\n\n\nCompare\n\n\nHigh level function for comparing galleries. Each template in the \nqueryGallery\n is compared against every template in the \ntargetGallery\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid Compare(const File \ntargetGallery, const File \nqueryGallery, const File \noutput)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetGallery\n\n\nconst \nFile\n \n\n\nGallery of target templates\n\n\n\n\n\n\nqueryGallery\n\n\nconst \nFile\n \n\n\nGallery of query templates\n\n\n\n\n\n\noutput\n\n\nconst \nFile\n \n\n\nOutput file for results\n\n\n\n\n\n\n\n\n\n\n\n\nreturns:\n (output)\n\n\n\n\nsee:\n \nbr_compare\n\n\nexample:\nFile target(\"/path/to/target/images/\");\nFile query(\"/path/to/query/images/\");\nFile output(\"/path/to/output/file\");\nCompare(target, query, output);\n\n\n\n\n\n\n\n\n\nCompareTemplateList\n\n\nHigh level function for comparing templates.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid CompareTemplateLists(const TemplateList \ntarget, const TemplateList \nquery, Output *output);\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntarget\n\n\nconst \nTemplateList\n \n\n\nTarget templates\n\n\n\n\n\n\nquery\n\n\nconst \nTemplateList\n \n\n\nQuery templates\n\n\n\n\n\n\noutput\n\n\nOutput\n *\n\n\nOutput file for results\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplateList targets = TemplateList() \n Template(\"target_img1.jpg\")\n                                      \n Template(\"target_img2.jpg\")\n                                      \n Template(\"target_img3.jpg\");\n\nTemplateList query = TemplateList() \n Template(\"query_img.jpg\");\nOutput *output = Factory::make\nOutput\n(\"/path/to/output/file\");\n\nCompareTemplateLists(targets, query, output);\n\n\n\n\n\n\n\n\n\nPairwiseCompare\n\n\nHigh level function for doing a series of pairwise comparisons.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid PairwiseCompare(const File \ntargetGallery, const File \nqueryGallery, const File \noutput)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetGallery\n\n\nconst \nFile\n \n\n\nGallery of target templates\n\n\n\n\n\n\nqueryGallery\n\n\nconst \nFile\n \n\n\nGallery of query templates\n\n\n\n\n\n\noutput\n\n\nconst \nFile\n \n\n\nOutput file for results\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_pairwise_comparison\n\n\nexample:\nFile target(\"/path/to/target/images/\");\nFile query(\"/path/to/query/images/\");\nFile output(\"/path/to/output/file\");\nPairwiseCompare(target, query, output);\n\n\n\n\n\n\n\n\n\nConvert\n\n\nChange the format of the \ninputFile\n to the format of the \noutputFile\n. Both the \ninputFile\n format and the \noutputFile\n format must be of the same format group, which is specified by the \nfileType\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid Convert(const File \nfileType, const File \ninputFile, const File \noutputFile)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfileType\n\n\nconst \nFile\n \n\n\nCan be either: \n \nFormat\n \nGallery\n \nOutput\n \n\n\n\n\n\n\ninputFile\n\n\nconst \nFile\n \n\n\nFile to be converted. Format is inferred from the extension.\n\n\n\n\n\n\noutputFile\n\n\nconst \nFile\n \n\n\nFile to store converted input. Format is inferred from the extension.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile input(\"input.csv\");\nFile output(\"output.xml\");\nConvert(\"Format\", input, output);\n\n\n\n\n\n\n\n\n\nCat\n\n\nConcatenate several galleries into one.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid Cat(const QStringList \ninputGalleries, const QString \noutputGallery)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninputGalleries\n\n\nconst \nQStringList\n \n\n\nList of galleries to concatenate\n\n\n\n\n\n\noutputGallery\n\n\nconst \nQString\n \n\n\nGallery to store the concatenated result. This gallery cannot be in the inputGalleries\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_cat\n\n\nexample:\nQStringList inputGalleries = QStringList() \n \"/path/to/gallery1\"\n                                           \n \"/path/to/gallery2\"\n                                           \n \"/path/to/gallery3\";\n\nQString outputGallery = \"/path/to/outputGallery\";\nCat(inputGalleries, outputGallery);\n\n\n\n\n\n\n\n\n\nDeduplicate\n\n\nDeduplicate a gallery. A duplicate is defined as an image with a match score above a given threshold to another image in the gallery.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid Deduplicate(const File \ninputGallery, const File \noutputGallery, const QString \nthreshold)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninputGallery\n\n\nconst \nFile\n \n\n\nGallery to deduplicate\n\n\n\n\n\n\noutputGallery\n\n\nconst \nFile\n \n\n\nGallery to store the deduplicated result\n\n\n\n\n\n\nthreshold\n\n\nconst \nQString\n \n\n\nMatch score threshold to determine duplicates\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nbr_deduplicate\n\n\nexample:\nFile input(\"/path/to/input/galley/with/dups\");\nFile output(\"/path/to/output/gallery\");\nDeduplicate(input, output, \"0.7\"); // Remove duplicates with match scores above 0.7", 
            "title": "API Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#isclassifier", 
            "text": "Determines if the given algorithm is a classifier. A classifier is defined as a  Transform  with no associated  Distance . Instead metadata fields with the predicted output classes are populated in  Template   files .    function definition:  bool IsClassifier(const QString  algorithm)    parameters:     Parameter  Type  Description      algorithm  const  QString    Algorithm to evaluate       output:  (bool) True if the algorithm is a classifier and false otherwise   see:   br_is_classifier  example: IsClassifier(\"Identity\"); // returns true\nIsClassifier(\"Identity:Dist\"); // returns false", 
            "title": "IsClassifier"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#train", 
            "text": "High level function for creating models.    function definition:  void Train(const File  input, const File  model)    parameters:     Parameter  Type  Description      input  const  File    Training data    model  const  File    Model file       output:  (void)   see:  The  training tutorial  for an example of training.  example: File file(\"/path/to/images/or/gallery.gal\");\nFile model(\"/path/to/model/file\");\nTrain(file, model);", 
            "title": "Train"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#enroll-1", 
            "text": "High level function for creating  galleries .    function definition:  void Enroll(const File  input, const File  gallery = File())    parameters:     Parameter  Type  Description      input  const  File    Path to enrollment file    gallery  const  File    (Optional) Path to gallery file.       output:  (void)   see:   br_enroll  example: File file(\"/path/to/images/or/gallery.gal\");\nEnroll(file); // Don't need to specify a gallery file\nFile gallery(\"/path/to/gallery/file\");\nEnroll(file, gallery); // Will write to the specified gallery file", 
            "title": "Enroll"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#enroll-2", 
            "text": "High level function for enrolling templates. Templates are modified in place as they are projected through the algorithm.    function definition:  void Enroll(TemplateList  tmpl)    parameters:     Parameter  Type  Description      tmpl  TemplateList    Data to enroll       output:  (void)   example: TemplateList tList = TemplateList()   Template(\"picture1.jpg\")\n                                      Template(\"picture2.jpg\")\n                                      Template(\"picture3.jpg\");\nEnroll(tList);", 
            "title": "Enroll"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#project", 
            "text": "A naive alternative to  Enroll .    function definition:  void Project(const File  input, const File  output)    parameters:     Parameter  Type  Description      input  const  File    Path to enrollment file    gallery  const  File    Path to gallery file.       output:  (void)   see:   Enroll  example: File file(\"/path/to/images/or/gallery.gal\");\nFile output(\"/path/to/gallery/file\");\nProject(file, gallery); // Will write to the specified gallery file", 
            "title": "Project"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#compare", 
            "text": "High level function for comparing galleries. Each template in the  queryGallery  is compared against every template in the  targetGallery .    function definition:  void Compare(const File  targetGallery, const File  queryGallery, const File  output)    parameters:     Parameter  Type  Description      targetGallery  const  File    Gallery of target templates    queryGallery  const  File    Gallery of query templates    output  const  File    Output file for results       returns:  (output)   see:   br_compare  example: File target(\"/path/to/target/images/\");\nFile query(\"/path/to/query/images/\");\nFile output(\"/path/to/output/file\");\nCompare(target, query, output);", 
            "title": "Compare"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#comparetemplatelists", 
            "text": "High level function for comparing templates.    function definition:  void CompareTemplateLists(const TemplateList  target, const TemplateList  query, Output *output);    parameters:     Parameter  Type  Description      target  const  TemplateList    Target templates    query  const  TemplateList    Query templates    output  Output  *  Output file for results       output:  (void)   example: TemplateList targets = TemplateList()   Template(\"target_img1.jpg\")\n                                        Template(\"target_img2.jpg\")\n                                        Template(\"target_img3.jpg\");\n\nTemplateList query = TemplateList()   Template(\"query_img.jpg\");\nOutput *output = Factory::make Output (\"/path/to/output/file\");\n\nCompareTemplateLists(targets, query, output);", 
            "title": "CompareTemplateList"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#pairwisecompare", 
            "text": "High level function for doing a series of pairwise comparisons.    function definition:  void PairwiseCompare(const File  targetGallery, const File  queryGallery, const File  output)    parameters:     Parameter  Type  Description      targetGallery  const  File    Gallery of target templates    queryGallery  const  File    Gallery of query templates    output  const  File    Output file for results       output:  (void)   see:   br_pairwise_comparison  example: File target(\"/path/to/target/images/\");\nFile query(\"/path/to/query/images/\");\nFile output(\"/path/to/output/file\");\nPairwiseCompare(target, query, output);", 
            "title": "PairwiseCompare"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#convert", 
            "text": "Change the format of the  inputFile  to the format of the  outputFile . Both the  inputFile  format and the  outputFile  format must be of the same format group, which is specified by the  fileType .    function definition:  void Convert(const File  fileType, const File  inputFile, const File  outputFile)    parameters:     Parameter  Type  Description      fileType  const  File    Can be either:    Format   Gallery   Output      inputFile  const  File    File to be converted. Format is inferred from the extension.    outputFile  const  File    File to store converted input. Format is inferred from the extension.       output:  (void)   example: File input(\"input.csv\");\nFile output(\"output.xml\");\nConvert(\"Format\", input, output);", 
            "title": "Convert"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#cat", 
            "text": "Concatenate several galleries into one.    function definition:  void Cat(const QStringList  inputGalleries, const QString  outputGallery)    parameters:     Parameter  Type  Description      inputGalleries  const  QStringList    List of galleries to concatenate    outputGallery  const  QString    Gallery to store the concatenated result. This gallery cannot be in the inputGalleries       output:  (void)   see:   br_cat  example: QStringList inputGalleries = QStringList()   \"/path/to/gallery1\"\n                                             \"/path/to/gallery2\"\n                                             \"/path/to/gallery3\";\n\nQString outputGallery = \"/path/to/outputGallery\";\nCat(inputGalleries, outputGallery);", 
            "title": "Cat"
        }, 
        {
            "location": "/api_docs/cpp_api/apifunctions/#deduplicate", 
            "text": "Deduplicate a gallery. A duplicate is defined as an image with a match score above a given threshold to another image in the gallery.    function definition:  void Deduplicate(const File  inputGallery, const File  outputGallery, const QString  threshold)    parameters:     Parameter  Type  Description      inputGallery  const  File    Gallery to deduplicate    outputGallery  const  File    Gallery to store the deduplicated result    threshold  const  QString    Match score threshold to determine duplicates       output:  (void)   see:   br_deduplicate  example: File input(\"/path/to/input/galley/with/dups\");\nFile output(\"/path/to/output/gallery\");\nDeduplicate(input, output, \"0.7\"); // Remove duplicates with match scores above 0.7", 
            "title": "Deduplicate"
        }, 
        {
            "location": "/api_docs/cpp_api/file/file/", 
            "text": "A file path with associated metadata.\n\n\nSee:\n\n\n\n\nMembers\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nThe File is one of two important data structures in OpenBR (the \nTemplate\n is the other).\nIt is typically used to store the path to a file on disk with associated metadata.\nThe ability to associate a key/value metadata table with the file helps keep the API simple while providing customizable behavior.\n\n\nWhen querying the value of a metadata key, the value will first try to be resolved against the file's private metadata table.\nIf the key does not exist in its local table then it will be resolved against the properties in the global Context.\nBy design file metadata may be set globally using Context::setProperty to operate on all files.\n\n\nFiles have a simple grammar that allow them to be converted to and from strings.\nIf a string ends with a \n]\n or \n)\n then the text within the final \n[]\n or \n()\n are parsed as comma separated metadata fields.\nBy convention, fields within \n[]\n are expected to have the format \n[key1=value1, key2=value2, ..., keyN=valueN]\n where order is irrelevant.\nFields within \n()\n are expected to have the format \n(value1, value2, ..., valueN)\n where order matters and the key context dependent.\nThe left hand side of the string not parsed in a manner described above is assigned to \nname\n.\n\n\nValues are not necessarily stored as strings in the metadata table.\nThe system will attempt to infer and convert them to their \"native\" type.\nThe conversion logic is as follows:\n\n\n\n\nIf the value starts with \n[\n and ends with \n]\n then it is treated as a comma separated list and represented with \nQVariantList\n. Each value in the list is parsed recursively.\n\n\nIf the value starts with \n(\n and ends with \n)\n and contains four comma separated elements, each convertable to a floating point number, then it is represented with \nQRectF\n.\n\n\nIf the value starts with \n(\n and ends with \n)\n and contains two comma separated elements, each convertable to a floating point number, then it is represented with \nQPointF\n.\n\n\nIf the value is convertable to a floating point number then it is represented with \nfloat\n.\n\n\nOtherwise, it is represented with \nQString\n.\n\n\n\n\nMetadata keys fall into one of two categories:\n\n camelCaseKeys are inputs that specify how to process the file.\n\n Capitalized_Underscored_Keys are outputs computed from processing the file.\n\n\nBelow are some of the most commonly occurring standardized keys:\n\n\n\n\n\n\n\n\nKey\n\n\nValue\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nQString\n\n\nContents of \nname\n\n\n\n\n\n\nseparator\n\n\nQString\n\n\nSeparate \nname\n into multiple files\n\n\n\n\n\n\nIndex\n\n\nint\n\n\nIndex of a template in a template list\n\n\n\n\n\n\nConfidence\n\n\nfloat\n\n\nClassification/Regression quality\n\n\n\n\n\n\nFTE\n\n\nbool\n\n\nFailure to enroll\n\n\n\n\n\n\nFTO\n\n\nbool\n\n\nFailure to open\n\n\n\n\n\n\n*_X\n\n\nfloat\n\n\nPosition\n\n\n\n\n\n\n*_Y\n\n\nfloat\n\n\nPosition\n\n\n\n\n\n\n*_Width\n\n\nfloat\n\n\nSize\n\n\n\n\n\n\n*_Height\n\n\nfloat\n\n\nSize\n\n\n\n\n\n\n*_Radius\n\n\nfloat\n\n\nSize\n\n\n\n\n\n\nLabel\n\n\nQString\n\n\nClass label\n\n\n\n\n\n\nTheta\n\n\nfloat\n\n\nPose\n\n\n\n\n\n\nRoll\n\n\nfloat\n\n\nPose\n\n\n\n\n\n\nPitch\n\n\nfloat\n\n\nPose\n\n\n\n\n\n\nYaw\n\n\nfloat\n\n\nPose\n\n\n\n\n\n\nPoints\n\n\nQList\nQPointF\n\n\nList of unnamed points\n\n\n\n\n\n\nRects\n\n\nQList\nRect\n\n\nList of unnamed rects\n\n\n\n\n\n\nAge\n\n\nfloat\n\n\nAge used for demographic filtering\n\n\n\n\n\n\nGender\n\n\nQString\n\n\nSubject gender\n\n\n\n\n\n\nTrain\n\n\nbool\n\n\nThe data is for training, as opposed to enrollment\n\n\n\n\n\n\n_*\n\n\n*\n\n\nReserved for internal use", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/file/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nQString\n\n\nPath to a file on disk\n\n\n\n\n\n\nfte\n\n\nbool\n\n\nFailed to enroll. If true this file failed to be processed somewhere in the template enrollment algorithm\n\n\n\n\n\n\nm_metadata\n\n\nQVariantMap\n\n\nMap for storing metadata. It is a \nQString\n, \nQVariant\n key value pairing.", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/file/constructors/", 
            "text": "Constructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFile()\n\n\nDefault constructor. Sets \nname\n to false.\n\n\n\n\n\n\nFile(const \nQString\n \nfile)\n\n\nInitializes the file by calling the private function init.\n\n\n\n\n\n\nFile(const \nQString\n \nfile, const \nQVariant\n \nlabel)\n\n\nInitializes the file by calling the private function init. Append label to the \nmetadata\n using the key \"Label\".\n\n\n\n\n\n\nFile(const char *file)\n\n\nInitializes the file with a c-style string.\n\n\n\n\n\n\nFile(const \nQVariantMap\n \nmetadata)\n\n\nSets \nname\n to false and sets the \nfile metadata\n to metadata.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/file/statics/", 
            "text": "QVariant\n parse(const \nQString\n \nvalue)\n\n\nTry to convert a given value to a \nQPointF\n, \nQRectF\n, int or float.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QVariant parse(const QString \nvalue);\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nconst \nQString\n \n\n\nString value to be converted.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQVariant\n) The converted file if a conversion was possible. Otherwise the unconverted string is returned.\n\n\n\n\nexample:\nQString point = \"(1, 1)\";\nQString rect = \"(1, 1, 5, 5)\";\nQString integer = \"1\";\nQString fp = \"1.0\";\nQString string = \"Hello World\";\n\nFile::parse(point);   // returns QVariant(QPointF, QPointF(1, 1))\nFile::parse(rect);    // returns QVariant(QRectF, QRectF(1, 1, 5x5))\nFile::parse(integer); // returns QVariant(int, 1)\nFile::parse(fp);      // returns QVariant(float, 1.0f)\nFile::parse(string);  // returns QVariant(QString, \"Hello World\")\n\n\n\n\n\n\n\nQList\nQVariant\n values(const \nQList\nU\n \nfileList, const \nQString\n \nkey)\n\n\nGather a list of \nQVariant\n values associated with a metadata key from a provided list of files.\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate\nclass U\n static [QList\nQVariant\n values(const QList\nU\n \nfileList, const QString \nkey)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfileList\n\n\nconst \nQList\nU\n \n\n\nA list of files to parse for values. A type is required for \nU\n. Valid options are: \n \nFile\n \nQString\n \n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nA metadata key used to lookup the values.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nQVariant\n) A list of \nQVariant\n values associated with the given key in each of the provided files.\n\n\n\n\nexample:\nFile f1, f2;\nf1.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf1.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\nf2.set(\"Key1\", QVariant::fromValue\nfloat\n(3));\n\nFile::values\nFile\n(QList\nFile\n() \n f1 \n f2, \"Key1\"); // returns [QVariant(float, 1),\n                                                       //          QVariant(float, 3)]\n\n\n\n\n\n\n\nQList\nT\n get(const \nQList\nU\n \nfileList, const \nQString\n \nkey)\n\n\nGather a list of \nT\n values associated with a metadata key from a provided list of files. \nT\n is a user provided type. If the key does not exist in the metadata of \nany\n file an error is thrown.\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate\nclass T, class U\n static QList\nT\n get(const QList\nU\n \nfileList, const QString \nkey)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfileList\n\n\nconst \nQList\nU\n \n\n\nA list of files to parse for values. A type is required for U. Valid options are: \n \nFile\n \nQString\n \n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nA metadata key used to lookup the values.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nT\n) A list of the values of type \nT\n associated with the given key. A type is required for \nT\n.\n\n\n\n\nexample:\nFile f1, f2;\nf1.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf1.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\nf2.set(\"Key1\", QVariant::fromValue\nfloat\n(3));\n\nFile::get\nfloat, File\n(QList\nFile\n() \n f1 \n f2, \"Key1\");  // returns [1., 3.]\nFile::get\nfloat, File\n(QList\nFile\n() \n f1 \n f2, \"Key2\");  // Error: Key doesn't exist in f2\nFile::get\nQRectF, File\n(QList\nFile\n() \n f1 \n f2, \"Key1\"); // Error: float is not convertable to QRectF\n\n\n\n\n\n\n\nQList\nT\n get(const \nQList\nU\n \nfileList, const \nQString\n \nkey, const T \ndefaultValue)\n\n\nGather a list of \nT\n values associated with a metadata key from a provided list of files. \nT\n is a user provided type. If the key does not exist in the metadata of \nany\n file the provided \ndefaultValue\n is used.\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate\nclass T, class U\n static QList\nT\n get(const QList\nU\n \nfileList, const QString \nkey, const T \ndefaultValue)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfileList\n\n\nconst \nQList\nU\n \n\n\nA list of files to parse for values. A type is required for U. Valid options are: \n \nFile\n \nQString\n \n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nA metadata key used to lookup the values.\n\n\n\n\n\n\ndefaultValue\n\n\nconst T \n\n\nThe default value if the key is not in a file's metadata. A type is required for T. All types are valid.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nT\n) A list of the values of type \nT\n associated with the given key. A type is required for \nT\n.\n\n\n\n\n\n\nexample:\n\n\nFile f1, f2;\nf1.set(\"Key1\", QVariant::fromValue\n(1));\nf1.set(\"Key2\", QVariant::fromValue\n(2));\nf2.set(\"Key1\", QVariant::fromValue\n(3));\n\n\nFile::get\n(QList\n() \n f1 \n f2, \"Key1\");                       // returns [1., 3.]\nFile::get\n(QList\n() \n f1 \n f2, \"Key2\", QList\n() \n 1);  // returns [1.]\nFile::get\n(QList\n() \n f1 \n f2, \"Key1, QList\n()\");     // returns []\n\n\n\n\n\n\nQDebug\n operator \n(\nQDebug\n dbg, const \nFile\n \nfile)\n\n\nCalls \nflat\n on the given file and then streams that file to stderr.\n\n\n\n\n\n\nfunction definition:\n\n\nQDebug operator \n(QDebug dbg, const File \nfile)\n\n\n\n\n\n\n\nparameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndbg\n\n\nQDebug\n\n\nThe debug stream\n\n\n\n\n\n\nfile\n\n\nconst \nFile\n \n\n\nFile to stream\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQDebug\n \n) returns a reference to the updated debug stream\n\n\n\n\nexample:\nFile file(\"../path/to/pictures/picture.jpg\");\nfile.set(\"Key\", QString(\"Value\"));\n\nqDebug() \n file; // \"../path/to/pictures/picture.jpg[Key=Value]\" streams to stderr\n\n\n\n\n\n\n\nQDataStream\n \noperator \n(\nQDataStream\n \nstream, const \nFile\n \nfile)\n\n\nSerialize a file to a data stream.\n\n\n\n\n\n\nfunction definition:\n\n\nQDataStream \noperator \n(QDataStream \nstream, const File \nfile)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n\n\nThe data stream\n\n\n\n\n\n\nfile\n\n\nconst \nFile\n \n\n\nFile to stream\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQDataStream\n \n) returns a reference to the updated data stream\n\n\n\n\nexample:\nvoid store(QDataStream \nstream)\n{\n    File file(\"../path/to/pictures/picture.jpg\");\n    file.set(\"Key\", QString(\"Value\"));\n\n    stream \n file; // \"../path/to/pictures/picture.jpg[Key=Value]\" serialized to the stream\n}\n\n\n\n\n\n\n\nQDataStream\n \noperator \n(\nQDataStream\n \nstream, const \nFile\n \nfile)\n\n\nDeserialize a file from a data stream.\n\n\n\n\n\n\nfunction definition:\n\n\nQDataStream \noperator \n(QDataStream \nstream, const File \nfile)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n\n\nThe data stream\n\n\n\n\n\n\nfile\n\n\nconst \nFile\n \n\n\nFile to stream\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQDataStream\n \n) returns a reference to the updated data stream\n\n\n\n\nexample:\nvoid load(QDataStream \nstream)\n{\n    File in(\"../path/to/pictures/picture.jpg\");\n    in.set(\"Key\", QString(\"Value\"));\n\n    stream \n in; // \"../path/to/pictures/picture.jpg[Key=Value]\" serialized to the stream\n\n    File out;\n    stream \n out;\n\n    out.name; // returns \"../path/to/pictures/picture.jpg\"\n    out.flat(); // returns \"../path/to/pictures/picture.jpg[Key=Value]\"\n}", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/file/statics/#parse", 
            "text": "Try to convert a given value to a  QPointF ,  QRectF , int or float.    function definition:  static QVariant parse(const QString  value);    parameters:     Parameter  Type  Description      value  const  QString    String value to be converted.       output:  ( QVariant ) The converted file if a conversion was possible. Otherwise the unconverted string is returned.   example: QString point = \"(1, 1)\";\nQString rect = \"(1, 1, 5, 5)\";\nQString integer = \"1\";\nQString fp = \"1.0\";\nQString string = \"Hello World\";\n\nFile::parse(point);   // returns QVariant(QPointF, QPointF(1, 1))\nFile::parse(rect);    // returns QVariant(QRectF, QRectF(1, 1, 5x5))\nFile::parse(integer); // returns QVariant(int, 1)\nFile::parse(fp);      // returns QVariant(float, 1.0f)\nFile::parse(string);  // returns QVariant(QString, \"Hello World\")", 
            "title": "QVariant parse(const QString value)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/statics/#values", 
            "text": "Gather a list of  QVariant  values associated with a metadata key from a provided list of files.    function definition:  template class U  static [QList QVariant  values(const QList U   fileList, const QString  key)    parameters:     Parameter  Type  Description      fileList  const  QList U    A list of files to parse for values. A type is required for  U . Valid options are:    File   QString      key  const  QString    A metadata key used to lookup the values.       output:  ( QList QVariant ) A list of  QVariant  values associated with the given key in each of the provided files.   example: File f1, f2;\nf1.set(\"Key1\", QVariant::fromValue float (1));\nf1.set(\"Key2\", QVariant::fromValue float (2));\nf2.set(\"Key1\", QVariant::fromValue float (3));\n\nFile::values File (QList File ()   f1   f2, \"Key1\"); // returns [QVariant(float, 1),\n                                                       //          QVariant(float, 3)]", 
            "title": "QListQVariant values(const QListU fileList, const QString key)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/statics/#get-1", 
            "text": "Gather a list of  T  values associated with a metadata key from a provided list of files.  T  is a user provided type. If the key does not exist in the metadata of  any  file an error is thrown.    function definition:  template class T, class U  static QList T  get(const QList U   fileList, const QString  key)    parameters:     Parameter  Type  Description      fileList  const  QList U    A list of files to parse for values. A type is required for U. Valid options are:    File   QString      key  const  QString    A metadata key used to lookup the values.       output:  ( QList T ) A list of the values of type  T  associated with the given key. A type is required for  T .   example: File f1, f2;\nf1.set(\"Key1\", QVariant::fromValue float (1));\nf1.set(\"Key2\", QVariant::fromValue float (2));\nf2.set(\"Key1\", QVariant::fromValue float (3));\n\nFile::get float, File (QList File ()   f1   f2, \"Key1\");  // returns [1., 3.]\nFile::get float, File (QList File ()   f1   f2, \"Key2\");  // Error: Key doesn't exist in f2\nFile::get QRectF, File (QList File ()   f1   f2, \"Key1\"); // Error: float is not convertable to QRectF", 
            "title": "QListT get(const QListU fileList, const QString key)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/statics/#get-2", 
            "text": "Gather a list of  T  values associated with a metadata key from a provided list of files.  T  is a user provided type. If the key does not exist in the metadata of  any  file the provided  defaultValue  is used.    function definition:  template class T, class U  static QList T  get(const QList U   fileList, const QString  key, const T  defaultValue)    parameters:     Parameter  Type  Description      fileList  const  QList U    A list of files to parse for values. A type is required for U. Valid options are:    File   QString      key  const  QString    A metadata key used to lookup the values.    defaultValue  const T   The default value if the key is not in a file's metadata. A type is required for T. All types are valid.       output:  ( QList T ) A list of the values of type  T  associated with the given key. A type is required for  T .    example:  File f1, f2;\nf1.set(\"Key1\", QVariant::fromValue (1));\nf1.set(\"Key2\", QVariant::fromValue (2));\nf2.set(\"Key1\", QVariant::fromValue (3));  File::get (QList ()   f1   f2, \"Key1\");                       // returns [1., 3.]\nFile::get (QList ()   f1   f2, \"Key2\", QList ()   1);  // returns [1.]\nFile::get (QList ()   f1   f2, \"Key1, QList ()\");     // returns []", 
            "title": "QListT get(const QListU fileList, const QString key, const T defaultValue)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/statics/#dbg-operator-ltlt", 
            "text": "Calls  flat  on the given file and then streams that file to stderr.    function definition:  QDebug operator  (QDebug dbg, const File  file)    parameter:     Parameter  Type  Description      dbg  QDebug  The debug stream    file  const  File    File to stream       output:  ( QDebug   ) returns a reference to the updated debug stream   example: File file(\"../path/to/pictures/picture.jpg\");\nfile.set(\"Key\", QString(\"Value\"));\n\nqDebug()   file; // \"../path/to/pictures/picture.jpg[Key=Value]\" streams to stderr", 
            "title": "QDebug operator (QDebug dbg, const File file)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/statics/#stream-operator-ltlt", 
            "text": "Serialize a file to a data stream.    function definition:  QDataStream  operator  (QDataStream  stream, const File  file)    parameters:     Parameter  Type  Description      stream  QDataStream  The data stream    file  const  File    File to stream       output:  ( QDataStream   ) returns a reference to the updated data stream   example: void store(QDataStream  stream)\n{\n    File file(\"../path/to/pictures/picture.jpg\");\n    file.set(\"Key\", QString(\"Value\"));\n\n    stream   file; // \"../path/to/pictures/picture.jpg[Key=Value]\" serialized to the stream\n}", 
            "title": "QDataStream operator (QDataStream stream, const File file)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/statics/#stream-operator-gtgt", 
            "text": "Deserialize a file from a data stream.    function definition:  QDataStream  operator  (QDataStream  stream, const File  file)    parameters:     Parameter  Type  Description      stream  QDataStream  The data stream    file  const  File    File to stream       output:  ( QDataStream   ) returns a reference to the updated data stream   example: void load(QDataStream  stream)\n{\n    File in(\"../path/to/pictures/picture.jpg\");\n    in.set(\"Key\", QString(\"Value\"));\n\n    stream   in; // \"../path/to/pictures/picture.jpg[Key=Value]\" serialized to the stream\n\n    File out;\n    stream   out;\n\n    out.name; // returns \"../path/to/pictures/picture.jpg\"\n    out.flat(); // returns \"../path/to/pictures/picture.jpg[Key=Value]\"\n}", 
            "title": "QDataStream operator (QDataStream stream, const File file)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/", 
            "text": "operator \nQString\n()\n\n\nConvenience function that allows \nFiles\n to be used as \nQStrings\n\n\n\n\n\n\nfunction definition:\n\n\ninline operator QString() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) returns \nname\n.\n\n\n\n\nQString\n flat()\n\n\nFunction to output files in string formats.\n\n\n\n\n\n\nfunction definition:\n\n\nQString flat() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) returns the \nfile name\n and \nmetadata\n as a formated string. The format is \nfilename\n[\nkey1=value1,key2=value2,...keyN=valueN\n].\n\n\nexample:\nFile file(\"picture.jpg\");\nfile.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nfile.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nfile.flat(); // returns \"picture.jpg[Key1=1,Key2=2]\"\n\n\n\n\n\n\n\nQString\n hash()\n\n\nFunction to output a hash of the file.\n\n\n\n\n\n\nfunction definition:\n\n\nQString hash() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns a hash of the file.\n\n\nexample:\nFile file(\"../path/to/pictures/picture.jpg\");\nfile.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nfile.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nfile.hash(); // returns \"kElVwY\"\n\n\n\n\n\n\n\nQStringList\n localKeys()\n\n\nFunction to get the private \nmetadata\n keys.\n\n\n\n\n\n\nfunction definition:\n\n\ninline QStringList localKeys() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQStringList\n) Returns a list of the local \nmetadata\n keys. They are called local because they do not include the keys in the \nglobal metadata\n.\n\n\n\n\nexample:\n\n\nFile file(\"../path/to/pictures/picture.jpg\");\nfile.set(\"Key1\", QVariant::fromValue\n(1));\nfile.set(\"Key2\", QVariant::fromValue\n(2));\n\n\nfile.localKeys(); // returns [Key1, Key2]\n\n\n\n\n\n\nQVariantMap\n localMetadata()\n\n\nFunction to get the private \nmetadata\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline QVariantMap localMetadata() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQVariantMap\n) Returns the local \nmetadata\n.\n\n\nexample:\nFile file(\"../path/to/pictures/picture.jpg\");\nfile.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nfile.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nfile.localMetadata(); // return QMap((\"Key1\", QVariant(float, 1)) (\"Key2\", QVariant(float, 2)))\n\n\n\n\n\n\n\nvoid append(const \nQVariantMap\n \nlocalMetadata)\n\n\nAdd new metadata fields to \nmetadata\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid append(const QVariantMap \nlocalMetadata)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlocalMetadata\n\n\nconst \nQVariantMap\n \n\n\nmetadata to append to the local \nmetadata\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile f();\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\n\nQVariantMap map;\nmap.insert(\"Key2\", QVariant::fromValue\nfloat\n(2));\nmap.insert(\"Key3\", QVariant::fromValue\nfloat\n(3));\n\nf.append(map);\nf.flat(); // returns \"[Key1=1, Key2=2, Key3=3]\"\n\n\n\n\n\n\n\nvoid append(const \nFile\n \nother)\n\n\nAppend another file using the \n;\n separator. The \nFile\n \nnames\n are combined with the separator in between them. The \nmetadata\n fields are combined. An additional field describing the separator is appended to the \nmetadata\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid append(const File \nother)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst \nFile\n \n\n\nFile to append\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile f1(\"../path/to/pictures/picture1.jpg\");\nf1.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\n\nFile f2(\"../path/to/pictures/picture2.jpg\");\nf2.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\nf2.set(\"Key3\", QVariant::fromValue\nfloat\n(3));\n\nf1.append(f2);\nf1.name; // return \"../path/to/pictures/picture1.jpg;../path/to/pictures/picture2.jpg\"\nf1.localKeys(); // returns \"[Key1, Key2, Key3, separator]\"\n\n\n\n\n\n\n\nFile\n \noperator+=(const \nQMap\nQString\n, \nQVariant\n \nother)\n\n\nShortcut operator to call \nappend\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline File \noperator+=(const QMap\nQString, QVariant\n \nother)\n\n\n\n\n\n\n\nparameters:\n\n\nParameter | Type | Description\nother | const \nQMap\nQString\n, \nQVariant\n \n | Metadata map to append to the local \nmetadata\n\n\n\n\n\n\noutput:\n (\nFile\n \n) Returns a reference to this file after the append occurs.\n\n\n\n\nexample:\nFile f();\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\n\nQMap\nQString, QVariant\n map;\nmap.insert(\"Key2\", QVariant::fromValue\nfloat\n(2));\nmap.insert(\"Key3\", QVariant::fromValue\nfloat\n(3));\n\nf += map;\nf.flat(); // returns \"[Key1=1, Key2=2, Key3=3]\"\n\n\n\n\n\n\n\nFile\n \noperator+=(const \nFile\n \nother)\n\n\nShortcut operator to call \nappend\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline File \noperator+=(const File \nother)\n\n\n\n\n\n\n\nparameters:\n\n\nParameter | Type | Description\nother | const \nFile\n \n | File to append\n\n\n\n\n\n\noutput:\n (\nFile\n \n) Returns a reference to this file after the append occurs.\n\n\n\n\nexample:\nFile f1(\"../path/to/pictures/picture1.jpg\");\nf1.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\n\nFile f2(\"../path/to/pictures/picture2.jpg\");\nf2.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\nf2.set(\"Key3\", QVariant::fromValue\nfloat\n(3));\n\nf1 += f2;\nf1.name; // return \"../path/to/pictures/picture1.jpg;../path/to/pictures/picture2.jpg\"\nf1.localKeys(); // returns \"[Key1, Key2, Key3, separator]\"\n\n\n\n\n\n\n\nQList\nFile\n split()\n\n\nThis function splits the \nFile\n into multiple files and returns them as a list. This is done by parsing the file \nname\n and splitting on the separator located at \nmetadata\n[\"separator\"]. If \"separator\" is not a \nmetadata\n key, the returned list has the original file as the only entry. Each new file has the same \nmetadata\n as the original, pre-split, file.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nFile\n split() const\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\noutput:\n (\nQList\nFile\n) List of split files\n\n\nexample:\nFile f1(\"../path/to/pictures/picture1.jpg\");\nf1.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\n\nf1.split(); // returns [../path/to/pictures/picture1.jpg[Key1=1]]\n\nFile f2(\"../path/to/pictures/picture2.jpg\");\nf2.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\nf2.set(\"Key3\", QVariant::fromValue\nfloat\n(3));\n\nf1.append(f2);\nf1.split(); // returns [../path/to/pictures/picture1.jpg[Key1=1, Key2=2, Key3=3, separator=;],\n            //          ../path/to/pictures/picture2.jpg[Key1=1, Key2=2, Key3=3, separator=;]]\n\n\n\n\n\n\n\nQList\nFile\n split(const \nQString\n \nseparator)\n\n\nThis function splits the file into multiple files and returns them as a list. This is done by parsing the file \nname\n and splitting on the given separator. Each new file has the same \nmetadata\n as the original, pre-split, file.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nFile\n split(const QString \nseparator) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nseparator\n\n\nconst \nQString\n \n\n\nSeparator to split the file name on\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nFile\n) List of split files\n\n\n\n\nexample:\nFile f(\"../path/to/pictures/picture1.jpg,../path/to/pictures/picture2.jpg\");\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nf.split(\",\"); // returns [../path/to/pictures/picture1.jpg[Key1=1, Key2=2],\n                          ../path/to/pictures/picture2.jpg[Key1=1, Key2=2]]\n\n\n\n\n\n\n\nvoid setParameter(int index, const \nQVariant\n \nvalue)\n\n\nInsert a keyless value into the \nmetadata\n. Generic key of \"ArgN\" is used, where N is given as a parameter.\n\n\n\n\n\n\nfunction definition:\n\n\ninline void setParameter(int index, const QVariant \nvalue)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindex\n\n\nint\n\n\nNumber to append to generic key\n\n\n\n\n\n\nvalue\n\n\nconst \nQVariant\n \n\n\nValue to add to the metadata\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \ncontainsParameter\n, \ngetParameter\n\n\nexample:\nFile f;\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nf.setParameter(1, QVariant::fromValue\nfloat\n(3));\nf.setParameter(5, QVariant::fromValue\nfloat\n(4));\n\nf.flat(); // returns \"[Key1=1, Key2=2, Arg1=3, Arg5=4]\"\n\n\n\n\n\n\n\nbool containsParameter(int index)\n\n\nCheck if the local \nmetadata\n contains a keyless value.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool containsParameter(int index) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindex\n\n\nint\n\n\nIndex of the keyless value to check for\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the local \nmetadata\n contains the keyless value, otherwise reutrns false.\n\n\n\n\nsee:\n \nsetParameter\n, \ngetParameter\n\n\nexample:\nFile f;\nf.setParameter(1, QVariant::fromValue\nfloat\n(1));\nf.setParameter(2, QVariant::fromValue\nfloat\n(2));\n\nf.containsParameter(1); // returns true\nf.containsParameter(2); // returns true\nf.containsParameter(3); // returns false\n\n\n\n\n\n\n\nQVariant\n getParameter(int index)\n\n\nGet a keyless value from the local \nmetadata\n. If the value does not exist an error is thrown.\n\n\n\n\n\n\nfunction definition:\n\n\ninline QVariant getParameter(int index) const\n\n\n\n\n\n\n\nparameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindex\n\n\nint\n\n\nIndex of the keyless value to look up. If the index does not exist an error is thrown.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQVariant\n) Returns the keyless value associated with the given index\n\n\n\n\nsee:\n \nsetParameter\n, \ncontainsParameter\n\n\nexample:\nFile f;\nf.setParameter(1, QVariant::fromValue\nfloat\n(1));\nf.setParameter(2, QVariant::fromValue\nfloat\n(2));\n\nf.getParameter(1); // returns 1\nf.getParameter(2); // returns 2\nf.getParameter(3); // error: index does not exist\n\n\n\n\n\n\n\nbool operator==(const char *other)\n\n\nCompare \nname\n against a c-style string.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool operator==(const char *other) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst char *\n\n\nC-style string to compare against\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the strings are equal, false otherwise.\n\n\n\n\nexample:\nFile f(\"picture.jpg\");\n\nf == \"picture.jpg\";       // returns true\nf == \"other_picture.jpg\"; // returns false\n\n\n\n\n\n\n\nbool operator==(const \nFile\n \nother)\n\n\nCompare \nname\n and \nmetadata\n against another file name and metadata.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool operator==(const File \nother) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst \nFile\n \n\n\nFile to compare against\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the names and metadata are equal, false otherwise.\n\n\n\n\nexample:\nFile f1(\"picture1.jpg\");\nFile f2(\"picture1.jpg\");\n\nf1 == f2; // returns true\n\nf1.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf2.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nf1 == f2; // returns false (metadata doesn't match)\n\n\n\n\n\n\n\nbool operator!=(const \nFile\n \nother)\n\n\nCompare \nname\n and \nmetadata\n against another file name and metadata.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool operator!=(const File \nother) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst \nFile\n \n\n\nFile to compare against\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the names and metadata are not equal, false otherwise.\n\n\n\n\nexample:\nFile f1(\"picture1.jpg\");\nFile f2(\"picture1.jpg\");\n\nf1 != f2; // returns false\n\nf1.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf2.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nf1 != f2; // returns true (metadata doesn't match)\n\n\n\n\n\n\n\nbool operator\n(const \nFile\n \nother)\n\n\nCompare \nname\n against another file name.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool operator\n(const File \nother) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst \nFile\n \n\n\nFile to compare against\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if \nname\n \n others.name\n\n\n\n\n\n\nbool operator\n=(const \nFile\n \nother)\n\n\nCompare \nname\n against another file name.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool operator\n=(const File \nother) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst \nFile\n \n\n\nFile to compare against\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if \nname\n \n= others.name\n\n\n\n\n\n\nbool operator\n(const \nFile\n \nother)\n\n\nCompare \nname\n against another file name.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool operator\n(const File \nother) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst \nFile\n \n\n\nFile to compare against\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if \nname\n \n others.name\n\n\n\n\n\n\nbool operator\n=(const \nFile\n \nother)\n\n\nCompare \nname\n against another file name.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool operator\n=(const File \nother) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst \nFile\n \n\n\nFile to compare against\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if \nname\n \n= others.name\n\n\n\n\n\n\nbool isNull()\n\n\nCheck if the file is null.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool isNull() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns true if \nname\n and \nmetadata\n are empty, false otherwise.\n\n\nexample:\nFile f;\nf.isNull(); // returns true\n\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf.isNull(); // returns false\n\n\n\n\n\n\n\nbool isTerminal()\n\n\nChecks if the value of \nname\n == \"terminal\".\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool isTerminal() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns true if \nname\n == \"terminal\", false otherwise.\n\n\nexample:\nFile f1(\"terminal\"), f2(\"not_terminal\");\n\nf1.isTerminal(); // returns true\nf2.isTerminal(); // returns false\n\n\n\n\n\n\n\nbool exists()\n\n\nCheck if the file exists on disk.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool exists() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n Returns true if \nname\n exists on disk, false otherwise.\n\n\n\n\nexample:\n\n\nFile f1(\"/path/to/file/that/exists\"), f2(\"/path/to/non/existant/file\");\n\n\nf1.exists(); // returns true\nf2.exists(); // returns false\n\n\n\n\n\n\nQString\n fileName()\n\n\nGet the file's base name and extension.\n\n\n\n\n\n\nfunction definition:\n\n\ninline QString fileName() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns the base name + extension of \nname\n\n\nexample:\nFile file(\"../path/to/pictures/picture.jpg\");\nfile.fileName(); // returns \"picture.jpg\"\n\n\n\n\n\n\n\nQString\n baseName()\n\n\nGet the file's base name.\n\n\n\n\n\n\nfunction definition:\n\n\ninline QString baseName() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns the base name of \nname\n\n\nexample:\nFile file(\"../path/to/pictures/picture.jpg\");\nfile.baseName(); // returns \"picture\"\n\n\n\n\n\n\n\nQString\n suffix()\n\n\nGet the file's extension.\n\n\n\n\n\n\nfunction definition:\n\n\ninline QString suffix() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns the extension of \nname\n\n\nexample:\nFile file(\"../path/to/pictures/picture.jpg\");\nfile.suffix(); // returns \"jpg\"\n\n\n\n\n\n\n\nQString\n path()\n\n\nGet the path of the file without the name.\n\n\n\n\n\n\nfunction definition:\n\n\ninline QString path() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns the path of \nname\n.\n\n\nexample:\nFile file(\"../path/to/pictures/picture.jpg\");\nfile.suffix(); // returns \"../path/to/pictures\"\n\n\n\n\n\n\n\nQString\n resolved()\n\n\nGet the full path for the file. This is done in three steps:\n\n\n\n\nIf \nname\n exists, return \nname\n.\n\n\nPrepend each path stored in \nGlobals-\npath\n to \nname\n. If the combined name exists then it is returned.\n\n\nPrepend each path stored in \nGlobals-\npath\n to \nfileName\n. If the combined name exists then it is returned.\n\n\n\n\nIf none of the attempted names exist, \nname\n is returned unmodified.\n\n\n\n\n\n\nfunction definition:\n\n\nQString resolved() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns the resolved string if it can be created. Otherwise it returns \nname\n\n\n\n\nbool contains(const \nQString\n \nkey)\n\n\nCheck if a given key is in the local \nmetadata\n.\n\n\n\n\n\n\nfunction definition:\n\n\nbool contains(const QString \nkey) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to check the \nmetadata\n for\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the given key is in the \nmetadata\n, false otherwise.\n\n\n\n\nexample:\nFile file;\nfile.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\n\nfile.contains(\"Key1\"); // returns true\nfile.contains(\"Key2\"); // returns false\n\n\n\n\n\n\n\nbool contains(const \nQStringList\n \nkeys)\n\n\nCheck if a list of keys is in the local \nmetadata\n.\n\n\n\n\n\n\nfunction definition:\n\n\nbool contains(const QStringList \nkeys) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeys\n\n\nconst \nQStringList\n \n\n\nKeys to check the \nmetadata\n for\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if \nall\n of the given keys are in the \nmetadata\n, false otherwise.\n\n\n\n\nexample:\nFile file;\nfile.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nfile.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nfile.contains(QStringList(\"Key1\")); // returns true\nfile.contains(QStringList() \n \"Key1\" \n \"Key2\") // returns true\nfile.contains(QStringList() \n \"Key1\" \n \"Key3\"); // returns false\n\n\n\n\n\n\n\nQVariant\n value(const \nQString\n \nkey)\n\n\nGet the value associated with a given key from the \nmetadata\n. If the key is not found in the \nlocal metadata\n, the \nglobal metadata\n is searched. In a special case, the key can be \"name\". This returns the file's \nname\n.\n\n\n\n\n\n\nfunction description:\n\n\nQVariant value(const QString \nkey) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to look up the value in the \nlocal metadata\n or \nglobal metadata\n. The key can also be \"name\".\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQVariant\n) Returns the key associated with the value from either the \nlocal\n or \nglobal\n metadata. If the key is \"name\", \nname\n is returned.\n\n\n\n\nexample:\nFile file;\nfile.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nfile.value(\"Key1\"); // returns QVariant(float, 1)\n\n\n\n\n\n\n\nvoid set(const \nQString\n \nkey, const \nQVariant\n \nvalue)\n\n\nInsert a value into the \nmetadata\n using a provided key. If the key already exists the new value will override the old one.\n\n\n\n\n\n\nfunction description:\n\n\ninline void set(const QString \nkey, const QVariant \nvalue)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameters\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to store the given value in the \nmetadata\n\n\n\n\n\n\nvalue\n\n\nconst \nQVariant\n \n\n\nValue to be stored\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile f;\nf.flat(); // returns \"\"\n\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf.flat(); // returns \"[Key1=1]\"\n\n\n\n\n\n\n\nvoid set(const \nQString\n \nkey, const \nQString\n \nvalue)\n\n\nInsert a value into the \nmetadata\n using a provided key. If the key already exists the new value will override the old one.\n\n\n\n\n\n\nfunction description:\n\n\nvoid set(const QString \nkey, const QString \nvalue)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameters\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to store the given value in the \nmetadata\n\n\n\n\n\n\nvalue\n\n\nconst \nQString\n \n\n\nValue to be stored\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile f;\nf.flat(); // returns \"\"\n\nf.set(\"Key1\", QString(\"1\"));\nf.flat(); // returns \"[Key1=1]\"\n\n\n\n\n\n\n\nvoid setList(const \nQString\n \nkey, const \nQList\nT\n \nvalue)\n\n\nInsert a list into the \nmetadata\n using a provided key. If the key already exists the new value will override the old one. The value should be queried with \ngetList\n instead of \nget\n.\n\n\n\n\n\n\nfunction description:\n\n\ntemplate \ntypename T\n void setList(const QString \nkey, const QList\nT\n \nvalue)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to store the given value in the \nmetadata\n\n\n\n\n\n\nvalue\n\n\nconst \nQList\nT\n\n\nList to be stored\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \ngetList\n, \nget\n\n\nexample:\nFile file;\n\nQList\nfloat\n list = QList\nfloat\n() \n 1 \n 2 \n 3;\nfile.setList\nfloat\n(\"List\", list);\nfile.getList\nfloat\n(\"List\"); // return [1., 2. 3.]\n\n\n\n\n\n\n\nvoid remove(const \nQString\n \nkey)\n\n\nRemove a key-value pair from the \nmetadata\n\n\n\n\n\n\nfunction description:\n\n\ninline void remove(const QString \nkey)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to be removed from \nmetadata\n along with its associated value.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile f;\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\nf.set(\"Key2\", QVariant::fromValue\nfloat\n(2));\n\nf.flat(); // returns \"[Key1=1, Key2=2]\"\n\nf.remove(\"Key1\");\nf.flat(); // returns \"[Key2=2]\"\n\n\n\n\n\n\n\nT get(const \nQString\n \nkey)\n\n\nGet a value from the \nmetadata\n using a provided key. If the key does not exist or the value cannot be converted to a user specified type an error is thrown.\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate \ntypename T\n T get(const QString \nkey) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to retrieve a value from \nmetadata\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nT\n) Returns a value of type \nT\n. \nT\n is a user specified type. The value associated with the given key must be convertable to \nT\n.\n\n\n\n\nsee:\n \nget\n, \ngetList\n\n\nexample:\nFile f;\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\n\nf.get\nfloat\n(\"Key1\");  // returns 1\nf.get\nfloat\n(\"Key2\");  // Error: Key2 is not in the metadata\nf.get\nQRectF\n(\"Key1\"); // Error: A float can't be converted to a QRectF\n\n\n\n\n\n\n\nT get(const \nQString\n \nkey, const T \ndefaultValue)\n\n\nGet a value from the \nmetadata\n using a provided key. If the key does not exist or the value cannot be converted to user specified type a provided default value is returned instead.\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate \ntypename T\n T get(const QString \nkey, const T \ndefaultValue)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to retrieve a value from the \nmetadata\n\n\n\n\n\n\ndefaultValue\n\n\nconst T \n\n\nDefault value to be returned if the key does not exist or found value cannot be converted to \nT\n. \nT\n is a user specified type.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nT\n) Returns a value of type \nT\n. \nT\n is a user specified type. If the value associated with the key is invalid, the provided default value is returned instead.\n\n\n\n\nsee:\n \nget\n, \ngetList\n\n\nexample:\nFile f;\nf.set(\"Key1\", QVariant::fromValue\nfloat\n(1));\n\nf.get\nfloat\n(\"Key1\", 5);  // returns 1\nf.get\nfloat\n(\"Key2\", 5);  // returns 5\nf.get\nQRectF\n(\"Key1\", QRectF(0, 0, 10, 10)); // returns QRectF(0, 0, 10x10)\n\n\n\n\n\n\n\nbool getBool(const \nQString\n \nkey, bool defaultValue = false)\n\n\nGet a boolean value from the \nmetadata\n using a provided key. If the key is not in the \nmetadata\n a provided default value is returned. If the key is in the metadata but the value cannot be converted to a bool true is returned. If the key is found and the value can be converted to a bool the value is returned.\n\n\n\n\n\n\nfunction definition:\n\n\nbool getBool(const QString \nkey, bool defaultValue = false) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to retrieve a value from the \nmetadata\n\n\n\n\n\n\ndefaultValue\n\n\nbool\n\n\n(Optional) Default value to be returned if the key is not in the \nmetadata\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) If the key \nis not\n in the \nmetadata\n the provided default value is returned. If the key \nis\n in the \nmetadata\n but the associated value \ncannot\n be converted to a bool true is returned. If the key \nis\n in the \nmetadata\n and the associated value \ncan\n be converted to a bool, that value is returned.\n\n\n\n\nsee:\n \nget\n\n\nexample:\nFile f;\nf.set(\"Key1\", QVariant::fromValue\nbool\n(true));\nf.set(\"Key2\", QVariant::fromValue\nfloat\n(10));\n\nf.getBool(\"Key1\");       // returns true\nf.getBool(\"Key2\")        // returns true (key found)\nf.getBool(\"Key3\");       // returns false (default value)\nf.getBool(\"Key3\", true); // returns true (default value)\n\n\n\n\n\n\n\nQList\nT\n getList(const \nQString\n \nkey)\n\n\nGet a list from the \nmetadata\n using a provided key. If the key does not exist or the elements of the list cannot be converted to a user specified type an error is thrown.\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate \ntypename T\n QList\nT\n getList(const QString \nkey) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to retrieve a value from the \nmetadata\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nT\n) Returns a list of values of a user specified type.\n\n\n\n\nsee:\n \nsetList\n, \nget\n\n\nexample:\nFile file;\n\nQList\nfloat\n list = QList\nfloat\n() \n 1 \n 2 \n 3;\nfile.setList\nfloat\n(\"List\", list);\n\nfile.getList\nfloat\n(\"List\");  // return [1., 2. 3.]\nfile.getList\nQRectF\n(\"List\"); // Error: float cannot be converted to QRectF\nfile.getList\nfloat\n(\"Key\");   // Error: key doesn't exist\n\n\n\n\n\n\n\nQList\nT\n getList(const \nQString\n \nkey, const \nQList\nT\n defaultValue)\n\n\nGet a list from the \nmetadata\n using a provided key. If the key does not exist or the elements of the list cannot be converted to a user specified type a provided default value is returned.\n\n\n\n\nfunction definition:\n\n\n\n\ntemplate \n QList\n getList(const QString \nkey, const QList\n defaultValue) const\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to retrieve a value from the \nmetadata\n\n\n\n\n\n\ndefaultValue\n\n\nQList\nT\n\n\n(Optional) Default value to be returned if the key is not in the \nmetadata\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nT\n) Returns a list of values of user specified type. If key is not in the \nmetadata\n or if the value cannot be converted to a \nQList\nT\n the default value is returned.\n\n\n\n\nsee:\n \ngetList\n\n\nexample:\nFile file;\n\nQList\nfloat\n list = QList\nfloat\n() \n 1 \n 2 \n 3;\nfile.setList\nfloat\n(\"List\", list);\n\nfile.getList\nfloat\n(\"List\", QList\nfloat\n());                  // return [1., 2. 3.]\nfile.getList\nQRectF\n(\"List\", QList\nQRectF\n());                // return []\nfile.getList\nfloat\n(\"Key\", QList\nfloat\n() \n 1 \n 2 \n 3);    // return [1., 2., 3.]\n\n\n\n\n\n\n\nQList\nQPointF\n namedPoints()\n\n\nFind values in the \nmetadata\n that can be converted into \nQPointF\n's. Values stored as \nQList\nQPointF\n \nwill not\n* be returned.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nQPointF\n namedPoints() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQList\nQPointF\n) Returns a list of points that can be converted from \nmetadata\n values.\n\n\nexample:\nFile file;\nfile.set(\"Key1\", QVariant::fromValue\nQPointF\n(QPointF(1, 1)));\nfile.set(\"Key2\", QVariant::fromValue\nQPointF\n(QPointF(2, 2)));\nfile.set(\"Points\", QVariant::fromValue\nQPointF\n(QPointF(3, 3)))\n\nf.namedPoints(); // returns [QPointF(1, 1), QPointF(2, 2), QPointF(3, 3)]\n\nfile.setPoints(QList\nQPointF\n() \n QPointF(3, 3)); // changes metadata[\"Points\"] to QList\nQPointF\n\nf.namedPoints(); // returns [QPointF(1, 1), QPointF(2, 2)]\n\n\n\n\n\n\n\nQList\nQPointF\n points()\n\n\nGet values stored in the \nmetadata\n with key \"Points\". It is expected that this field holds a \nQList\nQPointf\n.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nQPointF\n points() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQList\nQPointf\n) Returns a list of points stored at \nmetadata\n[\"Points\"]\n\n\nsee:\n \nappendPoint\n, \nappendPoints\n, \nclearPoints\n, \nsetPoints\n\n\nexample:\nFile file;\nfile.set(\"Points\", QVariant::fromValue\nQPointF\n(QPointF(1, 1)));\nfile.points(); // returns [] (point is not in a list)\n\nfile.setPoints(QList\nQPointF\n() \n QPointF(2, 2));\nfile.points(); // returns [QPointF(2, 2)]\n\n\n\n\n\n\n\nvoid appendPoint(const \nQPointF\n \npoint)\n\n\nAppend a point to the \nQList\nQPointF\n stored at \nmetadata\n[\"Points\"].\n\n\n\n\n\n\nfunction definition:\n\n\nvoid appendPoint(const QPointF \npoint)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npoint\n\n\nconst \nQPoint\n \n\n\nPoint to be appended\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.points(); // returns []\n\nfile.appendPoint(QPointF(1, 1));\nfile.points(); // returns [QPointF(1, 1)]\n\n\n\n\n\n\n\nvoid appendPoints(const \nQList\nQPointF\n \npoints)\n\n\nAppend a list of points to the \nQList\nQPointF\n stored at \nmetadata\n[\"Points\"].\n\n\n\n\n\n\nfunction definition:\n\n\nvoid appendPoints(const QList\nQPointF\n \npoints)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npoints\n\n\nconst \nQList\nQPointF\n \n\n\nList of points to be appended\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.points(); // returns []\n\nfile.appendPoints(QList\nQPointF\n() \n QPointF(1, 1) \n QPointF(2, 2));\nfile.points(); // returns [QPointF(1, 1), QPointF(2, 2)]\n\n\n\n\n\n\n\nvoid clearPoints()\n\n\nRemove all points stored at \nmetadata\n[\"Points\"].\n\n\n\n\n\n\nfunction definition:\n\n\ninline void clearPoints()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)\n\n\nexample:\nFile file;\nfile.appendPoints(QList\nQPointF\n() \n QPointF(1, 1) \n QPointF(2, 2));\nfile.points(); // returns [QPointF(1, 1), QPointF(2, 2)]\n\nfile.clearPoints();\nfile.points(); // returns []\n\n\n\n\n\n\n\nvoid setPoints(const \nQList\nQPointF\n \npoints)\n\n\nReplace the points stored at \nmetadata\n[\"Points\"]\n\n\n\n\n\n\nfunction definition:\n\n\ninline void setPoints(const QList\nQPointF\n \npoints)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npoints\n\n\nconst \nQList\nQPointF\n \n\n\nPoints to overwrite \nmetadata\n with\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.appendPoints(QList\nQPointF\n() \n QPointF(1, 1) \n QPointF(2, 2));\nfile.points(); // returns [QPointF(1, 1), QPointF(2, 2)]\n\nfile.setPoints(QList\nQPointF\n() \n QPointF(3, 3) \n QPointF(4, 4));\nfile.points(); // returns [QPointF(3, 3), QPointF(4, 4)]\n\n\n\n\n\n\n\nQList\nQRectF\n namedRects()\n\n\nFind values in the \nmetadata\n that can be converted into \nQRectF\n's. Values stored as \nQList\nQRectF\n \nwill not\n* be returned.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nQRectF\n namedRects() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQList\nQRectF\n) Returns a list of rects that can be converted from \nmetadata\n values.\n\n\nexample:\nFile file;\nfile.set(\"Key1\", QVariant::fromValue\nQRectF\n(QRectF(1, 1, 5, 5)));\nfile.set(\"Key2\", QVariant::fromValue\nQRectF\n(QRectF(2, 2, 5, 5)));\nfile.set(\"Rects\", QVariant::fromValue\nQRectF\n(QRectF(3, 3, 5, 5)));\n\nf.namedRects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5), QRectF(3, 3, 5x5)]\n\nfile.setRects(QList\nQRectF\n() \n QRectF(3, 3, 5x5)); // changes metadata[\"Rects\"] to QList\nQRectF\n\nf.namedRects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\n\n\n\n\n\n\nQList\nQRectF\n rects()\n\n\nGet values stored at \nmetadata\n[\"Rects\"]. It is expected that this field holds a \nQList\nQRectf\n.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nQRectF\n points() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQList\nQRectf\n) Returns a list of rects stored at \nmetadata\n[\"Rects\"]\n\n\nsee:\n \nappendRect\n, \nappendRects\n, \nclearRects\n, \nsetRects\n\n\nexample:\nFile file;\nfile.set(\"Rects\", QVariant::fromValue\nQRectF\n(QRectF(1, 1, 5, 5)));\nfile.rects(); // returns [] (rect is not in a list)\n\nfile.setRects(QList\nQRectF\n() \n QRectF(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(2, 2, 5x5)]\n\n\n\n\n\n\n\nvoid appendRect(const \nQRectF\n \nrect)\n\n\nAppend a rect to the \nQList\nQRectF\n stored at \nmetadata\n[\"Rects\"].\n\n\n\n\n\n\nfunction definition:\n\n\nvoid appendRect(const QRectF \nrect)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrect\n\n\nconst [QRect][QRect] \n\n\nRect to be appended\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.rects(); // returns []\n\nfile.appendRect(QRectF(1, 1, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5)]\n\n\n\n\n\n\n\nvoid appendRect(const \nRect\n \nrect)\n\n\nAppend an OpenCV-style \nRect\n to the \nQList\nQRectF\n stored at \nmetadata\n[\"Rects\"]. Supplied OpenCV-style rects are converted to \nQRectF\n before being appended.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid appendRect(const Rect \nrect)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrect\n\n\nconst \nRect\n \n\n\nOpenCV-style rect to be appended\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.rects(); // returns []\n\nfile.appendRect(cv::Rect(1, 1, 5, 5)); // automatically converted to QRectF\nfile.rects(); // returns [QRectF(1, 1, 5x5)]\n\n\n\n\n\n\n\nvoid appendRects(const \nQList\nQRectF\n \nrects)\n\n\nAppend a list of rects to the \nQList\nQRectF\n stored at \nmetadata\n[\"Rects\"].\n\n\n\n\n\n\nfunction definition:\n\n\nvoid appendRects(const QList\nQRectF\n \nrects)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrects\n\n\nconst \nQList\nQRectF\n \n\n\nList of rects to be appended\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.rects(); // returns []\n\nfile.appendRects(QList\nQRectF\n() \n QRectF(1, 1, 5, 5) \n QRectF(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\n\n\n\n\n\n\nvoid appendRects(const \nQList\nQRectF\n \nrects)\n\n\nAppend a list of OpenCV-style \nRects\n to the \nQList\nQRectF\n stored at \nmetadata\n[\"Rects\"]. Supplied OpenCV-style rects are converted to \nQRectF\n before being appended.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid appendRects(const QList\nQRectF\n \nrects)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrects\n\n\nconst \nQList\nRect\n \n\n\nList of OpenCV-style rects to be appended\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.rects(); // returns []\n\nfile.appendRects(QList\nRect\n() \n Rect(1, 1, 5, 5) \n Rect(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\n\n\n\n\n\n\nvoid clearRects()\n\n\nRemove all points stored at \nmetadata\n[\"Rects\"].\n\n\n\n\n\n\nfunction definition:\n\n\ninline void clearRects()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)\n\n\nexample:\nFile file;\nfile.appendRects(QList\nQRectF\n() \n QRectF(1, 1, 5, 5) \n QRectF(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\nfile.clearRects();\nfile.rects(); // returns []\n\n\n\n\n\n\n\nvoid setRects(const \nQList\nQRectF\n \nrects)\n\n\nReplace the rects stored at \nmetadata\n with a provided list of rects.\n\n\n\n\n\n\nfunction definition:\n\n\ninline void setRects(const QList\nQRectF\n \nrects)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrects\n\n\nconst \nQList\nQRectF\n \n\n\nRects to overwrite \nmetadata\n[\"Rects\"] with\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.appendRects(QList\nQRectF\n() \n QRectF(1, 1, 5, 5) \n QRectF(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\nfile.setRects(QList\nQRectF\n() \n QRectF(3, 3, 5, 5) \n QRectF(4, 4, 5, 5));\nfile.rects(); // returns [QRectF(3, 3, 5x5), QRectF(4, 4, 5x5)]\n\n\n\n\n\n\n\nvoid setRects(const \nQList\nRect\n \nrects)\n\n\nReplace the rects stored at \nmetadata\n with a provided list of OpenCV-style \nRects\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline void setRects(const QList\nRect\n \nrects)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrects\n\n\nconst \nQList\nRect\n \n\n\nOpenCV-style rects to overwrite \nmetadata\n[\"Rects\"] with\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile file;\nfile.appendRects(QList\ncv::Rect\n() \n cv::Rect(1, 1, 5, 5) \n cv::Rect(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\nfile.setRects(QList\ncv::Rect\n() \n cv::Rect(3, 3, 5, 5) \n cv::Rect(4, 4, 5, 5));\nfile.rects(); // returns [QRectF(3, 3, 5x5), QRectF(4, 4, 5x5)]", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-qstring", 
            "text": "Convenience function that allows  Files  to be used as  QStrings    function definition:  inline operator QString() const    parameters:  NONE   output:  ( QString ) returns  name .", 
            "title": "operator QString()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#flat", 
            "text": "Function to output files in string formats.    function definition:  QString flat() const    parameters:  NONE   output:  ( QString ) returns the  file name  and  metadata  as a formated string. The format is  filename [ key1=value1,key2=value2,...keyN=valueN ].  example: File file(\"picture.jpg\");\nfile.set(\"Key1\", QVariant::fromValue float (1));\nfile.set(\"Key2\", QVariant::fromValue float (2));\n\nfile.flat(); // returns \"picture.jpg[Key1=1,Key2=2]\"", 
            "title": "QString flat()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#hash", 
            "text": "Function to output a hash of the file.    function definition:  QString hash() const    parameters:  NONE   output:  ( QString ) Returns a hash of the file.  example: File file(\"../path/to/pictures/picture.jpg\");\nfile.set(\"Key1\", QVariant::fromValue float (1));\nfile.set(\"Key2\", QVariant::fromValue float (2));\n\nfile.hash(); // returns \"kElVwY\"", 
            "title": "QString hash()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#localkeys", 
            "text": "Function to get the private  metadata  keys.    function definition:  inline QStringList localKeys() const    parameters:  NONE   output:  ( QStringList ) Returns a list of the local  metadata  keys. They are called local because they do not include the keys in the  global metadata .   example:  File file(\"../path/to/pictures/picture.jpg\");\nfile.set(\"Key1\", QVariant::fromValue (1));\nfile.set(\"Key2\", QVariant::fromValue (2));  file.localKeys(); // returns [Key1, Key2]", 
            "title": "QStringList localKeys()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#localmetadata", 
            "text": "Function to get the private  metadata .    function definition:  inline QVariantMap localMetadata() const    parameters:  NONE   output:  ( QVariantMap ) Returns the local  metadata .  example: File file(\"../path/to/pictures/picture.jpg\");\nfile.set(\"Key1\", QVariant::fromValue float (1));\nfile.set(\"Key2\", QVariant::fromValue float (2));\n\nfile.localMetadata(); // return QMap((\"Key1\", QVariant(float, 1)) (\"Key2\", QVariant(float, 2)))", 
            "title": "QVariantMap localMetadata()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#append-1", 
            "text": "Add new metadata fields to  metadata .    function definition:  void append(const QVariantMap  localMetadata)    parameters:     Parameter  Type  Description      localMetadata  const  QVariantMap    metadata to append to the local  metadata       output:  (void)   example: File f();\nf.set(\"Key1\", QVariant::fromValue float (1));\n\nQVariantMap map;\nmap.insert(\"Key2\", QVariant::fromValue float (2));\nmap.insert(\"Key3\", QVariant::fromValue float (3));\n\nf.append(map);\nf.flat(); // returns \"[Key1=1, Key2=2, Key3=3]\"", 
            "title": "void append(const QVariantMap localMetadata)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#append-2", 
            "text": "Append another file using the  ;  separator. The  File   names  are combined with the separator in between them. The  metadata  fields are combined. An additional field describing the separator is appended to the  metadata .    function definition:  void append(const File  other)    parameters:     Parameter  Type  Description      other  const  File    File to append       output:  (void)   example: File f1(\"../path/to/pictures/picture1.jpg\");\nf1.set(\"Key1\", QVariant::fromValue float (1));\n\nFile f2(\"../path/to/pictures/picture2.jpg\");\nf2.set(\"Key2\", QVariant::fromValue float (2));\nf2.set(\"Key3\", QVariant::fromValue float (3));\n\nf1.append(f2);\nf1.name; // return \"../path/to/pictures/picture1.jpg;../path/to/pictures/picture2.jpg\"\nf1.localKeys(); // returns \"[Key1, Key2, Key3, separator]\"", 
            "title": "void append(const File other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-pe-1", 
            "text": "Shortcut operator to call  append .    function definition:  inline File  operator+=(const QMap QString, QVariant   other)    parameters:  Parameter | Type | Description\nother | const  QMap QString ,  QVariant    | Metadata map to append to the local  metadata    output:  ( File   ) Returns a reference to this file after the append occurs.   example: File f();\nf.set(\"Key1\", QVariant::fromValue float (1));\n\nQMap QString, QVariant  map;\nmap.insert(\"Key2\", QVariant::fromValue float (2));\nmap.insert(\"Key3\", QVariant::fromValue float (3));\n\nf += map;\nf.flat(); // returns \"[Key1=1, Key2=2, Key3=3]\"", 
            "title": "File operator+=(const QMapQString, QVariant other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-pe-2", 
            "text": "Shortcut operator to call  append .    function definition:  inline File  operator+=(const File  other)    parameters:  Parameter | Type | Description\nother | const  File    | File to append    output:  ( File   ) Returns a reference to this file after the append occurs.   example: File f1(\"../path/to/pictures/picture1.jpg\");\nf1.set(\"Key1\", QVariant::fromValue float (1));\n\nFile f2(\"../path/to/pictures/picture2.jpg\");\nf2.set(\"Key2\", QVariant::fromValue float (2));\nf2.set(\"Key3\", QVariant::fromValue float (3));\n\nf1 += f2;\nf1.name; // return \"../path/to/pictures/picture1.jpg;../path/to/pictures/picture2.jpg\"\nf1.localKeys(); // returns \"[Key1, Key2, Key3, separator]\"", 
            "title": "File operator+=(const File other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#split-1", 
            "text": "This function splits the  File  into multiple files and returns them as a list. This is done by parsing the file  name  and splitting on the separator located at  metadata [\"separator\"]. If \"separator\" is not a  metadata  key, the returned list has the original file as the only entry. Each new file has the same  metadata  as the original, pre-split, file.    function definition:  QList File  split() const    parameters:  None   output:  ( QList File ) List of split files  example: File f1(\"../path/to/pictures/picture1.jpg\");\nf1.set(\"Key1\", QVariant::fromValue float (1));\n\nf1.split(); // returns [../path/to/pictures/picture1.jpg[Key1=1]]\n\nFile f2(\"../path/to/pictures/picture2.jpg\");\nf2.set(\"Key2\", QVariant::fromValue float (2));\nf2.set(\"Key3\", QVariant::fromValue float (3));\n\nf1.append(f2);\nf1.split(); // returns [../path/to/pictures/picture1.jpg[Key1=1, Key2=2, Key3=3, separator=;],\n            //          ../path/to/pictures/picture2.jpg[Key1=1, Key2=2, Key3=3, separator=;]]", 
            "title": "QListFile split()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#split-2", 
            "text": "This function splits the file into multiple files and returns them as a list. This is done by parsing the file  name  and splitting on the given separator. Each new file has the same  metadata  as the original, pre-split, file.    function definition:  QList File  split(const QString  separator) const    parameters:     Parameter  Type  Description      separator  const  QString    Separator to split the file name on       output:  ( QList File ) List of split files   example: File f(\"../path/to/pictures/picture1.jpg,../path/to/pictures/picture2.jpg\");\nf.set(\"Key1\", QVariant::fromValue float (1));\nf.set(\"Key2\", QVariant::fromValue float (2));\n\nf.split(\",\"); // returns [../path/to/pictures/picture1.jpg[Key1=1, Key2=2],\n                          ../path/to/pictures/picture2.jpg[Key1=1, Key2=2]]", 
            "title": "QListFile split(const QString separator)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#setparameter", 
            "text": "Insert a keyless value into the  metadata . Generic key of \"ArgN\" is used, where N is given as a parameter.    function definition:  inline void setParameter(int index, const QVariant  value)    parameters:     Parameter  Type  Description      index  int  Number to append to generic key    value  const  QVariant    Value to add to the metadata       output:  (void)   see:   containsParameter ,  getParameter  example: File f;\nf.set(\"Key1\", QVariant::fromValue float (1));\nf.set(\"Key2\", QVariant::fromValue float (2));\n\nf.setParameter(1, QVariant::fromValue float (3));\nf.setParameter(5, QVariant::fromValue float (4));\n\nf.flat(); // returns \"[Key1=1, Key2=2, Arg1=3, Arg5=4]\"", 
            "title": "void setParameter(int index, const QVariant value)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#containsparameter", 
            "text": "Check if the local  metadata  contains a keyless value.    function definition:  inline bool containsParameter(int index) const    parameters:     Parameter  Type  Description      index  int  Index of the keyless value to check for       output:  (bool) Returns true if the local  metadata  contains the keyless value, otherwise reutrns false.   see:   setParameter ,  getParameter  example: File f;\nf.setParameter(1, QVariant::fromValue float (1));\nf.setParameter(2, QVariant::fromValue float (2));\n\nf.containsParameter(1); // returns true\nf.containsParameter(2); // returns true\nf.containsParameter(3); // returns false", 
            "title": "bool containsParameter(int index)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#getparameter", 
            "text": "Get a keyless value from the local  metadata . If the value does not exist an error is thrown.    function definition:  inline QVariant getParameter(int index) const    parameter:     Parameter  Type  Description      index  int  Index of the keyless value to look up. If the index does not exist an error is thrown.       output:  ( QVariant ) Returns the keyless value associated with the given index   see:   setParameter ,  containsParameter  example: File f;\nf.setParameter(1, QVariant::fromValue float (1));\nf.setParameter(2, QVariant::fromValue float (2));\n\nf.getParameter(1); // returns 1\nf.getParameter(2); // returns 2\nf.getParameter(3); // error: index does not exist", 
            "title": "QVariant getParameter(int index)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-ee-1", 
            "text": "Compare  name  against a c-style string.    function definition:  inline bool operator==(const char *other) const    parameters:     Parameter  Type  Description      other  const char *  C-style string to compare against       output:  (bool) Returns true if the strings are equal, false otherwise.   example: File f(\"picture.jpg\");\n\nf == \"picture.jpg\";       // returns true\nf == \"other_picture.jpg\"; // returns false", 
            "title": "bool operator==(const char *other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-ee-2", 
            "text": "Compare  name  and  metadata  against another file name and metadata.    function definition:  inline bool operator==(const File  other) const    parameters:     Parameter  Type  Description      other  const  File    File to compare against       output:  (bool) Returns true if the names and metadata are equal, false otherwise.   example: File f1(\"picture1.jpg\");\nFile f2(\"picture1.jpg\");\n\nf1 == f2; // returns true\n\nf1.set(\"Key1\", QVariant::fromValue float (1));\nf2.set(\"Key2\", QVariant::fromValue float (2));\n\nf1 == f2; // returns false (metadata doesn't match)", 
            "title": "bool operator==(const File other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-ne", 
            "text": "Compare  name  and  metadata  against another file name and metadata.    function definition:  inline bool operator!=(const File  other) const    parameters:     Parameter  Type  Description      other  const  File    File to compare against       output:  (bool) Returns true if the names and metadata are not equal, false otherwise.   example: File f1(\"picture1.jpg\");\nFile f2(\"picture1.jpg\");\n\nf1 != f2; // returns false\n\nf1.set(\"Key1\", QVariant::fromValue float (1));\nf2.set(\"Key2\", QVariant::fromValue float (2));\n\nf1 != f2; // returns true (metadata doesn't match)", 
            "title": "bool operator!=(const File other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-lt", 
            "text": "Compare  name  against another file name.    function definition:  inline bool operator (const File  other) const    parameters:     Parameter  Type  Description      other  const  File    File to compare against       output:  (bool) Returns true if  name    others.name", 
            "title": "bool operator(const File other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-lte", 
            "text": "Compare  name  against another file name.    function definition:  inline bool operator =(const File  other) const    parameters:     Parameter  Type  Description      other  const  File    File to compare against       output:  (bool) Returns true if  name   = others.name", 
            "title": "bool operator=(const File other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-gt", 
            "text": "Compare  name  against another file name.    function definition:  inline bool operator (const File  other) const    parameters:     Parameter  Type  Description      other  const  File    File to compare against       output:  (bool) Returns true if  name    others.name", 
            "title": "bool operator(const File other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#operator-gte", 
            "text": "Compare  name  against another file name.    function definition:  inline bool operator =(const File  other) const    parameters:     Parameter  Type  Description      other  const  File    File to compare against       output:  (bool) Returns true if  name   = others.name", 
            "title": "bool operator=(const File other)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#isnull", 
            "text": "Check if the file is null.    function definition:  inline bool isNull() const    parameters:  NONE   output:  (bool) Returns true if  name  and  metadata  are empty, false otherwise.  example: File f;\nf.isNull(); // returns true\n\nf.set(\"Key1\", QVariant::fromValue float (1));\nf.isNull(); // returns false", 
            "title": "bool isNull()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#isterminal", 
            "text": "Checks if the value of  name  == \"terminal\".    function definition:  inline bool isTerminal() const    parameters:  NONE   output:  (bool) Returns true if  name  == \"terminal\", false otherwise.  example: File f1(\"terminal\"), f2(\"not_terminal\");\n\nf1.isTerminal(); // returns true\nf2.isTerminal(); // returns false", 
            "title": "bool isTerminal()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#exists", 
            "text": "Check if the file exists on disk.    function definition:  inline bool exists() const    parameters:  NONE   output:  Returns true if  name  exists on disk, false otherwise.   example:  File f1(\"/path/to/file/that/exists\"), f2(\"/path/to/non/existant/file\");  f1.exists(); // returns true\nf2.exists(); // returns false", 
            "title": "bool exists()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#filename", 
            "text": "Get the file's base name and extension.    function definition:  inline QString fileName() const    parameters:  NONE   output:  ( QString ) Returns the base name + extension of  name  example: File file(\"../path/to/pictures/picture.jpg\");\nfile.fileName(); // returns \"picture.jpg\"", 
            "title": "QString fileName()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#basename", 
            "text": "Get the file's base name.    function definition:  inline QString baseName() const    parameters:  NONE   output:  ( QString ) Returns the base name of  name  example: File file(\"../path/to/pictures/picture.jpg\");\nfile.baseName(); // returns \"picture\"", 
            "title": "QString baseName()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#suffix", 
            "text": "Get the file's extension.    function definition:  inline QString suffix() const    parameters:  NONE   output:  ( QString ) Returns the extension of  name  example: File file(\"../path/to/pictures/picture.jpg\");\nfile.suffix(); // returns \"jpg\"", 
            "title": "QString suffix()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#path", 
            "text": "Get the path of the file without the name.    function definition:  inline QString path() const    parameters:  NONE   output:  ( QString ) Returns the path of  name .  example: File file(\"../path/to/pictures/picture.jpg\");\nfile.suffix(); // returns \"../path/to/pictures\"", 
            "title": "QString path()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#resolved", 
            "text": "Get the full path for the file. This is done in three steps:   If  name  exists, return  name .  Prepend each path stored in  Globals- path  to  name . If the combined name exists then it is returned.  Prepend each path stored in  Globals- path  to  fileName . If the combined name exists then it is returned.   If none of the attempted names exist,  name  is returned unmodified.    function definition:  QString resolved() const    parameters:  NONE   output:  ( QString ) Returns the resolved string if it can be created. Otherwise it returns  name", 
            "title": "QString resolved()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#contains-1", 
            "text": "Check if a given key is in the local  metadata .    function definition:  bool contains(const QString  key) const    parameters:     Parameter  Type  Description      key  const  QString    Key to check the  metadata  for       output:  (bool) Returns true if the given key is in the  metadata , false otherwise.   example: File file;\nfile.set(\"Key1\", QVariant::fromValue float (1));\n\nfile.contains(\"Key1\"); // returns true\nfile.contains(\"Key2\"); // returns false", 
            "title": "bool contains(const QString key)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#contains-2", 
            "text": "Check if a list of keys is in the local  metadata .    function definition:  bool contains(const QStringList  keys) const    parameters:     Parameter  Type  Description      keys  const  QStringList    Keys to check the  metadata  for       output:  (bool) Returns true if  all  of the given keys are in the  metadata , false otherwise.   example: File file;\nfile.set(\"Key1\", QVariant::fromValue float (1));\nfile.set(\"Key2\", QVariant::fromValue float (2));\n\nfile.contains(QStringList(\"Key1\")); // returns true\nfile.contains(QStringList()   \"Key1\"   \"Key2\") // returns true\nfile.contains(QStringList()   \"Key1\"   \"Key3\"); // returns false", 
            "title": "bool contains(const QStringList keys)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#value", 
            "text": "Get the value associated with a given key from the  metadata . If the key is not found in the  local metadata , the  global metadata  is searched. In a special case, the key can be \"name\". This returns the file's  name .    function description:  QVariant value(const QString  key) const    parameters:     Parameter  Type  Description      key  const  QString    Key to look up the value in the  local metadata  or  global metadata . The key can also be \"name\".       output:  ( QVariant ) Returns the key associated with the value from either the  local  or  global  metadata. If the key is \"name\",  name  is returned.   example: File file;\nfile.set(\"Key1\", QVariant::fromValue float (1));\nfile.value(\"Key1\"); // returns QVariant(float, 1)", 
            "title": "QVariant value(const QString key)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#set-1", 
            "text": "Insert a value into the  metadata  using a provided key. If the key already exists the new value will override the old one.    function description:  inline void set(const QString  key, const QVariant  value)    parameters:     Parameters  Type  Description      key  const  QString    Key to store the given value in the  metadata    value  const  QVariant    Value to be stored       output:  (void)   example: File f;\nf.flat(); // returns \"\"\n\nf.set(\"Key1\", QVariant::fromValue float (1));\nf.flat(); // returns \"[Key1=1]\"", 
            "title": "void set(const QString key, const QVariant value)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#set-2", 
            "text": "Insert a value into the  metadata  using a provided key. If the key already exists the new value will override the old one.    function description:  void set(const QString  key, const QString  value)    parameters:     Parameters  Type  Description      key  const  QString    Key to store the given value in the  metadata    value  const  QString    Value to be stored       output:  (void)   example: File f;\nf.flat(); // returns \"\"\n\nf.set(\"Key1\", QString(\"1\"));\nf.flat(); // returns \"[Key1=1]\"", 
            "title": "void set(const QString key, const QString value)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#setlist", 
            "text": "Insert a list into the  metadata  using a provided key. If the key already exists the new value will override the old one. The value should be queried with  getList  instead of  get .    function description:  template  typename T  void setList(const QString  key, const QList T   value)    parameters:     Parameter  Type  Description      key  const  QString    Key to store the given value in the  metadata    value  const  QList T  List to be stored       output:  (void)   see:   getList ,  get  example: File file;\n\nQList float  list = QList float ()   1   2   3;\nfile.setList float (\"List\", list);\nfile.getList float (\"List\"); // return [1., 2. 3.]", 
            "title": "void setList(const QString key, const QListT value)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#remove", 
            "text": "Remove a key-value pair from the  metadata    function description:  inline void remove(const QString  key)    parameters:     Parameter  Type  Description      key  const  QString    Key to be removed from  metadata  along with its associated value.       output:  (void)   example: File f;\nf.set(\"Key1\", QVariant::fromValue float (1));\nf.set(\"Key2\", QVariant::fromValue float (2));\n\nf.flat(); // returns \"[Key1=1, Key2=2]\"\n\nf.remove(\"Key1\");\nf.flat(); // returns \"[Key2=2]\"", 
            "title": "void remove(const QString key)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#get-1", 
            "text": "Get a value from the  metadata  using a provided key. If the key does not exist or the value cannot be converted to a user specified type an error is thrown.    function definition:  template  typename T  T get(const QString  key) const    parameters:     Parameter  Type  Description      key  const  QString    Key to retrieve a value from  metadata       output:  ( T ) Returns a value of type  T .  T  is a user specified type. The value associated with the given key must be convertable to  T .   see:   get ,  getList  example: File f;\nf.set(\"Key1\", QVariant::fromValue float (1));\n\nf.get float (\"Key1\");  // returns 1\nf.get float (\"Key2\");  // Error: Key2 is not in the metadata\nf.get QRectF (\"Key1\"); // Error: A float can't be converted to a QRectF", 
            "title": "T get(const QString key)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#get-2", 
            "text": "Get a value from the  metadata  using a provided key. If the key does not exist or the value cannot be converted to user specified type a provided default value is returned instead.    function definition:  template  typename T  T get(const QString  key, const T  defaultValue)    parameters:     Parameter  Type  Description      key  const  QString    Key to retrieve a value from the  metadata    defaultValue  const T   Default value to be returned if the key does not exist or found value cannot be converted to  T .  T  is a user specified type.       output:  ( T ) Returns a value of type  T .  T  is a user specified type. If the value associated with the key is invalid, the provided default value is returned instead.   see:   get ,  getList  example: File f;\nf.set(\"Key1\", QVariant::fromValue float (1));\n\nf.get float (\"Key1\", 5);  // returns 1\nf.get float (\"Key2\", 5);  // returns 5\nf.get QRectF (\"Key1\", QRectF(0, 0, 10, 10)); // returns QRectF(0, 0, 10x10)", 
            "title": "T get(const QString key, const T defaultValue)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#getbool", 
            "text": "Get a boolean value from the  metadata  using a provided key. If the key is not in the  metadata  a provided default value is returned. If the key is in the metadata but the value cannot be converted to a bool true is returned. If the key is found and the value can be converted to a bool the value is returned.    function definition:  bool getBool(const QString  key, bool defaultValue = false) const    parameters:     Parameter  Type  Description      key  const  QString    Key to retrieve a value from the  metadata    defaultValue  bool  (Optional) Default value to be returned if the key is not in the  metadata .       output:  (bool) If the key  is not  in the  metadata  the provided default value is returned. If the key  is  in the  metadata  but the associated value  cannot  be converted to a bool true is returned. If the key  is  in the  metadata  and the associated value  can  be converted to a bool, that value is returned.   see:   get  example: File f;\nf.set(\"Key1\", QVariant::fromValue bool (true));\nf.set(\"Key2\", QVariant::fromValue float (10));\n\nf.getBool(\"Key1\");       // returns true\nf.getBool(\"Key2\")        // returns true (key found)\nf.getBool(\"Key3\");       // returns false (default value)\nf.getBool(\"Key3\", true); // returns true (default value)", 
            "title": "bool getBool(const QString key, bool defaultValue = false)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#getlist-1", 
            "text": "Get a list from the  metadata  using a provided key. If the key does not exist or the elements of the list cannot be converted to a user specified type an error is thrown.    function definition:  template  typename T  QList T  getList(const QString  key) const    parameters:     Parameter  Type  Description      key  const  QString    Key to retrieve a value from the  metadata       output:  ( QList T ) Returns a list of values of a user specified type.   see:   setList ,  get  example: File file;\n\nQList float  list = QList float ()   1   2   3;\nfile.setList float (\"List\", list);\n\nfile.getList float (\"List\");  // return [1., 2. 3.]\nfile.getList QRectF (\"List\"); // Error: float cannot be converted to QRectF\nfile.getList float (\"Key\");   // Error: key doesn't exist", 
            "title": "QListT getList(const QString key)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#getlist-2", 
            "text": "Get a list from the  metadata  using a provided key. If the key does not exist or the elements of the list cannot be converted to a user specified type a provided default value is returned.   function definition:   template   QList  getList(const QString  key, const QList  defaultValue) const    parameters:     Parameter  Type  Description      key  const  QString    Key to retrieve a value from the  metadata    defaultValue  QList T  (Optional) Default value to be returned if the key is not in the  metadata .       output:  ( QList T ) Returns a list of values of user specified type. If key is not in the  metadata  or if the value cannot be converted to a  QList T  the default value is returned.   see:   getList  example: File file;\n\nQList float  list = QList float ()   1   2   3;\nfile.setList float (\"List\", list);\n\nfile.getList float (\"List\", QList float ());                  // return [1., 2. 3.]\nfile.getList QRectF (\"List\", QList QRectF ());                // return []\nfile.getList float (\"Key\", QList float ()   1   2   3);    // return [1., 2., 3.]", 
            "title": "QListT getList(const QString key, const QListT defaultValue)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#namedpoints", 
            "text": "Find values in the  metadata  that can be converted into  QPointF 's. Values stored as  QList QPointF   will not * be returned.    function definition:  QList QPointF  namedPoints() const    parameters:  NONE   output:  ( QList QPointF ) Returns a list of points that can be converted from  metadata  values.  example: File file;\nfile.set(\"Key1\", QVariant::fromValue QPointF (QPointF(1, 1)));\nfile.set(\"Key2\", QVariant::fromValue QPointF (QPointF(2, 2)));\nfile.set(\"Points\", QVariant::fromValue QPointF (QPointF(3, 3)))\n\nf.namedPoints(); // returns [QPointF(1, 1), QPointF(2, 2), QPointF(3, 3)]\n\nfile.setPoints(QList QPointF ()   QPointF(3, 3)); // changes metadata[\"Points\"] to QList QPointF \nf.namedPoints(); // returns [QPointF(1, 1), QPointF(2, 2)]", 
            "title": "QListQPointF namedPoints()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#points", 
            "text": "Get values stored in the  metadata  with key \"Points\". It is expected that this field holds a  QList QPointf .    function definition:  QList QPointF  points() const    parameters:  NONE   output:  ( QList QPointf ) Returns a list of points stored at  metadata [\"Points\"]  see:   appendPoint ,  appendPoints ,  clearPoints ,  setPoints  example: File file;\nfile.set(\"Points\", QVariant::fromValue QPointF (QPointF(1, 1)));\nfile.points(); // returns [] (point is not in a list)\n\nfile.setPoints(QList QPointF ()   QPointF(2, 2));\nfile.points(); // returns [QPointF(2, 2)]", 
            "title": "QListQPointF points()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#appendpoint", 
            "text": "Append a point to the  QList QPointF  stored at  metadata [\"Points\"].    function definition:  void appendPoint(const QPointF  point)    parameters:     Parameter  Type  Description      point  const  QPoint    Point to be appended       output:  (void)   example: File file;\nfile.points(); // returns []\n\nfile.appendPoint(QPointF(1, 1));\nfile.points(); // returns [QPointF(1, 1)]", 
            "title": "void appendPoint(const QPointF point)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#appendpoints", 
            "text": "Append a list of points to the  QList QPointF  stored at  metadata [\"Points\"].    function definition:  void appendPoints(const QList QPointF   points)    parameters:     Parameter  Type  Description      points  const  QList QPointF    List of points to be appended       output:  (void)   example: File file;\nfile.points(); // returns []\n\nfile.appendPoints(QList QPointF ()   QPointF(1, 1)   QPointF(2, 2));\nfile.points(); // returns [QPointF(1, 1), QPointF(2, 2)]", 
            "title": "void appendPoints(const QListQPointF points)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#clearpoints", 
            "text": "Remove all points stored at  metadata [\"Points\"].    function definition:  inline void clearPoints()    parameters:  NONE   output:  (void)  example: File file;\nfile.appendPoints(QList QPointF ()   QPointF(1, 1)   QPointF(2, 2));\nfile.points(); // returns [QPointF(1, 1), QPointF(2, 2)]\n\nfile.clearPoints();\nfile.points(); // returns []", 
            "title": "void clearPoints()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#setpoints", 
            "text": "Replace the points stored at  metadata [\"Points\"]    function definition:  inline void setPoints(const QList QPointF   points)    parameters:     Parameter  Type  Description      points  const  QList QPointF    Points to overwrite  metadata  with       output:  (void)   example: File file;\nfile.appendPoints(QList QPointF ()   QPointF(1, 1)   QPointF(2, 2));\nfile.points(); // returns [QPointF(1, 1), QPointF(2, 2)]\n\nfile.setPoints(QList QPointF ()   QPointF(3, 3)   QPointF(4, 4));\nfile.points(); // returns [QPointF(3, 3), QPointF(4, 4)]", 
            "title": "void setPoints(const QListQPointF points)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#namedrects", 
            "text": "Find values in the  metadata  that can be converted into  QRectF 's. Values stored as  QList QRectF   will not * be returned.    function definition:  QList QRectF  namedRects() const    parameters:  NONE   output:  ( QList QRectF ) Returns a list of rects that can be converted from  metadata  values.  example: File file;\nfile.set(\"Key1\", QVariant::fromValue QRectF (QRectF(1, 1, 5, 5)));\nfile.set(\"Key2\", QVariant::fromValue QRectF (QRectF(2, 2, 5, 5)));\nfile.set(\"Rects\", QVariant::fromValue QRectF (QRectF(3, 3, 5, 5)));\n\nf.namedRects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5), QRectF(3, 3, 5x5)]\n\nfile.setRects(QList QRectF ()   QRectF(3, 3, 5x5)); // changes metadata[\"Rects\"] to QList QRectF \nf.namedRects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]", 
            "title": "QListQRectF namedRects()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#rects", 
            "text": "Get values stored at  metadata [\"Rects\"]. It is expected that this field holds a  QList QRectf .    function definition:  QList QRectF  points() const    parameters:  NONE   output:  ( QList QRectf ) Returns a list of rects stored at  metadata [\"Rects\"]  see:   appendRect ,  appendRects ,  clearRects ,  setRects  example: File file;\nfile.set(\"Rects\", QVariant::fromValue QRectF (QRectF(1, 1, 5, 5)));\nfile.rects(); // returns [] (rect is not in a list)\n\nfile.setRects(QList QRectF ()   QRectF(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(2, 2, 5x5)]", 
            "title": "QListQRectF rects()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#appendrect-1", 
            "text": "Append a rect to the  QList QRectF  stored at  metadata [\"Rects\"].    function definition:  void appendRect(const QRectF  rect)    parameters:     Parameter  Type  Description      rect  const [QRect][QRect]   Rect to be appended       output:  (void)   example: File file;\nfile.rects(); // returns []\n\nfile.appendRect(QRectF(1, 1, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5)]", 
            "title": "void appendRect(const QRectF rect)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#appendrect-2", 
            "text": "Append an OpenCV-style  Rect  to the  QList QRectF  stored at  metadata [\"Rects\"]. Supplied OpenCV-style rects are converted to  QRectF  before being appended.    function definition:  void appendRect(const Rect  rect)    parameters:     Parameter  Type  Description      rect  const  Rect    OpenCV-style rect to be appended       output:  (void)   example: File file;\nfile.rects(); // returns []\n\nfile.appendRect(cv::Rect(1, 1, 5, 5)); // automatically converted to QRectF\nfile.rects(); // returns [QRectF(1, 1, 5x5)]", 
            "title": "void appendRect(const Rect rect)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#appendrects-1", 
            "text": "Append a list of rects to the  QList QRectF  stored at  metadata [\"Rects\"].    function definition:  void appendRects(const QList QRectF   rects)    parameters:     Parameter  Type  Description      rects  const  QList QRectF    List of rects to be appended       output:  (void)   example: File file;\nfile.rects(); // returns []\n\nfile.appendRects(QList QRectF ()   QRectF(1, 1, 5, 5)   QRectF(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]", 
            "title": "void appendRects(const QListQRectF rects)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#appendrects-2", 
            "text": "Append a list of OpenCV-style  Rects  to the  QList QRectF  stored at  metadata [\"Rects\"]. Supplied OpenCV-style rects are converted to  QRectF  before being appended.    function definition:  void appendRects(const QList QRectF   rects)    parameters:     Parameter  Type  Description      rects  const  QList Rect    List of OpenCV-style rects to be appended       output:  (void)   example: File file;\nfile.rects(); // returns []\n\nfile.appendRects(QList Rect ()   Rect(1, 1, 5, 5)   Rect(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]", 
            "title": "void appendRects(const QListQRectF rects)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#clearrects", 
            "text": "Remove all points stored at  metadata [\"Rects\"].    function definition:  inline void clearRects()    parameters:  NONE   output:  (void)  example: File file;\nfile.appendRects(QList QRectF ()   QRectF(1, 1, 5, 5)   QRectF(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\nfile.clearRects();\nfile.rects(); // returns []", 
            "title": "void clearRects()"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#setrects-1", 
            "text": "Replace the rects stored at  metadata  with a provided list of rects.    function definition:  inline void setRects(const QList QRectF   rects)    parameters:     Parameter  Type  Description      rects  const  QList QRectF    Rects to overwrite  metadata [\"Rects\"] with       output:  (void)   example: File file;\nfile.appendRects(QList QRectF ()   QRectF(1, 1, 5, 5)   QRectF(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\nfile.setRects(QList QRectF ()   QRectF(3, 3, 5, 5)   QRectF(4, 4, 5, 5));\nfile.rects(); // returns [QRectF(3, 3, 5x5), QRectF(4, 4, 5x5)]", 
            "title": "void setRects(const QListQRectF rects)"
        }, 
        {
            "location": "/api_docs/cpp_api/file/functions/#setrects-2", 
            "text": "Replace the rects stored at  metadata  with a provided list of OpenCV-style  Rects .    function definition:  inline void setRects(const QList Rect   rects)    parameters:     Parameter  Type  Description      rects  const  QList Rect    OpenCV-style rects to overwrite  metadata [\"Rects\"] with       output:  (void)   example: File file;\nfile.appendRects(QList cv::Rect ()   cv::Rect(1, 1, 5, 5)   cv::Rect(2, 2, 5, 5));\nfile.rects(); // returns [QRectF(1, 1, 5x5), QRectF(2, 2, 5x5)]\n\nfile.setRects(QList cv::Rect ()   cv::Rect(3, 3, 5, 5)   cv::Rect(4, 4, 5, 5));\nfile.rects(); // returns [QRectF(3, 3, 5x5), QRectF(4, 4, 5x5)]", 
            "title": "void setRects(const QListRect rects)"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/filelist/", 
            "text": "Inherits \nQList\nFile\n.\n\n\nSee:\n\n\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nA convenience class for dealing with lists of files.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/constructors/", 
            "text": "Constructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFileList()\n\n\nDefault constructor. Doesn't do anything.\n\n\n\n\n\n\nFileList(int n)\n\n\nIntialize the \nFileList\n with n empty \nFiles\n\n\n\n\n\n\nFileList(const \nQStringList\n \nfiles)\n\n\nInitialize the \nFileList\n with a list of strings. Each string should have the format \"filename[key1=value1, key2=value2, ... keyN=valueN]\"\n\n\n\n\n\n\nFileList(const \nQList\nFile\n \nfiles)\n\n\nInitialize the \nFileList\n from a list of \nfiles\n.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/statics/", 
            "text": "FileList\n fromGallery(const \nFile\n \ngallery, bool cache = false)\n\n\nCreate a \nFileList\n from a \nGallery\n. Galleries store one or more \nTemplates\n on disk. Common formats include \ncsv\n, \nxml\n, and \ngal\n, which is a unique OpenBR format. Read more about this in the \nGallery\n section. This function creates a \nFileList\n by parsing the stored gallery based on its format. Cache determines whether the gallery should be stored for faster reading later.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic FileList fromGallery(const File \ngallery, bool cache = false)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nconst \nFile\n \n\n\nGallery file to be enrolled\n\n\n\n\n\n\ncache\n\n\nbool\n\n\n(Optional) Retain the gallery in memory. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nFileList\n) Returns the filelist that the gallery was enrolled into\n\n\n\n\nexample:\nFile gallery(\"gallery.csv\");\n\nFileList fList = FileList::fromGallery(gallery);\nfList.flat(); // returns all the files that have been loaded from disk. It could\n              // be 1 or 100 depending on what was stored.", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/statics/#fromgallery", 
            "text": "Create a  FileList  from a  Gallery . Galleries store one or more  Templates  on disk. Common formats include  csv ,  xml , and  gal , which is a unique OpenBR format. Read more about this in the  Gallery  section. This function creates a  FileList  by parsing the stored gallery based on its format. Cache determines whether the gallery should be stored for faster reading later.    function definition:  static FileList fromGallery(const File  gallery, bool cache = false)    parameters:     Parameter  Type  Description      gallery  const  File    Gallery file to be enrolled    cache  bool  (Optional) Retain the gallery in memory. Default is false.       output:  ( FileList ) Returns the filelist that the gallery was enrolled into   example: File gallery(\"gallery.csv\");\n\nFileList fList = FileList::fromGallery(gallery);\nfList.flat(); // returns all the files that have been loaded from disk. It could\n              // be 1 or 100 depending on what was stored.", 
            "title": "FileList fromGallery(const File gallery, bool cache = false)"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/functions/", 
            "text": "QStringList\n flat() const\n\n\nCalls \nflat\n on every \nFile\n in the list and returns the resulting strings as a \nQStringList\n.\n\n\n\n\n\n\nfunction definition:\n\n\nQStringList flat() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQStringList\n) Returns a list of the output of calling \nflat\n on each \nFile\n\n\nexample:\nFile f1(\"picture1.jpg\"), f2(\"picture2.jpg\");\nf1.set(\"Key\", QString(\"Value\"));\n\nFileList fList(QList\nFile\n() \n f1 \n f2);\nfList.flat(); // returns [\"picture1.jpg[Key=Value]\", \"picture2.jpg\"]\n\n\n\n\n\n\n\nQStringList\n names() const\n\n\nGet the \nnames\n of every \nFile\n in the list.\n\n\n\n\n\n\nfunction definition:\n\n\nQStringList names() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQStringList\n) Returns the \nname\n of every \nFile\n in the list\n\n\nexample:\nFile f1(\"picture1.jpg\"), f2(\"picture2.jpg\");\nf1.set(\"Key\", QString(\"Value\"));\n\nFileList fList(QList\nFile\n() \n f1 \n f2);\nfList.names(); // returns [\"picture1.jpg\", \"picture2.jpg\"]\n\n\n\n\n\n\n\nvoid sort(const \nQString\n \nkey)\n\n\nSort the \nFileList\n based on the values associated with a provided key in each \nFile\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid sort(const QString \nkey)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nKey to look up desired values in each \nFiles\n \nmetadata\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFile f1(\"1\"), f2(\"2\"), f3(\"3\");\nf1.set(\"Key\", QVariant::fromValue\nfloat\n(3));\nf2.set(\"Key\", QVariant::fromValue\nfloat\n(1));\nf3.set(\"Key\", QVariant::fromValue\nfloat\n(2));\n\nFileList fList(QList\nFile\n() \n f1 \n f2 \n f3);\nfList.names(); // returns [\"1\", \"2\", \"3\"]\n\nfList.sort(\"Key\");\nfList.names(); // returns [\"2\", \"3\", \"1\"]\n\n\n\n\n\n\n\nQList\nint\n crossValidationPartitions() const\n\n\nGet the cross-validation partion of each \nFile\n in the list. The partition is stored in each \nFile\n at \nmetadata\n[\"Partition\"].\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nint\n crossValidationPartitions() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQList\nint\n) Returns the cross-validation partion of each \nFile\n as a list. If a \nFile\n does not have the \"Partition\" field in it's \nmetadata\n 0 is used.\n\n\nexample:\nFile f1, f2, f3;\nf1.set(\"Partition\", QVariant::fromValue\nint\n(1));\nf3.set(\"Partition\", QVariant::fromValue\nint\n(3));\n\nFileList fList(QList\nFile\n() \n f1 \n f2 \n f3);\nfList.crossValidationPartitions(); // returns [1, 0, 3]\n\n\n\n\n\n\n\nint failures() const\n\n\nGet the number of \nFiles\n in the list that have \nfailed to enroll\n.\n\n\n\n\n\n\nfunction definition:\n\n\nint failures() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (int) Returns the number of \nFiles\n that have \nfte\n equal true.\n\n\nexample:\nFile f1, f2, f3;\nf1.fte = false;\nf2.fte = true;\nf3.fte = true;\n\nFileList fList(QList\nFile\n() \n f1 \n f2 \n f3);\nfList.failures(); // returns 2", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/functions/#flat", 
            "text": "Calls  flat  on every  File  in the list and returns the resulting strings as a  QStringList .    function definition:  QStringList flat() const    parameters:  NONE   output:  ( QStringList ) Returns a list of the output of calling  flat  on each  File  example: File f1(\"picture1.jpg\"), f2(\"picture2.jpg\");\nf1.set(\"Key\", QString(\"Value\"));\n\nFileList fList(QList File ()   f1   f2);\nfList.flat(); // returns [\"picture1.jpg[Key=Value]\", \"picture2.jpg\"]", 
            "title": "QStringList flat() const"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/functions/#names", 
            "text": "Get the  names  of every  File  in the list.    function definition:  QStringList names() const    parameters:  NONE   output:  ( QStringList ) Returns the  name  of every  File  in the list  example: File f1(\"picture1.jpg\"), f2(\"picture2.jpg\");\nf1.set(\"Key\", QString(\"Value\"));\n\nFileList fList(QList File ()   f1   f2);\nfList.names(); // returns [\"picture1.jpg\", \"picture2.jpg\"]", 
            "title": "QStringList names() const"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/functions/#sort", 
            "text": "Sort the  FileList  based on the values associated with a provided key in each  File .    function definition:  void sort(const QString  key)    parameters:     Parameter  Type  Description      key  const  QString    Key to look up desired values in each  Files   metadata       output:  (void)   example: File f1(\"1\"), f2(\"2\"), f3(\"3\");\nf1.set(\"Key\", QVariant::fromValue float (3));\nf2.set(\"Key\", QVariant::fromValue float (1));\nf3.set(\"Key\", QVariant::fromValue float (2));\n\nFileList fList(QList File ()   f1   f2   f3);\nfList.names(); // returns [\"1\", \"2\", \"3\"]\n\nfList.sort(\"Key\");\nfList.names(); // returns [\"2\", \"3\", \"1\"]", 
            "title": "void sort(const QString key)"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/functions/#crossvalidationpartitions", 
            "text": "Get the cross-validation partion of each  File  in the list. The partition is stored in each  File  at  metadata [\"Partition\"].    function definition:  QList int  crossValidationPartitions() const    parameters:  NONE   output:  ( QList int ) Returns the cross-validation partion of each  File  as a list. If a  File  does not have the \"Partition\" field in it's  metadata  0 is used.  example: File f1, f2, f3;\nf1.set(\"Partition\", QVariant::fromValue int (1));\nf3.set(\"Partition\", QVariant::fromValue int (3));\n\nFileList fList(QList File ()   f1   f2   f3);\nfList.crossValidationPartitions(); // returns [1, 0, 3]", 
            "title": "QListint crossValidationPartitions() const"
        }, 
        {
            "location": "/api_docs/cpp_api/filelist/functions/#failures", 
            "text": "Get the number of  Files  in the list that have  failed to enroll .    function definition:  int failures() const    parameters:  NONE   output:  (int) Returns the number of  Files  that have  fte  equal true.  example: File f1, f2, f3;\nf1.fte = false;\nf2.fte = true;\nf3.fte = true;\n\nFileList fList(QList File ()   f1   f2   f3);\nfList.failures(); // returns 2", 
            "title": "int failures() const"
        }, 
        {
            "location": "/api_docs/cpp_api/template/template/", 
            "text": "Inherits \nQList\nMat\n.\n\n\nA list of matrices associated with a file.\n\n\nSee:\n\n\n\n\nMembers\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nThe Template is one of two important data structures in OpenBR (the \nFile\n is the other).\nA template represents a biometric at various stages of enrollment and can be modified by \nTransforms\n and compared to other \ntemplates\n with \nDistances\n.\n\n\nWhile there exist many cases (ex. video enrollment, multiple face detects, per-patch subspace learning, ...) where the template will contain more than one matrix,\nin most cases templates have exactly one matrix in their list representing a single image at various stages of enrollment.\nIn the cases where exactly one image is expected, the template provides the function m() as an idiom for treating it as a single matrix.\nCasting operators are also provided to pass the template into image processing functions expecting matrices.\n\n\nMetadata related to the template that is computed during enrollment (ex. bounding boxes, eye locations, quality metrics, ...) should be assigned to the template's \nFile\n member.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/template/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nFile\n\n\nThe file that constructs the template and stores its associated metadata", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/template/constructors/", 
            "text": "Constructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTemplate()\n\n\nThe default template constructor. It doesn't do anything.\n\n\n\n\n\n\nTemplate(const \nFile\n \nfile)\n\n\nSets \nfile\n to the given \nFile\n.\n\n\n\n\n\n\nTemplate(const \nFile\n \nfile, const \nMat\n \nmat)\n\n\nSets \nfile\n to the given \nFile\n and appends the given \nMat\n to itself.\n\n\n\n\n\n\nTemplate(const \nMat\n \nmat)\n\n\nAppends the given \nMat\n to itself", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/template/statics/", 
            "text": "QDataStream\n \noperator\n(\nQDataStream\n \nstream, const \nTemplate\n \nt)\n\n\nSerialize a template\n\n\n\n\n\n\nfunction definition:\n\n\nQDataStream \noperator\n(QDataStream \nstream, const Template \nt)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n \n\n\nThe stream to serialize to\n\n\n\n\n\n\nt\n\n\nconst \nTemplate\n \n\n\nThe template to serialize\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQDataStream\n \n) Returns the updated stream\n\n\n\n\nexample:\nvoid store(QDataStream \nstream)\n{\n    Template t(\"picture.jpg\");\n    t.append(Mat::ones(1, 1, CV_8U));\n\n    stream \n t; // \"[\"1\"]picture.jpg\" serialized to the stream\n}\n\n\n\n\n\n\n\nQDataStream\n \noperator\n(\nQDataStream\n \nstream, \nTemplate\n \nt)\n\n\nDeserialize a template\n\n\n\n\n\n\nfunction definition:\n\n\nQDataStream \noperator\n(QDataStream \nstream, Template \nt)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n \n\n\nThe stream to deserialize to\n\n\n\n\n\n\nt\n\n\nconst \nTemplate\n \n\n\nThe template to deserialize\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQDataStream\n \n) Returns the updated stream\n\n\n\n\nexample:\nvoid load(QDataStream \nstream)\n{\n    Template in(\"picture.jpg\");\n    in.append(Mat::ones(1, 1, CV_8U));\n\n    stream \n in; // \"[\"1\"]picture.jpg\" serialized to the stream\n\n    Template out;\n    stream \n out;\n\n    out.file; // returns \"picture.jpg\"\n    out; // returns [\"1\"]\n}", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/template/statics/#operator-ltlt", 
            "text": "Serialize a template    function definition:  QDataStream  operator (QDataStream  stream, const Template  t)    parameters:     Parameter  Type  Description      stream  QDataStream    The stream to serialize to    t  const  Template    The template to serialize       output:  ( QDataStream   ) Returns the updated stream   example: void store(QDataStream  stream)\n{\n    Template t(\"picture.jpg\");\n    t.append(Mat::ones(1, 1, CV_8U));\n\n    stream   t; // \"[\"1\"]picture.jpg\" serialized to the stream\n}", 
            "title": "QDataStream operator(QDataStream stream, const Template t)"
        }, 
        {
            "location": "/api_docs/cpp_api/template/statics/#operator-gtgt", 
            "text": "Deserialize a template    function definition:  QDataStream  operator (QDataStream  stream, Template  t)    parameters:     Parameter  Type  Description      stream  QDataStream    The stream to deserialize to    t  const  Template    The template to deserialize       output:  ( QDataStream   ) Returns the updated stream   example: void load(QDataStream  stream)\n{\n    Template in(\"picture.jpg\");\n    in.append(Mat::ones(1, 1, CV_8U));\n\n    stream   in; // \"[\"1\"]picture.jpg\" serialized to the stream\n\n    Template out;\n    stream   out;\n\n    out.file; // returns \"picture.jpg\"\n    out; // returns [\"1\"]\n}", 
            "title": "QDataStream operator(QDataStream stream, Template t)"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/", 
            "text": "operator const \nFile\n \n() const\n\n\nIdiom to treat the template like a \nFile\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline operator const File \n() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nFile\n Returns \nfile\n.\n\n\n\n\nconst \nMat\n \nm() const\n\n\nIdiom to treat the template like a \nMat\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline const Mat \nm() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nMat\n) Returns the last \nMat\n in the list. If the list is empty an empty \nMat\n is returned.\n\n\nexample:\nTemplate t;\nt.m(); // returns empty mat\n\nMat m1;\nt.append(m1);\nt.m(); // returns m1;\n\nMat m2;\nt.append(m2);\nt.m(); // returns m2;\n\n\n\n\n\n\n\nMat\n \nm()\n\n\nIdiom to treat the template like a \nMat\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline Mat \nm()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nMat\n) Returns the last \nMat\n in the list. If the list is empty an empty \nMat\n is returned.\n\n\nexample:\nTemplate t;\nt.m(); // returns empty mat\n\nMat m1;\nt.append(m1);\nt.m(); // returns m1;\n\nMat m2;\nt.append(m2);\nt.m(); // returns m2;\n\n\n\n\n\n\n\noperator const \nMat\n \n()\n\n\nIdiom to treat the template like a \nMat\n. Makes a call to \nm()\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline operator const Mat\n() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nMat\n) Returns the last \nMat\n in the list. If the list is empty an empty \nMat\n is returned.\n\n\nsee:\n \nm\n\n\n\n\noperator \nMat\n \n()\n\n\nIdiom to treat the template like a \nMat\n. Makes a call to \nm()\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline operator Mat\n()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nMat\n) Returns the last \nMat\n in the list. If the list is empty an empty \nMat\n is returned.\n\n\nsee:\n \nm\n\n\n\n\noperator \n_InputArray\n \n()\n\n\nIdiom to treat the template like an \n_InputArray\n. Makes a call to \nm()\n.\n\n\n\n\nfunction definition:\ninline operator _InputArray() const\n\n\n\n\n\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\noutput:\n (\n_InputArray\n) Returns the last \nMat\n in the list. If the list is empty an empty \nMat\n is returned.\n\n\nsee:\n \nm\n\n\n\n\noperator \n_OutputArray\n \n()\n\n\nIdiom to treat the template like an \n_OutputArray\n. Makes a call to \nm()\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline operator _OutputArray()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\n_OutputArray\n) Returns the last \nMat\n in the list. If the list is empty an empty \nMat\n is returned.\n\n\nsee:\n \nm\n\n\n\n\nMat\n \noperator =(const \nMat\n \nother)\n\n\nIdiom to treat the template like a \nMat\n. Set the result of \nm()\n equal to other.\n\n\n\n\n\n\nfunction definition:\n\n\ninline Mat \noperator=(const Mat \nother)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst Mat \n\n\nMat to overwrite value of \nm\n\n\n\n\n\n\n\n\n\n\n\n\noutput\n: (\nMat\n \n) Returns a reference to the updated \nMat\n\n\n\n\n\n\nbool isNull() const\n\n\nCheck if the template is NULL.\n\n\n\n\n\n\nfunction definition:\n\n\ninline bool isNull() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns true if the template is empty \nor\n if \nm\n has no data.\n\n\nexample:\nTemplate t;\nt.isNull(); // returns true\n\nt.append(Mat());\nt.isNull(); // returns true\n\nt.append(Mat::ones(1, 1, CV_8U));\nt.isNull(); // returns false\n\n\n\n\n\n\n\nvoid merge(const \nTemplate\n \nother)\n\n\nAppend the contents of another template. The \nfiles\n are appended using \nappend\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline void merge(const Template \nother)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nother\n\n\nconst \nTemplate\n \n\n\nTemplate to be merged\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplate t1(\"picture1.jpg\"), t2(\"picture2.jpg\");\nMat m1, m2;\n\nt1.append(m1);\nt2.append(m2);\n\nt1.merge(t2);\n\nt1.file; // returns picture1.jpg;picture2.jpg[seperator=;]\nt1; // returns [m1, m2]\n\n\n\n\n\n\n\nsize_t bytes() const\n\n\nGet the total number of bytes in the template\n\n\n\n\n\n\nfunction definition:\n\n\nsize_t bytes() const\n\n\n\n\n\n\n\nparameters:\n None\n\n\n\n\noutput:\n (int) Returns the sum of the bytes in each \nMat\n in the \nTemplate\n\n\nexample:\nTemplate t;\n\nMat m1 = Mat::ones(1, 1, CV_8U); // 1 byte\nMat m2 = Mat::ones(2, 2, CV_8U); // 4 bytes\nMat m3 = Mat::ones(3, 3, CV_8U); // 9 bytes\n\nt \n m1 \n m2 \n m3;\n\nt.bytes(); // returns 14\n\n\n\n\n\n\n\nTemplate clone() const\n\n\nClone the template\n\n\n\n\n\n\nfunction definition:\n\n\nTemplate clone() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nTemplate\n) Returns a new \nTemplate\n with copies of the \nfile\n and each \nMat\n that was in the original.\n\n\nexample:\nTemplate t1(\"picture.jpg\");\nt1.append(Mat::ones(1, 1, CV_8U));\n\nTemplate t2 = t1.clone();\n\nt2.file; // returns \"picture.jpg\"\nt2; // returns [\"1\"]", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#operator-file", 
            "text": "Idiom to treat the template like a  File .    function definition:  inline operator const File  () const    parameters:  NONE   output:  ( File  Returns  file .", 
            "title": "operator const File () const"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#m-1", 
            "text": "Idiom to treat the template like a  Mat .    function definition:  inline const Mat  m() const    parameters:  NONE   output:  ( Mat ) Returns the last  Mat  in the list. If the list is empty an empty  Mat  is returned.  example: Template t;\nt.m(); // returns empty mat\n\nMat m1;\nt.append(m1);\nt.m(); // returns m1;\n\nMat m2;\nt.append(m2);\nt.m(); // returns m2;", 
            "title": "const Mat m() const"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#m-2", 
            "text": "Idiom to treat the template like a  Mat .    function definition:  inline Mat  m()    parameters:  NONE   output:  ( Mat ) Returns the last  Mat  in the list. If the list is empty an empty  Mat  is returned.  example: Template t;\nt.m(); // returns empty mat\n\nMat m1;\nt.append(m1);\nt.m(); // returns m1;\n\nMat m2;\nt.append(m2);\nt.m(); // returns m2;", 
            "title": "Mat m()"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#operator-mat-1", 
            "text": "Idiom to treat the template like a  Mat . Makes a call to  m() .    function definition:  inline operator const Mat () const    parameters:  NONE   output:  ( Mat ) Returns the last  Mat  in the list. If the list is empty an empty  Mat  is returned.  see:   m", 
            "title": "operator const Mat ()"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#operator-mat-2", 
            "text": "Idiom to treat the template like a  Mat . Makes a call to  m() .    function definition:  inline operator Mat ()    parameters:  NONE   output:  ( Mat ) Returns the last  Mat  in the list. If the list is empty an empty  Mat  is returned.  see:   m", 
            "title": "operator Mat ()"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#operator-inputarray", 
            "text": "Idiom to treat the template like an  _InputArray . Makes a call to  m() .   function definition: inline operator _InputArray() const      parameters:  NONE  output:  ( _InputArray ) Returns the last  Mat  in the list. If the list is empty an empty  Mat  is returned.  see:   m", 
            "title": "operator _InputArray ()"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#operator-outputarray", 
            "text": "Idiom to treat the template like an  _OutputArray . Makes a call to  m() .    function definition:  inline operator _OutputArray()    parameters:  NONE   output:  ( _OutputArray ) Returns the last  Mat  in the list. If the list is empty an empty  Mat  is returned.  see:   m", 
            "title": "operator _OutputArray ()"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#operator-e", 
            "text": "Idiom to treat the template like a  Mat . Set the result of  m()  equal to other.    function definition:  inline Mat  operator=(const Mat  other)    parameters:     Parameter  Type  Description      other  const Mat   Mat to overwrite value of  m       output : ( Mat   ) Returns a reference to the updated  Mat", 
            "title": "Mat operator =(const Mat other)"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#isnull", 
            "text": "Check if the template is NULL.    function definition:  inline bool isNull() const    parameters:  NONE   output:  (bool) Returns true if the template is empty  or  if  m  has no data.  example: Template t;\nt.isNull(); // returns true\n\nt.append(Mat());\nt.isNull(); // returns true\n\nt.append(Mat::ones(1, 1, CV_8U));\nt.isNull(); // returns false", 
            "title": "bool isNull() const"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#merge", 
            "text": "Append the contents of another template. The  files  are appended using  append .    function definition:  inline void merge(const Template  other)    parameters:     Parameter  Type  Description      other  const  Template    Template to be merged       output:  (void)   example: Template t1(\"picture1.jpg\"), t2(\"picture2.jpg\");\nMat m1, m2;\n\nt1.append(m1);\nt2.append(m2);\n\nt1.merge(t2);\n\nt1.file; // returns picture1.jpg;picture2.jpg[seperator=;]\nt1; // returns [m1, m2]", 
            "title": "void merge(const Template other)"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#bytes", 
            "text": "Get the total number of bytes in the template    function definition:  size_t bytes() const    parameters:  None   output:  (int) Returns the sum of the bytes in each  Mat  in the  Template  example: Template t;\n\nMat m1 = Mat::ones(1, 1, CV_8U); // 1 byte\nMat m2 = Mat::ones(2, 2, CV_8U); // 4 bytes\nMat m3 = Mat::ones(3, 3, CV_8U); // 9 bytes\n\nt   m1   m2   m3;\n\nt.bytes(); // returns 14", 
            "title": "size_t bytes() const"
        }, 
        {
            "location": "/api_docs/cpp_api/template/functions/#clone", 
            "text": "Clone the template    function definition:  Template clone() const    parameters:  NONE   output:  ( Template ) Returns a new  Template  with copies of the  file  and each  Mat  that was in the original.  example: Template t1(\"picture.jpg\");\nt1.append(Mat::ones(1, 1, CV_8U));\n\nTemplate t2 = t1.clone();\n\nt2.file; // returns \"picture.jpg\"\nt2; // returns [\"1\"]", 
            "title": "Template clone() const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/templatelist/", 
            "text": "Inherits \nQList\nTemplate\n.\n\n\nConvenience class for working with a list of templates.\n\n\nSee:\n\n\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/constructors/", 
            "text": "Constructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTemplateList()\n\n\nThe default \nTemplateList\n constructor. Doesn't do anything.\n\n\n\n\n\n\nTemplateList(const \nQList\nTemplate\n \ntemplates)\n\n\nInitialize the \nTemplateList\n with a list of templates. The given list is appended\n\n\n\n\n\n\nTemplateList(const \nQList\nFile\n \nfiles)\n\n\nInitialize the \nTemplateList\n with a list of \nFiles\n. Each \nFile\n is treated like a template and appended.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/statics/", 
            "text": "TemplateList\n fromGallery(const \nFile\n \ngallery)\n\n\nCreate a \nTemplateList\n from a gallery \nFile\n.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic TemplateList fromGallery(const File \ngallery)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngallery\n\n\nconst \nFile\n \n\n\nGallery \nfile\n to be enrolled.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTemplateList\n) Returns a \nTemplateList\n created by enrolling the gallery.\n\n\n\n\n\n\nTemplateList\n fromBuffer(const \nQByteArray\n \nbuffer)\n\n\nCreate a template from a memory buffer of individual templates. This is compatible with \n.gal\n galleries.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic TemplateList fromBuffer(const QByteArray \nbuffer)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbuffer\n\n\nconst \nQByteArray\n \n\n\nRaw data buffer to be enrolled\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTemplateList\n) Returns a \nTemplateList\n created by enrolling the buffer\n\n\n\n\n\n\nTemplateList\n relabel(const \nTemplateList\n \ntl, const \nQString\n \npropName, bool preserveIntegers)\n\n\nRelabel the values associated with a given key in the \nmetadata\n of a provided \nTemplateList\n. The values are relabeled to be between [0, numClasses-1]. If preserveIntegers is true and the \nmetadata\n can be converted to integers then numClasses equals the maximum value in the values. Otherwise, numClasses equals the number of unique values. The relabeled values are stored in the \"Label\" field of the returned \nTemplateList\n.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic TemplateList relabel(const TemplateList \ntl, const QString \npropName, bool preserveIntegers)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntl\n\n\nconst \nTemplateList\n \n\n\nTemplateList\n to be relabeled\n\n\n\n\n\n\npropName\n\n\nconst \nQString\n \n\n\nMetadata\n key\n\n\n\n\n\n\npreserveIntegers\n\n\nbool\n\n\nIf true attempt to use the \nmetadata\n values as the relabeled values. Otherwise use the number of unique values.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTemplateList\n) Returns a \nTemplateList\n identical to the input \nTemplateList\n but with the new labels appended to the \nmetadata\n using the \"Label\" key.\n\n\n\n\nexample:\nTemplate t1, t2, t3;\n\nt1.file.set(\"Class\", QString(\"1\"));\nt2.file.set(\"Class\", QString(\"10\"));\nt3.file.set(\"Class\", QString(\"100\"));\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2 \n t3);\n\nTemplateList relabeled = TemplateList::relabel(tList, \"Class\", true);\nrelabeled.files(); // returns [[Class=1, Label=1], [Class=10, Label=10], [Class=100, Label=100]]\n\nrelabeled = TemplateList::relabel(tList, \"Class\", false);\nrelabeled.files(); // returns [[Class=1, Label=0], [Class=10, Label=1], [Class=100, Label=2]]", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/statics/#fromgallery", 
            "text": "Create a  TemplateList  from a gallery  File .    function definition:  static TemplateList fromGallery(const File  gallery)    parameters:     Parameter  Type  Description      gallery  const  File    Gallery  file  to be enrolled.       output:  ( TemplateList ) Returns a  TemplateList  created by enrolling the gallery.", 
            "title": "TemplateList fromGallery(const File gallery)"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/statics/#frombuffer", 
            "text": "Create a template from a memory buffer of individual templates. This is compatible with  .gal  galleries.    function definition:  static TemplateList fromBuffer(const QByteArray  buffer)    parameters:     Parameter  Type  Description      buffer  const  QByteArray    Raw data buffer to be enrolled       output:  ( TemplateList ) Returns a  TemplateList  created by enrolling the buffer", 
            "title": "TemplateList fromBuffer(const QByteArray buffer)"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/statics/#relabel", 
            "text": "Relabel the values associated with a given key in the  metadata  of a provided  TemplateList . The values are relabeled to be between [0, numClasses-1]. If preserveIntegers is true and the  metadata  can be converted to integers then numClasses equals the maximum value in the values. Otherwise, numClasses equals the number of unique values. The relabeled values are stored in the \"Label\" field of the returned  TemplateList .    function definition:  static TemplateList relabel(const TemplateList  tl, const QString  propName, bool preserveIntegers)    parameters:     Parameter  Type  Description      tl  const  TemplateList    TemplateList  to be relabeled    propName  const  QString    Metadata  key    preserveIntegers  bool  If true attempt to use the  metadata  values as the relabeled values. Otherwise use the number of unique values.       output:  ( TemplateList ) Returns a  TemplateList  identical to the input  TemplateList  but with the new labels appended to the  metadata  using the \"Label\" key.   example: Template t1, t2, t3;\n\nt1.file.set(\"Class\", QString(\"1\"));\nt2.file.set(\"Class\", QString(\"10\"));\nt3.file.set(\"Class\", QString(\"100\"));\nTemplateList tList(QList Template ()   t1   t2   t3);\n\nTemplateList relabeled = TemplateList::relabel(tList, \"Class\", true);\nrelabeled.files(); // returns [[Class=1, Label=1], [Class=10, Label=10], [Class=100, Label=100]]\n\nrelabeled = TemplateList::relabel(tList, \"Class\", false);\nrelabeled.files(); // returns [[Class=1, Label=0], [Class=10, Label=1], [Class=100, Label=2]]", 
            "title": "TemplateList relabel(const TemplateList tl, const QString propName, bool preserveIntegers)"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/", 
            "text": "QList\nint\n indexProperty(const \nQString\n \npropName, \nQHash\nQString\n, int\n \nvalueMap, \nQHash\nint, \nQVariant\n \nreverseLookup) const\n\n\nConvert \nmetadata\n values associated with \npropName\n to integers. Each unique value gets its own integer. This is useful in many classification problems where nominal data (e.g \"Male\", \"Female\") needs to represented with integers (\"Male\" = 0, \"Female\" = 1). \nvalueMap\n and \nreverseLookup\n are created to allow easy conversion to the integer replacements and back.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nint\n indexProperty(const QString \npropName, QHash\nQString, int\n \nvalueMap, QHash\nint, QVariant\n \nreverseLookup) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npropName\n\n\nconst \nQString\n \n\n\nMetadata\n key\n\n\n\n\n\n\nvalueMap\n\n\nQHash\nQString\n, int\n \n\n\nA mapping from \nmetadata\n values to the equivalent unique index. \nQStrings\n are used instead of \nQVariant\n so comparison operators can be used. This is filled in by the function and can be provided empty.\n\n\n\n\n\n\nreverseLookup\n\n\nQHash\nint, \nQVariant\n \n\n\nA mapping from the unique index to the original value. This is the \nreverse\n mapping of the \nvalueMap\n. This is filled in by the function and can be provided empty.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nint\n) Returns a list of unique integers that can be mapped to the \nmetadata\n values associated with \npropName\n. The integers can be mapped to their respective values using \nvalueMap\n and the values can be mapped to the integers using \nreverseLookup\n.\n\n\n\n\nexample:\nTemplate t1, t2, t3, t4;\n\nt1.file.set(\"Key\", QString(\"Class 1\"));\nt2.file.set(\"Key\", QString(\"Class 2\"));\nt3.file.set(\"Key\", QString(\"Class 3\"));\nt4.file.set(\"Key\", QString(\"Class 1\"));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2 \n t3 \n t4);\n\nQHash\nQString, int\n valueMap;\nQHash\nint, QVariant\n reverseLookup;\ntList.indexProperty(\"Key\", valueMap, reverseLookup); // returns [0, 1, 2, 0]\nvalueMap; // returns QHash((\"Class 1\", 0)(\"Class 2\", 1)(\"Class 3\", 2))\nreverseLookup; // QHash((0, QVariant(QString, \"Class 1\")) (2, QVariant(QString, \"Class 3\")) (1, QVariant(QString, \"Class 2\")))\n\n\n\n\n\n\n\nQList\nint\n indexProperty(const \nQString\n \npropName, \nQHash\nQString\n, int\n *valueMap=NULL, \nQHash\nint, \nQVariant\n *reverseLookup=NULL) const\n\n\nShortcut to call \nindexProperty\n without \nvalueMap\n or \nreverseLookup\n arguments.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nint\n indexProperty(const QString \npropName, QHash\nQString, int\n * valueMap=NULL,QHash\nint, QVariant\n * reverseLookup = NULL) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npropName\n\n\nconst \nQString\n \n\n\nMetadata\n key\n\n\n\n\n\n\nvalueMap\n\n\nQHash\nQString\n, int\n *\n\n\n(Optional) A mapping from \nmetadata\n values to the equivalent unique index. \nQStrings\n are used instead of \nQVariant\n so comparison operators can be used. This is filled in by the function and can be provided empty.\n\n\n\n\n\n\nreverseLookup\n\n\nQHash\nint, \nQVariant\n *\n\n\n(Optional) A mapping from the unique index to the original value. This is the \nreverse\n mapping of the \nvalueMap\n. This is filled in by the function and can be provided empty.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nint\n) Returns a list of unique integers that can be mapped to the \nmetadata\n values associated with \npropName\n. The integers can be mapped to their respective values using \nvalueMap\n (if provided) and the values can be mapped to the integers using \nreverseLookup\n (if provided).\n\n\n\n\n\n\nQList\nint\n applyIndex(const \nQString\n \npropName, const \nQHash\nQString\n, int\n \nvalueMap) const\n\n\nApply a mapping to convert non-integer values to integers. \nMetadata\n values associated with \npropName\n are mapped through the given \nvalueMap\n.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\nint\n applyIndex(const QString \npropName, const QHash\nQString, int\n \nvalueMap) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npropName\n\n\nconst \nQString\n \n\n\nMetadata\n key\n\n\n\n\n\n\nvalueMap\n\n\nconst \nQHash\nQString\n, int\n \n\n\n(Optional) A mapping from \nmetadata\n values to the equivalent unique index. \nQStrings\n are used instead of \nQVariant\n so comparison operators can be used.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQlist\nint\n) Returns a list of integer values. The values are ordered in the same order as the \nTemplates\n in the list. The values are calculated like so:\n\n\n\n\nIf the value \nis\n found in the \nvalueMap\n, its integer mapping is appened to the list.\n\n\nIf the value \nis not\n found in the \nvalueMap\n, -1 is appened to the list.\n\n\n\n\n\n\n\n\nexample:\n\n\nTemplate t1, t2, t3, t4;\n\nt1.file.set(\"Key\", QString(\"Class 1\"));\nt2.file.set(\"Key\", QString(\"Class 2\"));\nt3.file.set(\"Key\", QString(\"Class 3\"));\nt4.file.set(\"Key\", QString(\"Class 1\"));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2 \n t3 \n t4);\n\nQHash\nQString, int\n valueMap;\nvalueMap.insert(\"Class 1\", 0);\nvalueMap.insert(\"Class 2\", 1);\n\ntList.applyIndex(\"Key\", valueMap); // returns [0, 1, -1, 0]\n\n\n\n\n\n\n\nT\n bytes() const\n\n\nGet the total number of bytes in the \nTemplateList\n.\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate \ntypename T\n T bytes() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nT\n) Returns the sum of the bytes in each of the \nTemplates\n in the list. \nT\n is a user specified type. It is expected to be numeric (int, float etc.)\n\n\nsee:\n \nbytes\n\n\nexample:\nTemplate t1, t2;\n\nt1.append(Mat::ones(1, 1, CV_8U)); // 1 byte\nt1.append(Mat::ones(2, 2, CV_8U)); // 4 bytes\nt2.append(Mat::ones(3, 3, CV_8U)); // 9 bytes\nt2.append(Mat::ones(4, 4, CV_8U)); // 16 bytes\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2);\ntList.bytes(); // returns 30\n\n\n\n\n\n\n\nQList\nMat\n data(int index = 0) const\n\n\nGet a list of matrices compiled from each \nTemplate\n in the list.\n\n\n\n\n\n\nfunction definition:\n\n\nQList\ncv::Mat\n data(int index = 0) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindex\n\n\nint\n\n\n(Optional) Index into each \nTemplate\n to select a \nMat\n. Default is 0.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nMat\n) Returns a list of \nMats\n. One \nMat\n is supplied by each \nTemplate\n in the image at the specified index.\n\n\n\n\nexample:\nTemplate t1, t2;\n\nt1.append(Mat::ones(1, 1, CV_8U));\nt1.append(Mat::zeros(1, 1, CV_8U));\nt2.append(Mat::ones(1, 1, CV_8U));\nt2.append(Mat::zeros(1, 1, CV_8U));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2);\ntList.data(); // returns [\"1\", \"1\"];\ntList.data(1); // returns [\"0\", \"0\"];\n\n\n\n\n\n\n\nQList\nTemplateList\n partition(const \nQList\nint\n \npartitionSizes) const\n\n\nDivide the \nTemplateList\n into a list of \nTemplateLists\n partitions.\n\n\n\n\n\n\nfunction defintion:\n\n\nQList\nTemplateList\n partition(const QList\nint\n \npartitionSizes) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npartitionSizes\n\n\nQList\nint\n\n\nA list of sizes for the partitions. The total number of partitions is equal to the length of this list. Each value in this list specifies the number of \nMats\n that should be in each template of the associated partition. The sum of values in this list \nmust\n equal the number of \nMats\n in each \nTemplate\n in the original \nTemplateList\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nTemplateList\n) Returns a \nQList\n of \nTemplateLists\n of partitions. Each partition has length equal to the number of templates in the original \nTemplateList\n. Each \nTemplate\n has length equal to the size specified in the associated value in \npartitionSizes\n.\n\n\n\n\nexample:\nTemplate t1, t2, t3;\n\nt1.append(Mat::ones(1, 1, CV_8U));\nt1.append(2*Mat::ones(1, 1, CV_8U));\nt1.append(3*Mat::ones(1, 1, CV_8U));\n\nt2.append(4*Mat::ones(1, 1, CV_8U));\nt2.append(5*Mat::ones(1, 1, CV_8U));\nt2.append(6*Mat::ones(1, 1, CV_8U));\n\nt3.append(7*Mat::ones(1, 1, CV_8U));\nt3.append(8*Mat::ones(1, 1, CV_8U));\nt3.append(9*Mat::ones(1, 1, CV_8U));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2 \n t3);\n\nQList\nTemplateList\n partitions = tList.partition(QList\nint\n() \n 1 \n 2); // split into 2 partitions. 1 with 1 Mat and 1 with 2 Mats.\n\npartitions[0]; // returns [(\"1\"), (\"4\"), (\"7\")]\npartitions[1]; // returns [(\"2\", \"3\"), (\"5\", \"6\"), (\"8\", \"9\")]\n\n\n\n\n\n\n\nFileList\n files() const\n\n\nGet a list of all the \nFiles\n in the \nTemplateList\n\n\n\n\n\n\nfunction definition:\n\n\nFileList files() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nFileList\n) Returns a \nFileList\n with the \nfile\n of each \nTemplate\n in the \nTemplateList\n.\n\n\nexample:\nTemplate t1(\"picture1.jpg\"), t2(\"picture2.jpg\");\n\nt1.file.set(\"Key\", QVariant::fromValue\nfloat\n(1));\nt2.file.set(\"Key\", QVariant::fromValue\nfloat\n(2));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2);\n\ntList.files(); // returns [\"picture1.jpg[Key=1]\", \"picture2.jpg[Key=2]\"]\n\n\n\n\n\n\n\nFileList\n operator()()\n\n\nShortcut call to \nfiles\n\n\n\n\n\n\nfunction definition:\n\n\nFileList operator()() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nFileList\n) Returns a \nFileList\n with the \nfile\n of each \nTemplate\n in the \nTemplateList\n.\n\n\nexample:\nTemplate t1(\"picture1.jpg\"), t2(\"picture2.jpg\");\n\nt1.file.set(\"Key\", QVariant::fromValue\nfloat\n(1));\nt2.file.set(\"Key\", QVariant::fromValue\nfloat\n(2));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2);\n\ntList.files(); // returns [\"picture1.jpg[Key=1]\", \"picture2.jpg[Key=2]\"]\n\n\n\n\n\n\n\nQMap\nT, int\n countValues(const \nQString\n \npropName, bool excludeFailures = false) const\n\n\nGet the frequency of each unique value associated with a provided \nmetadata\n key.\n\n\n\n\nfunction definition:\n\n\n\n\ntemplate\n QMap\n countValues(const QString \npropName, bool excludeFailures = false) const\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npropName\n\n\nconst \nQString\n \n\n\nMetadata\n key\n\n\n\n\n\n\nexcludeFailures\n\n\nbool\n\n\n(Optional) Exclude \nFile\n \nmetadata\n if the \nFile\n has \nfte\n equal to true. Default is false\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQMap\nT, int\n) Returns a mapping between unique \nmetadata\n and their frequency.\n\n\n\n\nexample:\nTemplate t1, t2, t3, t4;\n\nt1.file.set(\"Key\", QString(\"Class 1\"));\nt2.file.set(\"Key\", QString(\"Class 2\"));\nt3.file.set(\"Key\", QString(\"Class 3\"));\nt4.file.set(\"Key\", QString(\"Class 1\"));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2 \n t3 \n t4);\n\ntList.countValues\nQString\n(\"Key\"); // returns QMap((\"Class 1\", 2), (\"Class 2\", 1), (\"Class 3\", 1))\n\n\n\n\n\n\n\nTemplateList\n reduced() const\n\n\nReduce the \nTemplates\n in the \nTemplateList\n by merging them together.\n\n\n\n\n\n\nfunction definition:\n\n\nTemplateList reduced() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nTemplateList\n) Returns a \nTemplateList\n with a single \nTemplate\n. The \nTemplate\n is the result of calling \nmerge\n on every \nTemplate\n.\n\n\nsee:\n \nmerge\n\n\nexample:\nTemplate t1(\"picture1.jpg\"), t2(\"picture2.jpg\");\n\nt1.file.set(\"Key1\", QString(\"Value1\"));\nt2.file.set(\"Key2\", QString(\"Value2\"));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2);\n\nTemplateList reduced = tList.reduced();\nreduced.size(); // returns 1\nreduced.files(); // returns [\"picture1.jpg;picture2.jpg[Key1=Value1, Key2=Value2, separator=;]\"]\n\n\n\n\n\n\n\nQList\nint\n find(const \nQString\n \nkey, const T \nvalue)\n\n\nGet the indices of every \nTemplate\n that has a provided key value pairing in its \nmetadata\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate\ntypename T\n QList\nint\n find(const QString \nkey, const \ntt\nT\n/tt\n \nvalue)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nMetadata\n key to search for\n\n\n\n\n\n\nvalue\n\n\nconst \nT\n \n\n\nValue to search for. Both the \nkey\n and value must match. \nT\n is a user specified type.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nint\n) Returns a list of indices for \nTemplates\n that contained the key-value pairing in their \nmetadata\n\n\n\n\nexample:\nTemplate t1, t2, t3;\n\nt1.file.set(\"Key\", QString(\"Value1\"));\nt2.file.set(\"Key\", QString(\"Value2\"));\nt3.file.set(\"Key\", QString(\"Value2\"));\n\nTemplateList tList(QList\nTemplate\n() \n t1 \n t2 \n t3);\ntList.find\nQString\n(\"Key\", \"Value2\"); // returns [1, 2]", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#indexproperty-1", 
            "text": "Convert  metadata  values associated with  propName  to integers. Each unique value gets its own integer. This is useful in many classification problems where nominal data (e.g \"Male\", \"Female\") needs to represented with integers (\"Male\" = 0, \"Female\" = 1).  valueMap  and  reverseLookup  are created to allow easy conversion to the integer replacements and back.    function definition:  QList int  indexProperty(const QString  propName, QHash QString, int   valueMap, QHash int, QVariant   reverseLookup) const    parameters:     Parameter  Type  Description      propName  const  QString    Metadata  key    valueMap  QHash QString , int    A mapping from  metadata  values to the equivalent unique index.  QStrings  are used instead of  QVariant  so comparison operators can be used. This is filled in by the function and can be provided empty.    reverseLookup  QHash int,  QVariant    A mapping from the unique index to the original value. This is the  reverse  mapping of the  valueMap . This is filled in by the function and can be provided empty.       output:  ( QList int ) Returns a list of unique integers that can be mapped to the  metadata  values associated with  propName . The integers can be mapped to their respective values using  valueMap  and the values can be mapped to the integers using  reverseLookup .   example: Template t1, t2, t3, t4;\n\nt1.file.set(\"Key\", QString(\"Class 1\"));\nt2.file.set(\"Key\", QString(\"Class 2\"));\nt3.file.set(\"Key\", QString(\"Class 3\"));\nt4.file.set(\"Key\", QString(\"Class 1\"));\n\nTemplateList tList(QList Template ()   t1   t2   t3   t4);\n\nQHash QString, int  valueMap;\nQHash int, QVariant  reverseLookup;\ntList.indexProperty(\"Key\", valueMap, reverseLookup); // returns [0, 1, 2, 0]\nvalueMap; // returns QHash((\"Class 1\", 0)(\"Class 2\", 1)(\"Class 3\", 2))\nreverseLookup; // QHash((0, QVariant(QString, \"Class 1\")) (2, QVariant(QString, \"Class 3\")) (1, QVariant(QString, \"Class 2\")))", 
            "title": "QListint indexProperty(const QString propName, QHashQString, int valueMap, QHashint, QVariant reverseLookup) const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#indexproperty-2", 
            "text": "Shortcut to call  indexProperty  without  valueMap  or  reverseLookup  arguments.    function definition:  QList int  indexProperty(const QString  propName, QHash QString, int  * valueMap=NULL,QHash int, QVariant  * reverseLookup = NULL) const    parameters:     Parameter  Type  Description      propName  const  QString    Metadata  key    valueMap  QHash QString , int  *  (Optional) A mapping from  metadata  values to the equivalent unique index.  QStrings  are used instead of  QVariant  so comparison operators can be used. This is filled in by the function and can be provided empty.    reverseLookup  QHash int,  QVariant  *  (Optional) A mapping from the unique index to the original value. This is the  reverse  mapping of the  valueMap . This is filled in by the function and can be provided empty.       output:  ( QList int ) Returns a list of unique integers that can be mapped to the  metadata  values associated with  propName . The integers can be mapped to their respective values using  valueMap  (if provided) and the values can be mapped to the integers using  reverseLookup  (if provided).", 
            "title": "QListint indexProperty(const QString propName, QHashQString, int *valueMap=NULL, QHashint, QVariant *reverseLookup=NULL) const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#applyindex", 
            "text": "Apply a mapping to convert non-integer values to integers.  Metadata  values associated with  propName  are mapped through the given  valueMap .    function definition:  QList int  applyIndex(const QString  propName, const QHash QString, int   valueMap) const    parameters:     Parameter  Type  Description      propName  const  QString    Metadata  key    valueMap  const  QHash QString , int    (Optional) A mapping from  metadata  values to the equivalent unique index.  QStrings  are used instead of  QVariant  so comparison operators can be used.       output:  ( Qlist int ) Returns a list of integer values. The values are ordered in the same order as the  Templates  in the list. The values are calculated like so:   If the value  is  found in the  valueMap , its integer mapping is appened to the list.  If the value  is not  found in the  valueMap , -1 is appened to the list.     example:  Template t1, t2, t3, t4;\n\nt1.file.set(\"Key\", QString(\"Class 1\"));\nt2.file.set(\"Key\", QString(\"Class 2\"));\nt3.file.set(\"Key\", QString(\"Class 3\"));\nt4.file.set(\"Key\", QString(\"Class 1\"));\n\nTemplateList tList(QList Template ()   t1   t2   t3   t4);\n\nQHash QString, int  valueMap;\nvalueMap.insert(\"Class 1\", 0);\nvalueMap.insert(\"Class 2\", 1);\n\ntList.applyIndex(\"Key\", valueMap); // returns [0, 1, -1, 0]", 
            "title": "QListint applyIndex(const QString propName, const QHashQString, int valueMap) const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#bytes", 
            "text": "Get the total number of bytes in the  TemplateList .    function definition:  template  typename T  T bytes() const    parameters:  NONE   output:  ( T ) Returns the sum of the bytes in each of the  Templates  in the list.  T  is a user specified type. It is expected to be numeric (int, float etc.)  see:   bytes  example: Template t1, t2;\n\nt1.append(Mat::ones(1, 1, CV_8U)); // 1 byte\nt1.append(Mat::ones(2, 2, CV_8U)); // 4 bytes\nt2.append(Mat::ones(3, 3, CV_8U)); // 9 bytes\nt2.append(Mat::ones(4, 4, CV_8U)); // 16 bytes\n\nTemplateList tList(QList Template ()   t1   t2);\ntList.bytes(); // returns 30", 
            "title": "T bytes() const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#data", 
            "text": "Get a list of matrices compiled from each  Template  in the list.    function definition:  QList cv::Mat  data(int index = 0) const    parameters:     Parameter  Type  Description      index  int  (Optional) Index into each  Template  to select a  Mat . Default is 0.       output:  ( QList Mat ) Returns a list of  Mats . One  Mat  is supplied by each  Template  in the image at the specified index.   example: Template t1, t2;\n\nt1.append(Mat::ones(1, 1, CV_8U));\nt1.append(Mat::zeros(1, 1, CV_8U));\nt2.append(Mat::ones(1, 1, CV_8U));\nt2.append(Mat::zeros(1, 1, CV_8U));\n\nTemplateList tList(QList Template ()   t1   t2);\ntList.data(); // returns [\"1\", \"1\"];\ntList.data(1); // returns [\"0\", \"0\"];", 
            "title": "QListMat data(int index = 0) const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#partition", 
            "text": "Divide the  TemplateList  into a list of  TemplateLists  partitions.    function defintion:  QList TemplateList  partition(const QList int   partitionSizes) const    parameters:     Parameter  Type  Description      partitionSizes  QList int  A list of sizes for the partitions. The total number of partitions is equal to the length of this list. Each value in this list specifies the number of  Mats  that should be in each template of the associated partition. The sum of values in this list  must  equal the number of  Mats  in each  Template  in the original  TemplateList .       output:  ( QList TemplateList ) Returns a  QList  of  TemplateLists  of partitions. Each partition has length equal to the number of templates in the original  TemplateList . Each  Template  has length equal to the size specified in the associated value in  partitionSizes .   example: Template t1, t2, t3;\n\nt1.append(Mat::ones(1, 1, CV_8U));\nt1.append(2*Mat::ones(1, 1, CV_8U));\nt1.append(3*Mat::ones(1, 1, CV_8U));\n\nt2.append(4*Mat::ones(1, 1, CV_8U));\nt2.append(5*Mat::ones(1, 1, CV_8U));\nt2.append(6*Mat::ones(1, 1, CV_8U));\n\nt3.append(7*Mat::ones(1, 1, CV_8U));\nt3.append(8*Mat::ones(1, 1, CV_8U));\nt3.append(9*Mat::ones(1, 1, CV_8U));\n\nTemplateList tList(QList Template ()   t1   t2   t3);\n\nQList TemplateList  partitions = tList.partition(QList int ()   1   2); // split into 2 partitions. 1 with 1 Mat and 1 with 2 Mats.\n\npartitions[0]; // returns [(\"1\"), (\"4\"), (\"7\")]\npartitions[1]; // returns [(\"2\", \"3\"), (\"5\", \"6\"), (\"8\", \"9\")]", 
            "title": "QListTemplateList partition(const QListint partitionSizes) const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#files", 
            "text": "Get a list of all the  Files  in the  TemplateList    function definition:  FileList files() const    parameters:  NONE   output:  ( FileList ) Returns a  FileList  with the  file  of each  Template  in the  TemplateList .  example: Template t1(\"picture1.jpg\"), t2(\"picture2.jpg\");\n\nt1.file.set(\"Key\", QVariant::fromValue float (1));\nt2.file.set(\"Key\", QVariant::fromValue float (2));\n\nTemplateList tList(QList Template ()   t1   t2);\n\ntList.files(); // returns [\"picture1.jpg[Key=1]\", \"picture2.jpg[Key=2]\"]", 
            "title": "FileList files() const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#operator-pp", 
            "text": "Shortcut call to  files    function definition:  FileList operator()() const    parameters:  NONE   output:  ( FileList ) Returns a  FileList  with the  file  of each  Template  in the  TemplateList .  example: Template t1(\"picture1.jpg\"), t2(\"picture2.jpg\");\n\nt1.file.set(\"Key\", QVariant::fromValue float (1));\nt2.file.set(\"Key\", QVariant::fromValue float (2));\n\nTemplateList tList(QList Template ()   t1   t2);\n\ntList.files(); // returns [\"picture1.jpg[Key=1]\", \"picture2.jpg[Key=2]\"]", 
            "title": "FileList operator()()"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#countvalues", 
            "text": "Get the frequency of each unique value associated with a provided  metadata  key.   function definition:   template  QMap  countValues(const QString  propName, bool excludeFailures = false) const    parameters:     Parameter  Type  Description      propName  const  QString    Metadata  key    excludeFailures  bool  (Optional) Exclude  File   metadata  if the  File  has  fte  equal to true. Default is false       output:  ( QMap T, int ) Returns a mapping between unique  metadata  and their frequency.   example: Template t1, t2, t3, t4;\n\nt1.file.set(\"Key\", QString(\"Class 1\"));\nt2.file.set(\"Key\", QString(\"Class 2\"));\nt3.file.set(\"Key\", QString(\"Class 3\"));\nt4.file.set(\"Key\", QString(\"Class 1\"));\n\nTemplateList tList(QList Template ()   t1   t2   t3   t4);\n\ntList.countValues QString (\"Key\"); // returns QMap((\"Class 1\", 2), (\"Class 2\", 1), (\"Class 3\", 1))", 
            "title": "QMapT, int countValues(const QString propName, bool excludeFailures = false) const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#reduced", 
            "text": "Reduce the  Templates  in the  TemplateList  by merging them together.    function definition:  TemplateList reduced() const    parameters:  NONE   output:  ( TemplateList ) Returns a  TemplateList  with a single  Template . The  Template  is the result of calling  merge  on every  Template .  see:   merge  example: Template t1(\"picture1.jpg\"), t2(\"picture2.jpg\");\n\nt1.file.set(\"Key1\", QString(\"Value1\"));\nt2.file.set(\"Key2\", QString(\"Value2\"));\n\nTemplateList tList(QList Template ()   t1   t2);\n\nTemplateList reduced = tList.reduced();\nreduced.size(); // returns 1\nreduced.files(); // returns [\"picture1.jpg;picture2.jpg[Key1=Value1, Key2=Value2, separator=;]\"]", 
            "title": "TemplateList reduced() const"
        }, 
        {
            "location": "/api_docs/cpp_api/templatelist/functions/#find", 
            "text": "Get the indices of every  Template  that has a provided key value pairing in its  metadata    function definition:  template typename T  QList int  find(const QString  key, const  tt T /tt   value)    parameters:     Parameter  Type  Description      key  const  QString    Metadata  key to search for    value  const  T    Value to search for. Both the  key  and value must match.  T  is a user specified type.       output:  ( QList int ) Returns a list of indices for  Templates  that contained the key-value pairing in their  metadata   example: Template t1, t2, t3;\n\nt1.file.set(\"Key\", QString(\"Value1\"));\nt2.file.set(\"Key\", QString(\"Value2\"));\nt3.file.set(\"Key\", QString(\"Value2\"));\n\nTemplateList tList(QList Template ()   t1   t2   t3);\ntList.find QString (\"Key\", \"Value2\"); // returns [1, 2]", 
            "title": "QListint find(const QString key, const T value)"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/factory/", 
            "text": "For the run time construction of objects from strings.\n\n\nSee:\n\n\n\n\nMembers\n\n\nConstructors\n\n\nMacros\n\n\nStatic Functions\n\n\n\n\nUses the Industrial Strength Pluggable Factory model described \nhere\n.\n\n\nOpenBR's plugin architecture is premised on the idea that algorithms can be described as strings and can be built at runtime. Constructing plugins from strings is the job of the \nFactory\n. For a plugin to be built by the \nFactory\n it must inherit from \nObject\n. It also must be registered with the factory at compile time using \nBR_REGISTER\n. At runtime, the \nFactory\n will look up provided strings in its \nregistry\n and, if they exist, return the described plugins.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nregistry\n\n\nstatic \nQMap\nQString\n,\nFactory\nT\n*\n\n\nList of all objects that have been registered with the factory. Registered objects are stored in this static registry by abstraction type.", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/constructors/", 
            "text": "Constructor \\\n\n\nDestructor\n\n\n\n\n\n\n\n\n\n\nFactory(\nQString\n name)\n\n\nThis is a special constructor in OpenBR. It is used to register new objects in the \nregistry\n.\n\n\n\n\n\n\nvirtual ~Factory()\n\n\nDefault destructor", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/macros/", 
            "text": "BR_REGISTER\n\n\nA special macro to register plugins in the \nFactory\n::\nregistry\n. When a plugin is registered the associated abstraction type will be removed from it's name, if it exists. For example, \nBR_REGISTER(Transform, ExampleTransform)\n will be registered as \"Example\". Plugins \ndo not\n have to have the abstraction as part of their name.\n\n\n\n\n\n\nmacro definition:\n\n\n#define BR_REGISTER(ABSTRACTION,IMPLEMENTATION)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nABSTRACTION\n\n\nThe Abstraction that the object inherits from. The object must inherit from \nObject\n somewhere in its inheritance tree. Abstractions should also implement \nABSTRACTION *make()\n. See \nTransform\n as an example of an abstraction.\n\n\n\n\n\n\nIMPLEMENTATION\n\n\nThe Implementation of the object. This is the definition of the object you want returned when you call \nFactory\nT\n::make\n.\n\n\n\n\n\n\n\n\n\n\n\n\nexample:\n\n\nclass Implementation : public Abstraction\n{\n    Q_OBJECT\n\n    ... // some functions etc.\n};\n\nBR_REGISTER(Abstraction, Implementation)", 
            "title": "Macros"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/macros/#br_register", 
            "text": "A special macro to register plugins in the  Factory :: registry . When a plugin is registered the associated abstraction type will be removed from it's name, if it exists. For example,  BR_REGISTER(Transform, ExampleTransform)  will be registered as \"Example\". Plugins  do not  have to have the abstraction as part of their name.    macro definition:  #define BR_REGISTER(ABSTRACTION,IMPLEMENTATION)    parameters:     Parameter  Description      ABSTRACTION  The Abstraction that the object inherits from. The object must inherit from  Object  somewhere in its inheritance tree. Abstractions should also implement  ABSTRACTION *make() . See  Transform  as an example of an abstraction.    IMPLEMENTATION  The Implementation of the object. This is the definition of the object you want returned when you call  Factory T ::make .       example:  class Implementation : public Abstraction\n{\n    Q_OBJECT\n\n    ... // some functions etc.\n};\n\nBR_REGISTER(Abstraction, Implementation)", 
            "title": "BR_REGISTER"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/statics/", 
            "text": "T\n *make(const \nFile\n \nfile)\n\n\nThis function constructs a plugin of type \nT\n from a provided \nFile\n. The \nFile\n \nname\n must already be in the \nregistry\n to be made.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic T *make(const File \nfile)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nconst \nFile\n \n\n\nFile describing the object to be constructed\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nT\n) Returns an object of type \nT\n. \nT\n must inherit from \nObject\n.\n\n\n\n\nexample:\nTransform *transform = Factory\nTransform\n::make(\"ExampleTransform(Property1=Value1,Property2=Value2)\");\n// returns a pointer to an instance of ExampleTransform with property1 set to value1\n// and property2 set to value 2.\n\n\n\n\n\n\n\nQList\nQSharedPointer\nT\nmakeAll\n\n\nMake all of the registered plugins for a specific abstraction.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QList\n QSharedPointer\nT\n \n makeAll()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQList\nQSharedPointer\nT\n) Returns a list of all of the objects registered to a particular abstraction \nT\n\n\nexample:\nBR_REGISTER(Transform, FirstTransform)\nBR_REGISTER(Transform, SecondTransform)\n\nQList\nQSharedPointer\nTransform\n \n = Factory\nTransform\n::makeAll(); // returns a list with pointers to FirstTransform and SecondTransform\n\n\n\n\n\n\n\nQStringList\n names()\n\n\nGet the names of all of the registered objects for a specific abstraction.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QStringList names()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQStringList\n) Returns a list of object names from the \nregistry\n\n\nexample:\nBR_REGISTER(Transform, FirstTransform)\nBR_REGISTER(Transform, SecondTransform)\n\nQStringList names = Factory\nTransform\n::names(); // returns [\"First\", \"Second\"]\n\n\n\n\n\n\n\nQString\n parameters(const \nQString\n \nname)\n\n\nGet the parameters for the plugin defined by the provided name.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QString parameters(const QString \nname)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nconst \nQString\n \n\n\nName of a plugin\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQString\n) Returns a string with each property and its value seperated by commas.\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nFactory\nTransform\n::parameters(\"Example\"); // returns \"int property1 = 1, float property2 = 2.5, QString property3 = Value\"\nFactory\nTransform\n::parameters(\"Example(property3=NewValue)\"); // returns \"int property1 = 1, float property2 = 2.5, QString property3 = NewValue\"", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/statics/#make", 
            "text": "This function constructs a plugin of type  T  from a provided  File . The  File   name  must already be in the  registry  to be made.    function definition:  static T *make(const File  file)    parameters:     Parameter  Type  Description      file  const  File    File describing the object to be constructed       output:  ( T ) Returns an object of type  T .  T  must inherit from  Object .   example: Transform *transform = Factory Transform ::make(\"ExampleTransform(Property1=Value1,Property2=Value2)\");\n// returns a pointer to an instance of ExampleTransform with property1 set to value1\n// and property2 set to value 2.", 
            "title": "T *make(const File file)"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/statics/#makeall", 
            "text": "Make all of the registered plugins for a specific abstraction.    function definition:  static QList  QSharedPointer T    makeAll()    parameters:  NONE   output:  ( QList QSharedPointer T ) Returns a list of all of the objects registered to a particular abstraction  T  example: BR_REGISTER(Transform, FirstTransform)\nBR_REGISTER(Transform, SecondTransform)\n\nQList QSharedPointer Transform    = Factory Transform ::makeAll(); // returns a list with pointers to FirstTransform and SecondTransform", 
            "title": "QListQSharedPointerTmakeAll"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/statics/#names", 
            "text": "Get the names of all of the registered objects for a specific abstraction.    function definition:  static QStringList names()    parameters:  NONE   output:  ( QStringList ) Returns a list of object names from the  registry  example: BR_REGISTER(Transform, FirstTransform)\nBR_REGISTER(Transform, SecondTransform)\n\nQStringList names = Factory Transform ::names(); // returns [\"First\", \"Second\"]", 
            "title": "QStringList names()"
        }, 
        {
            "location": "/api_docs/cpp_api/factory/statics/#parameters", 
            "text": "Get the parameters for the plugin defined by the provided name.    function definition:  static QString parameters(const QString  name)    parameters:     Parameter  Type  Description      name  const  QString    Name of a plugin       output:  ( QString ) Returns a string with each property and its value seperated by commas.   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nFactory Transform ::parameters(\"Example\"); // returns \"int property1 = 1, float property2 = 2.5, QString property3 = Value\"\nFactory Transform ::parameters(\"Example(property3=NewValue)\"); // returns \"int property1 = 1, float property2 = 2.5, QString property3 = NewValue\"", 
            "title": "QString parameters(const QString name)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/object/", 
            "text": "Inherits from \nQObject\n\n\nSee:\n\n\n\n\nMembers\n\n\nMacros\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nThis is the base class of all OpenBR plugins. \nObjects\n are constructed from \nFiles\n. The \nFile's\n \nname\n specifies which plugin to construct and the \nFile's\n \nmetadata\n provides initialization values for the plugin's properties.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/object/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nFile\n\n\nThe \nFile\n used to construct the plugin.\n\n\n\n\n\n\nfirstAvailablePropertyIdx\n\n\nint\n\n\nIndex of the first property of the object that can be set via command line arguments", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/object/macros/", 
            "text": "BR_PROPERTY\n\n\nThis macro provides an extension to the \nQt Property System\n. It's purpose is to set default values for each property in an object. Every call to \nBR_PROPERTY\n should have a corresponding call to \nQ_PROPERTY\n.\n\n\n\n\n\n\nmacro definition:\n\n\n#define BR_PROPERTY(TYPE,NAME,DEFAULT)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTYPE\n\n\nThe type of the property (int, float etc.)\n\n\n\n\n\n\nNAME\n\n\nThe name of the property\n\n\n\n\n\n\nDEFAULT\n\n\nThe default value of the property\n\n\n\n\n\n\n\n\n\n\n\n\nexample:\n\n\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1) // sets default value of \"property1\" to 1\n    BR_PROPERTY(float, property2, 2.5) // sets default value of \"property2\" to 2.5\n    BR_PROPERTY(QString, property3, \"Value\") // sets default value of \"property3\" to \"Value\"\n\n    ...\n};", 
            "title": "Macros"
        }, 
        {
            "location": "/api_docs/cpp_api/object/macros/#br_property", 
            "text": "This macro provides an extension to the  Qt Property System . It's purpose is to set default values for each property in an object. Every call to  BR_PROPERTY  should have a corresponding call to  Q_PROPERTY .    macro definition:  #define BR_PROPERTY(TYPE,NAME,DEFAULT)    parameters:     Parameter  Description      TYPE  The type of the property (int, float etc.)    NAME  The name of the property    DEFAULT  The default value of the property       example:  class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1) // sets default value of \"property1\" to 1\n    BR_PROPERTY(float, property2, 2.5) // sets default value of \"property2\" to 2.5\n    BR_PROPERTY(QString, property3, \"Value\") // sets default value of \"property3\" to \"Value\"\n\n    ...\n};", 
            "title": "BR_PROPERTY"
        }, 
        {
            "location": "/api_docs/cpp_api/object/statics/", 
            "text": "QStringList\n parse(const \nQString\n \nstring, char split = ',')\n\n\nSplit the provided string using the provided split character. Lexical scoping of \n()\n, \n[]\n, \n\\\n>\n, and \n{}\n is respected.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QStringList parse(const QString \nstring, char split = ',');\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstring\n\n\nconst \nQString\n \n\n\nString to be split\n\n\n\n\n\n\nsplit\n\n\nchar\n\n\n(Optional) The character to split the string on. Default is ','\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQStringList\n) Returns a list of the split strings\n\n\n\n\nexample:\nObject::parse(\"Transform1(p1=v1,p2=v2),Transform2(p1=v3,p2=v4)\"); // returns [\"Transform1(p1=v1,p2=v2)\", \"Transform2(p1=v3,p2=v4)\"]", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/object/statics/#parse", 
            "text": "Split the provided string using the provided split character. Lexical scoping of  () ,  [] ,  \\ > , and  {}  is respected.    function definition:  static QStringList parse(const QString  string, char split = ',');    parameters:     Parameter  Type  Description      string  const  QString    String to be split    split  char  (Optional) The character to split the string on. Default is ','       output:  ( QStringList ) Returns a list of the split strings   example: Object::parse(\"Transform1(p1=v1,p2=v2),Transform2(p1=v3,p2=v4)\"); // returns [\"Transform1(p1=v1,p2=v2)\", \"Transform2(p1=v3,p2=v4)\"]", 
            "title": "QStringList parse(const QString string, char split = ',')"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/", 
            "text": "void init()\n\n\nThis is a virtual function. It is meant to be overloaded by derived classes if they need to initialize internal variables. The default constructor of derived objects should \nnever\n be overloaded.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void init()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid store(\nQDataStream\n \nstream)\n\n\nThis is a virtual function. Serialize an object to a \nQDataStream\n. The default implementation serializes each property and its value to disk.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void store(QDataStream \nstream) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n \n\n\nStream to store serialized data\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nvoid load(\nQDataStream\n \nstream)\n\n\nThis is a virtual function. Deserialize an item from a \nQDataStream\n. Elements can be deserialized in the same order in which they were serialized. The default implementation deserializes a value for each property and then calls \ninit\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void load(QDataStream \nstream);\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n \n\n\nStream to deserialize data from\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nvoid serialize(\nQDataStream\n \nstream)\n\n\nThis is a virtual function. Serialize an entire plugin to a \nQDataStream\n. This function is larger in scope then \nstore\n. It stores the string describing the plugin and then calls \nstore\n to serialize its parameters. This has the benefit of being able to deserialize an entire plugin (or series of plugins) from a stored model file.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void serialize(QDataStream \nstream) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n \n\n\nStream to store serialized data\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\n\n\nQStringList\n parameters()\n\n\nGet a string describing the parameters of the object\n\n\n\n\n\n\nfunction definition:\n\n\nQStringList parameters() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQStringList\n) Returns a list of the parameters to a function\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nFactory\nTransform\n::make(\".Example\")-\nparameters(); // returns [\"int property1 = 1\", \"float property2 = 2.5\", \"QString property3 = Value\"]\n\n\n\n\n\n\n\n\n\nQStringList\n prunedArguments(bool expanded = false)\n\n\nGet a string describing the user-specified parameters of the object. This means that parameters using their default value are not returned.\n\n\n\n\n\n\nfunction definition:\n\n\nQStringList prunedArguments(bool expanded = false) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexpanded\n\n\nbool\n\n\n(Optional) If true, expand all abbreviations or model files into their full description strings. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQStringList\n) Returns a list of all of the user specified parameters of the object\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nFactory\nTransform\n::make(\".Example\")-\nprunedArguments(); // returns []\nFactory\nTransform\n::make(\".Example(property1=10)\")-\nprunedArguments(); // returns [\"property1=10\"]\nFactory\nTransform\n::make(\".Example(property1=10,property3=NewValue)\")-\nprunedArguments(); // returns [\"property1=10\", \"property3=NewValue\"]\n\n\n\n\n\n\n\n\n\nQString\n argument(int index, bool expanded)\n\n\nGet a string value of the argument at a provided index. An index of 0 returns the name of the object.\n\n\n\n\n\n\nfunction definition:\n\n\nQString argument(int index, bool expanded) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindex\n\n\nint\n\n\nIndex of the parameter to look up\n\n\n\n\n\n\nexpanded\n\n\nbool\n\n\nIf true, expand all abbreviations or model files into their full description strings.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQString\n) Returns a string value for the lookup argument\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nFactory\nTransform\n::make(\".Example\")-\nargument(0, false); // returns \"Example\"\nFactory\nTransform\n::make(\".Example\")-\nargument(1, false); // returns \"1\"\nFactory\nTransform\n::make(\".Example\")-\nargument(2, false); // returns \"2.5\"\n\n\n\n\n\n\n\n\n\nQString\n description(bool expanded = false)\n\n\nThis is a virtual function. Get a description of the object. The description includes the name and any user-defined parameters of the object. Parameters that retain their default value are not included.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual QString description(bool expanded = false) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexpanded\n\n\nbool\n\n\n(Optional) If true, expand all abbreviations or model files into their full description strings. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQString\n) Returns a string describing the object\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nFactory\nTransform\n::make(\".Example\")-\ndescription(); // returns \"Example\"\nqDebug() \n Factory\nTransform\n::make(\".Example(property3=NewValue)\")-\ndescription(); // returns \"Example(property3=NewValue)\"\n\n\n\n\n\n\n\n\n\nvoid setProperty(const \nQString\n \nname, \nQVariant\n value)\n\n\nSet a property with a provided name to a provided value. This function overloads \nQObject\n::setProperty so that it can handle OpenBR data types. If the provided name is not a property of the object nothing happens. If the provided name is a property but the provided value is not a valid type an error is thrown.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid setProperty(const QString \nname, QVariant value)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nconst \nQString\n \n\n\nName of the property to set\n\n\n\n\n\n\nvalue\n\n\nQVariant\n\n\nValue to set the property to\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nsetPropertyRecursive\n, \nsetExistingProperty\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nQScopedPointer\nTransform\n transform(Factory\nTransform\n::make(\".Example\"));\ntransform-\nparameters(); // returns [\"int property1 = 1\", \"float property2 = 2.5\", \"QString property3 = Value\"]\n\ntransform-\nsetProperty(\"property1\", QVariant::fromValue\nint\n(10));\ntransform-\nparameters(); // returns [\"int property1 = 10\", \"float property2 = 2.5\", \"QString property3 = Value\"]\n\ntransform-\nsetProperty(\"property1\", QVariant::fromValue\nQString\n(\"Value\")); // ERROR: incorrect type\n\n\n\n\n\n\n\n\n\nbool setPropertyRecursive(const \nQString\n \nname, \nQVariant\n value)\n\n\nSet a property of the object or the object's children to a provided value. The recursion is only single level; the children of the the objects children will not be affected. Only the first property found is set. This means that if a parent and a child have the same property only the parent's property is set.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual bool setPropertyRecursive(const QString \nname, QVariant value)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nconst \nQString\n \n\n\nName of the property to set\n\n\n\n\n\n\nvalue\n\n\nQVariant\n\n\nValue to set the property to\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the property is set in either the object or its children\n\n\n\n\nsee:\n \nsetProperty\n, \nsetExistingProperty\n, \ngetChildren\n\n\nexample:\nclass ChildTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    BR_PROPERTY(int, property1, 2)\n    BR_PROPERTY(int, property2, 2.5)\n\n    ...\n};\n\nBR_REGISTER(Transform, ChildTransform)\n\nclass ParentTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(br::Transform *child READ get_child WRITE set_child RESET reset_child STORED false)\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    BR_PROPERTY(br::Transform*, child, Factory\nTransform\n::make(\".Child\"))\n    BR_PROPERTY(int, property1, 1)\n\n    ...\n};\n\nQScopedPointer\nTransform\n parent(Factory\nTransform\n::make(\".Parent\"));\nparent-\nparameters(); // returns [\"br::Transform* child = \", \"int property1 = 1\"]\nparent-\ngetChildren\nTransform\n().first()-\nparameters(); // returns [\"int property1 = 2\", \"float property2 = 2\"]\n\nparent-\nsetPropertyRecursive(\"property1\", QVariant::fromValue\nint\n(10));\nparent-\nparameters(); // returns [\"br::Transform* child = \", \"int property1 = 10\"]\nparent-\ngetChildren\nTransform\n().first()-\nparameters(); // returns [\"int property1 = 2\", \"float property2 = 2\"]\n\nparent-\nsetPropertyRecursive(\"property2\", QVariant::fromValue\nfloat\n(10.5));\nparent-\nparameters(); // returns [\"br::Transform* child = \", \"int property1 = 10\"]\nparent-\ngetChildren\nTransform\n().first()-\nparameters(); // returns [\"int property1 = 2\", \"float property2 = 10\"]\n\n\n\n\n\n\n\n\n\nbool setExistingProperty(const \nQString\n \nname, \nQVariant\n value)\n\n\nAttempt to set a property to a provided value. If the provided value is not a valid type for the given property an error is thrown.\n\n\n\n\n\n\nfunction definition:\n\n\nbool setExistingProperty(const QString \nname, QVariant value)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nconst \nQString\n \n\n\nName of the property to set\n\n\n\n\n\n\nvalue\n\n\nQVariant\n\n\nValue to set the property to\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the provided property exists and can be set to the provided value, otherwise returns false\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    BR_PROPERTY(int, property1, 2)\n    BR_PROPERTY(int, property2, 2.5)\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nQScopedPointer\nTransform\n transform(Factory\nTransform\n::make(\".Child\"));\ntransform-\nsetExistingProperty(\"property1\", QVariant::fromValue\nint\n(10)); // returns true\ntransform-\nparameters(); // returns [\"int property1 = 10\", \"float property2 = 2\"]\n\ntransform-\nsetExistingProperty(\"property3\", QVariant::fromValue\nint\n(10)); // returns false\ntransform-\nsetExistingProperty(\"property1\", QVariant::fromValue\nQString\n(\"Hello\")); // ERROR: incorrect type\n\n\n\n\n\n\n\n\n\nQList\nObject\n *\n getChildren()\n\n\nThis is a virtual function. Get all of the children of the object. The default implementation looks for children in the properties of the object. A derived object should overload this function if it needs to provide children from a different source.\n\n\n\n\nfunction definition:\nvirtual QList\nObject *\n getChildren() const\n\n\n\n\n\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\noutput:\n (\nQList\nObject\n *\n) Returns a list of all of the children of the object\n\n\nexample:\nclass ChildTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    BR_PROPERTY(int, property1, 2)\n    BR_PROPERTY(int, property2, 2.5)\n\n    ...\n};\n\nBR_REGISTER(Transform, ChildTransform)\n\nclass ParentTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(br::Transform *child READ get_child WRITE set_child RESET reset_child STORED false)\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    BR_PROPERTY(br::Transform *, child, Factory\nTransform\n::make(\".Child\"))\n    BR_PROPERTY(int, property1, 1)\n\n    ...\n};\n\nBR_REGISTER(Transform, ParentTransform)\n\nQScopedPointer\nTransform\n transform(Factory\nTransform\n::make(\".Parent\"));\ntransform-\ngetChildren(); // returns [br::ChildTransform(0x7fc10bf01050, name = \"Child\")]\ntransform-\ngetChildren().first()-\nparameters(); // returns [\"int property1 = 2\", \"float property2 = 2\"]\n\n\n\n\n\n\n\n\n\nQList\nT *\n getChildren()\n\n\nProvides a wrapper on \ngetChildren\n as a convenience to allow the return type (\nT\n) to be specified. \nT\n must be a derived class of \nObject\n.\n\n\n\n\n\n\nfunction definition:\n\n\ntemplate\ntypename T\n\nQList\nT *\n getChildren() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQList\nT\n *\n) Returns a list of all of the children of the object, casted to type \nT\n. \nT\n must be a derived class of \nObject\n\n\nexample:\nclass ChildTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    BR_PROPERTY(int, property1, 2)\n    BR_PROPERTY(int, property2, 2.5)\n\n    ...\n};\n\nBR_REGISTER(Transform, ChildTransform)\n\nclass ParentTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(br::Transform *child READ get_child WRITE set_child RESET reset_child STORED false)\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    BR_PROPERTY(br::Transform *, child, Factory\nTransform\n::make(\".Child\"))\n    BR_PROPERTY(int, property1, 1)\n\n    ...\n};\n\nBR_REGISTER(Transform, ParentTransform)\n\nQScopedPointer\nTransform\n transform(Factory\nTransform\n::make(\".Parent\"));\ntransform-\ngetChildren\nTransform\n(); // returns [br::ChildTransform(0x7fc10bf01050, name = \"Child\")]\ntransform-\ngetChildren\nTransform\n().first()-\nparameters(); // returns [\"int property1 = 2\", \"float property2 = 2\"]", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#init", 
            "text": "This is a virtual function. It is meant to be overloaded by derived classes if they need to initialize internal variables. The default constructor of derived objects should  never  be overloaded.    function definition:  virtual void init()    parameters:  NONE   output:  (void)", 
            "title": "void init()"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#store", 
            "text": "This is a virtual function. Serialize an object to a  QDataStream . The default implementation serializes each property and its value to disk.    function definition:  virtual void store(QDataStream  stream) const    parameters:     Parameter  Type  Description      stream  QDataStream    Stream to store serialized data       output:  (void)", 
            "title": "void store(QDataStream stream)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#load", 
            "text": "This is a virtual function. Deserialize an item from a  QDataStream . Elements can be deserialized in the same order in which they were serialized. The default implementation deserializes a value for each property and then calls  init .    function definition:  virtual void load(QDataStream  stream);    parameters:     Parameter  Type  Description      stream  QDataStream    Stream to deserialize data from       output:  (void)", 
            "title": "void load(QDataStream stream)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#serialize", 
            "text": "This is a virtual function. Serialize an entire plugin to a  QDataStream . This function is larger in scope then  store . It stores the string describing the plugin and then calls  store  to serialize its parameters. This has the benefit of being able to deserialize an entire plugin (or series of plugins) from a stored model file.    function definition:  virtual void serialize(QDataStream  stream) const    parameters:     Parameter  Type  Description      stream  QDataStream    Stream to store serialized data       output:  (void)", 
            "title": "void serialize(QDataStream stream)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#parameters", 
            "text": "Get a string describing the parameters of the object    function definition:  QStringList parameters() const    parameters:  NONE   output:  ( QStringList ) Returns a list of the parameters to a function  example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nFactory Transform ::make(\".Example\")- parameters(); // returns [\"int property1 = 1\", \"float property2 = 2.5\", \"QString property3 = Value\"]", 
            "title": "QStringList parameters()"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#prunedarguments", 
            "text": "Get a string describing the user-specified parameters of the object. This means that parameters using their default value are not returned.    function definition:  QStringList prunedArguments(bool expanded = false) const    parameters:     Parameter  Type  Description      expanded  bool  (Optional) If true, expand all abbreviations or model files into their full description strings. Default is false.       output:  ( QStringList ) Returns a list of all of the user specified parameters of the object   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nFactory Transform ::make(\".Example\")- prunedArguments(); // returns []\nFactory Transform ::make(\".Example(property1=10)\")- prunedArguments(); // returns [\"property1=10\"]\nFactory Transform ::make(\".Example(property1=10,property3=NewValue)\")- prunedArguments(); // returns [\"property1=10\", \"property3=NewValue\"]", 
            "title": "QStringList prunedArguments(bool expanded = false)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#argument", 
            "text": "Get a string value of the argument at a provided index. An index of 0 returns the name of the object.    function definition:  QString argument(int index, bool expanded) const    parameters:     Parameter  Type  Description      index  int  Index of the parameter to look up    expanded  bool  If true, expand all abbreviations or model files into their full description strings.       output:  ( QString ) Returns a string value for the lookup argument   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nFactory Transform ::make(\".Example\")- argument(0, false); // returns \"Example\"\nFactory Transform ::make(\".Example\")- argument(1, false); // returns \"1\"\nFactory Transform ::make(\".Example\")- argument(2, false); // returns \"2.5\"", 
            "title": "QString argument(int index, bool expanded)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#description", 
            "text": "This is a virtual function. Get a description of the object. The description includes the name and any user-defined parameters of the object. Parameters that retain their default value are not included.    function definition:  virtual QString description(bool expanded = false) const    parameters:     Parameter  Type  Description      expanded  bool  (Optional) If true, expand all abbreviations or model files into their full description strings. Default is false.       output:  ( QString ) Returns a string describing the object   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nFactory Transform ::make(\".Example\")- description(); // returns \"Example\"\nqDebug()   Factory Transform ::make(\".Example(property3=NewValue)\")- description(); // returns \"Example(property3=NewValue)\"", 
            "title": "QString description(bool expanded = false)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#setproperty", 
            "text": "Set a property with a provided name to a provided value. This function overloads  QObject ::setProperty so that it can handle OpenBR data types. If the provided name is not a property of the object nothing happens. If the provided name is a property but the provided value is not a valid type an error is thrown.    function definition:  void setProperty(const QString  name, QVariant value)    parameters:     Parameter  Type  Description      name  const  QString    Name of the property to set    value  QVariant  Value to set the property to       output:  (void)   see:   setPropertyRecursive ,  setExistingProperty  example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    Q_PROPERTY(QString property3 READ get_property3 WRITE set_property3 RESET reset_property3 STORED false)\n    BR_PROPERTY(int, property1, 1)\n    BR_PROPERTY(float, property2, 2.5)\n    BR_PROPERTY(QString, property3, \"Value\")\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nQScopedPointer Transform  transform(Factory Transform ::make(\".Example\"));\ntransform- parameters(); // returns [\"int property1 = 1\", \"float property2 = 2.5\", \"QString property3 = Value\"]\n\ntransform- setProperty(\"property1\", QVariant::fromValue int (10));\ntransform- parameters(); // returns [\"int property1 = 10\", \"float property2 = 2.5\", \"QString property3 = Value\"]\n\ntransform- setProperty(\"property1\", QVariant::fromValue QString (\"Value\")); // ERROR: incorrect type", 
            "title": "void setProperty(const QString name, QVariant value)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#setpropertyrecursive", 
            "text": "Set a property of the object or the object's children to a provided value. The recursion is only single level; the children of the the objects children will not be affected. Only the first property found is set. This means that if a parent and a child have the same property only the parent's property is set.    function definition:  virtual bool setPropertyRecursive(const QString  name, QVariant value)    parameters:     Parameter  Type  Description      name  const  QString    Name of the property to set    value  QVariant  Value to set the property to       output:  (bool) Returns true if the property is set in either the object or its children   see:   setProperty ,  setExistingProperty ,  getChildren  example: class ChildTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    BR_PROPERTY(int, property1, 2)\n    BR_PROPERTY(int, property2, 2.5)\n\n    ...\n};\n\nBR_REGISTER(Transform, ChildTransform)\n\nclass ParentTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(br::Transform *child READ get_child WRITE set_child RESET reset_child STORED false)\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    BR_PROPERTY(br::Transform*, child, Factory Transform ::make(\".Child\"))\n    BR_PROPERTY(int, property1, 1)\n\n    ...\n};\n\nQScopedPointer Transform  parent(Factory Transform ::make(\".Parent\"));\nparent- parameters(); // returns [\"br::Transform* child = \", \"int property1 = 1\"]\nparent- getChildren Transform ().first()- parameters(); // returns [\"int property1 = 2\", \"float property2 = 2\"]\n\nparent- setPropertyRecursive(\"property1\", QVariant::fromValue int (10));\nparent- parameters(); // returns [\"br::Transform* child = \", \"int property1 = 10\"]\nparent- getChildren Transform ().first()- parameters(); // returns [\"int property1 = 2\", \"float property2 = 2\"]\n\nparent- setPropertyRecursive(\"property2\", QVariant::fromValue float (10.5));\nparent- parameters(); // returns [\"br::Transform* child = \", \"int property1 = 10\"]\nparent- getChildren Transform ().first()- parameters(); // returns [\"int property1 = 2\", \"float property2 = 10\"]", 
            "title": "bool setPropertyRecursive(const QString name, QVariant value)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#setexistingproperty", 
            "text": "Attempt to set a property to a provided value. If the provided value is not a valid type for the given property an error is thrown.    function definition:  bool setExistingProperty(const QString  name, QVariant value)    parameters:     Parameter  Type  Description      name  const  QString    Name of the property to set    value  QVariant  Value to set the property to       output:  (bool) Returns true if the provided property exists and can be set to the provided value, otherwise returns false   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    BR_PROPERTY(int, property1, 2)\n    BR_PROPERTY(int, property2, 2.5)\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nQScopedPointer Transform  transform(Factory Transform ::make(\".Child\"));\ntransform- setExistingProperty(\"property1\", QVariant::fromValue int (10)); // returns true\ntransform- parameters(); // returns [\"int property1 = 10\", \"float property2 = 2\"]\n\ntransform- setExistingProperty(\"property3\", QVariant::fromValue int (10)); // returns false\ntransform- setExistingProperty(\"property1\", QVariant::fromValue QString (\"Hello\")); // ERROR: incorrect type", 
            "title": "bool setExistingProperty(const QString name, QVariant value)"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#getchildren-1", 
            "text": "This is a virtual function. Get all of the children of the object. The default implementation looks for children in the properties of the object. A derived object should overload this function if it needs to provide children from a different source.   function definition: virtual QList Object *  getChildren() const      parameters:  NONE  output:  ( QList Object  * ) Returns a list of all of the children of the object  example: class ChildTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    BR_PROPERTY(int, property1, 2)\n    BR_PROPERTY(int, property2, 2.5)\n\n    ...\n};\n\nBR_REGISTER(Transform, ChildTransform)\n\nclass ParentTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(br::Transform *child READ get_child WRITE set_child RESET reset_child STORED false)\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    BR_PROPERTY(br::Transform *, child, Factory Transform ::make(\".Child\"))\n    BR_PROPERTY(int, property1, 1)\n\n    ...\n};\n\nBR_REGISTER(Transform, ParentTransform)\n\nQScopedPointer Transform  transform(Factory Transform ::make(\".Parent\"));\ntransform- getChildren(); // returns [br::ChildTransform(0x7fc10bf01050, name = \"Child\")]\ntransform- getChildren().first()- parameters(); // returns [\"int property1 = 2\", \"float property2 = 2\"]", 
            "title": "QListObject * getChildren()"
        }, 
        {
            "location": "/api_docs/cpp_api/object/functions/#getchildren-2", 
            "text": "Provides a wrapper on  getChildren  as a convenience to allow the return type ( T ) to be specified.  T  must be a derived class of  Object .    function definition:  template typename T \nQList T *  getChildren() const    parameters:  NONE   output:  ( QList T  * ) Returns a list of all of the children of the object, casted to type  T .  T  must be a derived class of  Object  example: class ChildTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    Q_PROPERTY(float property2 READ get_property2 WRITE set_property2 RESET reset_property2 STORED false)\n    BR_PROPERTY(int, property1, 2)\n    BR_PROPERTY(int, property2, 2.5)\n\n    ...\n};\n\nBR_REGISTER(Transform, ChildTransform)\n\nclass ParentTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(br::Transform *child READ get_child WRITE set_child RESET reset_child STORED false)\n    Q_PROPERTY(int property1 READ get_property1 WRITE set_property1 RESET reset_property1 STORED false)\n    BR_PROPERTY(br::Transform *, child, Factory Transform ::make(\".Child\"))\n    BR_PROPERTY(int, property1, 1)\n\n    ...\n};\n\nBR_REGISTER(Transform, ParentTransform)\n\nQScopedPointer Transform  transform(Factory Transform ::make(\".Parent\"));\ntransform- getChildren Transform (); // returns [br::ChildTransform(0x7fc10bf01050, name = \"Child\")]\ntransform- getChildren Transform ().first()- parameters(); // returns [\"int property1 = 2\", \"float property2 = 2\"]", 
            "title": "QListT * getChildren()"
        }, 
        {
            "location": "/api_docs/cpp_api/context/context/", 
            "text": "The singleton class of global settings.\n\n\nSee:\n\n\n\n\nMembers\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nBefore including and using OpenBR in a project the user must call \ninitialize\n. Before the program terminates the user must call \nfinalize\n. The settings are accessible as Context *Globals.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/context/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsdkPath\n\n\nQString\n\n\nPath to the sdk. Path + \nshare/openbr/openbr.bib\n must exist.\n\n\n\n\n\n\nalgorithm\n\n\nQString\n\n\nThe default algorithm to use when enrolling and comparing templates.\n\n\n\n\n\n\nlog\n\n\nQString\n\n\nOptional log file to copy \nstderr\n to.\n\n\n\n\n\n\npath\n\n\nQString\n\n\nPath to use when resolving images specified with relative paths. Multiple paths can be specified using a semicolon separator.\n\n\n\n\n\n\nparallelism\n\n\nint\n\n\nThe number of threads to use. The default is the maximum of 1 and the value returned by (\nQThread\n::idealThreadCount() + 1).\n\n\n\n\n\n\nuseGui\n\n\nbool\n\n\nWhether or not to use GUI functions. The default is true.\n\n\n\n\n\n\nblockSize\n\n\nint\n\n\nThe maximum number of templates to process in parallel. The default is: \nparallelism * ((sizeof(void*) == 4) ? 128 : 1024)\n\n\n\n\n\n\nquiet\n\n\nbool\n\n\nIf true, no messages will be sent to the terminal. The default is false.\n\n\n\n\n\n\nverbose\n\n\nbool\n\n\nIf true, extra messages will be sent to the terminal. The default is false.\n\n\n\n\n\n\nmostRecentMessage\n\n\nQString\n\n\nThe most recent message sent to the terminal.\n\n\n\n\n\n\ncurrentStep\n\n\ndouble\n\n\nUsed internally to compute \nprogress\n and \ntimeRemaining\n.\n\n\n\n\n\n\ntotalSteps\n\n\ndouble\n\n\nUsed internally to compute \nprogress\n and \ntimeRemaining\n.\n\n\n\n\n\n\nenrollAll\n\n\nbool\n\n\nIf true, enroll 0 or more templates per image. Otherwise, enroll exactly one. The default is false.\n\n\n\n\n\n\nfilters\n\n\nFilters\n\n\nFilters is a \ntypedef QHash\nQString,QStringList\n Filters\n. Filters that automatically determine imposter matches based on target (\ngallery\n) template metadata. See \nFilterDistance\n.\n\n\n\n\n\n\nbuffer\n\n\nQByteArray\n\n\nFile output is redirected here if the file's basename is \"buffer\". This clears previous contents.\n\n\n\n\n\n\nscoreNormalization\n\n\nbool\n\n\nIf true, enable score normalization. Otherwise disable it. The default is true.\n\n\n\n\n\n\ncrossValidate\n\n\nint\n\n\nPerform k-fold cross validation where k is the value of \ncrossValidate\n. The default value is 0.\n\n\n\n\n\n\nmodelSearch\n\n\nQList\nQString\n\n\nList of paths to search for sub-models on.\n\n\n\n\n\n\nabbreviations\n\n\nQHash\nQString\n, \nQString\n\n\nUsed by \nTransform\n::\nmake\n to expand abbreviated algorithms into their complete definitions.\n\n\n\n\n\n\nstartTime\n\n\nQTime\n\n\nUsed to estimate \ntimeRemaining\n.\n\n\n\n\n\n\nlogFile\n\n\nQFile\n\n\nLog file to write to.", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/context/statics/", 
            "text": "void initialize(int \nargc, char *argv[], \nQString\n sdkPath = \"\", bool useGui = true)\n\n\nCall \nonce\n at the start of the application to allocate global variables. If the project is a \nQt\n project this call should occur after initializing \nQApplication\n.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic void initialize(int \nargc, char *argv[], QString sdkPath = \"\", bool useGui = true);\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargc\n\n\nint \n\n\nNumber of command line arguments as provided by \nmain()\n\n\n\n\n\n\nargv\n\n\nchar * []\n\n\nCommand line arguments as provided by \nmain()\n\n\n\n\n\n\nsdkPath\n\n\nQString\n\n\n(Optional) The path to the folder containing \nshare/openbr/openbr.bib\n. If no path is provided (default) OpenBR automatically searches: \n \nThe working directory\n \nThe executable's location\n \n\n\n\n\n\n\nuseGui\n\n\nbool\n\n\n(Optional) Make OpenBR as a \nQApplication\n instead of a \nQCoreApplication\n. Default is true.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \nfinalize\n\n\nexample:\nint main(int argc, char \\*argv[])\n{\n    QApplication(argc, argv); // ONLY FOR QT PROJECTS\n    br::Context::initialize(argc, argv);\n\n    // ...\n\n    br::Context::finalize();\n    return 0;\n}\n\n\n\n\n\n\n\nvoid finalize()\n\n\nCall \nonce\n at the end of the application to deallocate global variables.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic void finalize();\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)\n\n\nsee:\n \ninitialize\n\n\n\n\nbool checkSDKPath(const \nQString\n \nsdkPath)\n\n\nCheck if a given SDK path is valid. A valid SDK satisfies\n\n\nexists(sdkPath + \"share/openbr/openbr.bib\")\n\n\n\n\n\n\n\nfunction definition:\n\n\nstatic bool checkSDKPath(const QString \nsdkPath);\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsdkPath\n\n\nconst \nQString\n \n\n\nPossible sdk path to examine\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the sdkPath + \"share/openbr/openbr.bib\" exists, otherwise returns false.\n\n\n\n\nexample:\n// OpenBR is at /libs/openbr\n\ncheckSDKPath(\"/libs/openbr/\"); // returns true\ncheckSDKPath(\"/libs/\"); // returns false\n\n\n\n\n\n\n\nQString\n about()\n\n\nGet a string with the name, version, and copyright of the project. This string is suitable for printing or terminal.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QString about();\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns a string containing the name, version and copyright of the project\n\n\nexample:\n// Using OpenBR version 0.6.0\nContext::about(); // returns \"OpenBR 0.6.0 Copyright (c) 2013 OpenBiometrics. All rights reserved.\"\n\n\n\n\n\n\n\nQString\n version()\n\n\nGet the version of the SDK.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QString version();\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns a string containing the version of the OpenBR SDK. The string has the format \nMajorVersion>\n.\nMinorVersion>\n.\nPatchVersion>\n\n\nexample:\n// Using OpenBR version 0.6.0\nContext::version(); // returns \"0.6.0\"\n\n\n\n\n\n\n\nQString\n scratchPath()\n\n\nGet the scratch directory used by OpenBR. This directory should be used as the root directory for managing temporary files and providing process persistence.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QString scratchPath();\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nQString\n) Returns a string pointing to the OpenBR scratch directory. The string has the format \npath/to/user/home>\nOpenBR->\nMajorVersion>\n.\nMinorVersion>\n.\n\n\nsee:\n \nversion\n\n\nexample:\n// Using OpenBR version 0.6.0\nContext::scratchPath(); // returns \"/path/to/user/home/OpenBR-0.6\"\n\n\n\n\n\n\n\nQStringList\n objects(const char *abstractions = \".*\", const char *implementations = \".*\", bool parameters = true)\n\n\nGet a collection of objects in OpenBR that match provided regular expressions. This function uses \nQRegExp\n syntax.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QStringList objects(const char *abstractions = \".*\", const char *implementations = \".*\", bool parameters = true)\n\n\n\n\n\n\n\nparameters:\n\n\nParameter | Type | Description\n--- | --- | ---\nabstractions | const char \\* | (Optional) Regular expression of the abstractions to search. Default is \".\\*\"\nimplementations | const char \\* | (Optional) Regular expression of the implementations to search. Default is \".\\*\".\nparameters | bool | (Optional) If true include parameters after object name. Default is true.\n\n\n\n\n\n\n\noutput:\n (\nQStringList\n) Return names and parameters for the requested objects. Each object is newline separated. Arguments are separated from the object name with tabs.\n\n\n\n\nexample:\n// Find all 'Rnd' Transforms\nContext::objects(\"Transform\", \"Rnd.*\", false); // returns [\"RndPoint\", \"RndRegion\", \"RndRotate\", \"RndSample\", \"RndSubspace\"]", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/context/statics/#initialize", 
            "text": "Call  once  at the start of the application to allocate global variables. If the project is a  Qt  project this call should occur after initializing  QApplication .    function definition:  static void initialize(int  argc, char *argv[], QString sdkPath = \"\", bool useGui = true);    parameters:     Parameter  Type  Description      argc  int   Number of command line arguments as provided by  main()    argv  char * []  Command line arguments as provided by  main()    sdkPath  QString  (Optional) The path to the folder containing  share/openbr/openbr.bib . If no path is provided (default) OpenBR automatically searches:    The working directory   The executable's location      useGui  bool  (Optional) Make OpenBR as a  QApplication  instead of a  QCoreApplication . Default is true.       output:  (void)   see:   finalize  example: int main(int argc, char \\*argv[])\n{\n    QApplication(argc, argv); // ONLY FOR QT PROJECTS\n    br::Context::initialize(argc, argv);\n\n    // ...\n\n    br::Context::finalize();\n    return 0;\n}", 
            "title": "void initialize(int argc, char *argv[], QString sdkPath = \"\", bool useGui = true)"
        }, 
        {
            "location": "/api_docs/cpp_api/context/statics/#finalize", 
            "text": "Call  once  at the end of the application to deallocate global variables.    function definition:  static void finalize();    parameters:  NONE   output:  (void)  see:   initialize", 
            "title": "void finalize()"
        }, 
        {
            "location": "/api_docs/cpp_api/context/statics/#checksdkpath", 
            "text": "Check if a given SDK path is valid. A valid SDK satisfies  exists(sdkPath + \"share/openbr/openbr.bib\")    function definition:  static bool checkSDKPath(const QString  sdkPath);    parameters:     Parameter  Type  Description      sdkPath  const  QString    Possible sdk path to examine       output:  (bool) Returns true if the sdkPath + \"share/openbr/openbr.bib\" exists, otherwise returns false.   example: // OpenBR is at /libs/openbr\n\ncheckSDKPath(\"/libs/openbr/\"); // returns true\ncheckSDKPath(\"/libs/\"); // returns false", 
            "title": "bool checkSDKPath(const QString sdkPath)"
        }, 
        {
            "location": "/api_docs/cpp_api/context/statics/#about", 
            "text": "Get a string with the name, version, and copyright of the project. This string is suitable for printing or terminal.    function definition:  static QString about();    parameters:  NONE   output:  ( QString ) Returns a string containing the name, version and copyright of the project  example: // Using OpenBR version 0.6.0\nContext::about(); // returns \"OpenBR 0.6.0 Copyright (c) 2013 OpenBiometrics. All rights reserved.\"", 
            "title": "QString about()"
        }, 
        {
            "location": "/api_docs/cpp_api/context/statics/#version", 
            "text": "Get the version of the SDK.    function definition:  static QString version();    parameters:  NONE   output:  ( QString ) Returns a string containing the version of the OpenBR SDK. The string has the format  MajorVersion> . MinorVersion> . PatchVersion>  example: // Using OpenBR version 0.6.0\nContext::version(); // returns \"0.6.0\"", 
            "title": "QString version()"
        }, 
        {
            "location": "/api_docs/cpp_api/context/statics/#scratchpath", 
            "text": "Get the scratch directory used by OpenBR. This directory should be used as the root directory for managing temporary files and providing process persistence.    function definition:  static QString scratchPath();    parameters:  NONE   output:  ( QString ) Returns a string pointing to the OpenBR scratch directory. The string has the format  path/to/user/home> OpenBR-> MajorVersion> . MinorVersion> .  see:   version  example: // Using OpenBR version 0.6.0\nContext::scratchPath(); // returns \"/path/to/user/home/OpenBR-0.6\"", 
            "title": "QString scratchPath()"
        }, 
        {
            "location": "/api_docs/cpp_api/context/statics/#objects", 
            "text": "Get a collection of objects in OpenBR that match provided regular expressions. This function uses  QRegExp  syntax.    function definition:  static QStringList objects(const char *abstractions = \".*\", const char *implementations = \".*\", bool parameters = true)    parameters:  Parameter | Type | Description\n--- | --- | ---\nabstractions | const char \\* | (Optional) Regular expression of the abstractions to search. Default is \".\\*\"\nimplementations | const char \\* | (Optional) Regular expression of the implementations to search. Default is \".\\*\".\nparameters | bool | (Optional) If true include parameters after object name. Default is true.    output:  ( QStringList ) Return names and parameters for the requested objects. Each object is newline separated. Arguments are separated from the object name with tabs.   example: // Find all 'Rnd' Transforms\nContext::objects(\"Transform\", \"Rnd.*\", false); // returns [\"RndPoint\", \"RndRegion\", \"RndRotate\", \"RndSample\", \"RndSubspace\"]", 
            "title": "QStringList objects(const char *abstractions = \".*\", const char *implementations = \".*\", bool parameters = true)"
        }, 
        {
            "location": "/api_docs/cpp_api/context/functions/", 
            "text": "bool contains(const \nQString\n \nname)\n\n\nCheck if a property exists in the \nglobal metadata\n.\n\n\n\n\n\n\nfunction definition:\n\n\nbool contains(const QString \nname);\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nconst \nQString\n \n\n\nMetadata\n key. It must be queryable using \nQObject::property\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (bool) Returns true if the provided key is a global property.\n\n\n\n\nsee:\n \nsetProperty\n\n\nexample:\nGlobals-\ncontains(\"path\"); // returns true\nGlobals-\ncontains(\"key\"); // returns false\n\n\n\n\n\n\n\nvoid setProperty(const \nQString\n \nkey, const \nQString\n \nvalue)\n\n\nSet a global property.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid setProperty(const QString \nkey, const QString \nvalue)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nconst \nQString\n \n\n\nMetadata\n key\n\n\n\n\n\n\nvalue\n\n\nconst \nQString\n \n\n\nValue to be added to the \nMetadata\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nsee:\n \ncontains\n\n\nexample:\nGlobals-\ncontains(\"key\"); // returns false\nGlobals-\nsetProperty(\"key\", \"value\");\nGlobals-\ncontains(\"key\"); // returns true\n\n\n\n\n\n\n\nvoid printStatus()\n\n\nPrints the current progress statistics to \nstdout\n.\n\n\n\n\nfunction definition:\n\n\n\n\nvoid printStatus();\n\n\n\n\nparameters:\n NONE\n\n\noutput:\n (void)\n\n\nsee:\n \nprogress\n\n\nexample:\nGlobals-\nprintStatus(); // returns 00.00%  ELAPSED=00:00:00  REMAINING=99:99:99  COUNT=0\n\n\n\n\n\n\n\nint timeRemaining() const\n\n\nGet the time remaining in seconds of a call to \nTrain\n, \nEnroll\n or \nCompare\n.\n\n\n\n\n\n\nfunction defintion:\n\n\nint timeRemaining() const;\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (int) Returns the estimated time remaining in the currently running process. If not process is running returns -1.\n\n\n\n\nfloat progress()\n\n\nGet the completion percentage of a call to \nTrain\n, \nEnroll\n or \nCompare\n.\n\n\n\n\n\n\nfunction definition:\n\n\nfloat progress() const;\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (float) Returns the fraction of the currently running job that has been completed.", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/context/functions/#contains", 
            "text": "Check if a property exists in the  global metadata .    function definition:  bool contains(const QString  name);    parameters:     Parameter  Type  Description      name  const  QString    Metadata  key. It must be queryable using  QObject::property .       output:  (bool) Returns true if the provided key is a global property.   see:   setProperty  example: Globals- contains(\"path\"); // returns true\nGlobals- contains(\"key\"); // returns false", 
            "title": "bool contains(const QString name)"
        }, 
        {
            "location": "/api_docs/cpp_api/context/functions/#setproperty", 
            "text": "Set a global property.    function definition:  void setProperty(const QString  key, const QString  value)    parameters:     Parameter  Type  Description      key  const  QString    Metadata  key    value  const  QString    Value to be added to the  Metadata       output:  (void)   see:   contains  example: Globals- contains(\"key\"); // returns false\nGlobals- setProperty(\"key\", \"value\");\nGlobals- contains(\"key\"); // returns true", 
            "title": "void setProperty(const QString key, const QString value)"
        }, 
        {
            "location": "/api_docs/cpp_api/context/functions/#printstatus", 
            "text": "Prints the current progress statistics to  stdout .   function definition:   void printStatus();   parameters:  NONE  output:  (void)  see:   progress  example: Globals- printStatus(); // returns 00.00%  ELAPSED=00:00:00  REMAINING=99:99:99  COUNT=0", 
            "title": "void printStatus()"
        }, 
        {
            "location": "/api_docs/cpp_api/context/functions/#timeremaining", 
            "text": "Get the time remaining in seconds of a call to  Train ,  Enroll  or  Compare .    function defintion:  int timeRemaining() const;    parameters:  NONE   output:  (int) Returns the estimated time remaining in the currently running process. If not process is running returns -1.", 
            "title": "int timeRemaining() const"
        }, 
        {
            "location": "/api_docs/cpp_api/context/functions/#progress", 
            "text": "Get the completion percentage of a call to  Train ,  Enroll  or  Compare .    function definition:  float progress() const;    parameters:  NONE   output:  (float) Returns the fraction of the currently running job that has been completed.", 
            "title": "float progress()"
        }, 
        {
            "location": "/api_docs/cpp_api/initializer/initializer/", 
            "text": "Inherits \nObject\n\n\nSee:\n\n\n\n\nConstructors\n\n\nFunctions\n\n\n\n\nPlugin base class for initializing resources. On startup (the call to \nContext\n::\ninitialize\n), OpenBR will call \ninitialize\n on every Initializer that has been registered with the \nFactory\n. On shutdown (the call to \nContext\n::\nfinalize\n, OpenBR will call \nfinalize\n on every registered initializer.\n\n\nThe general use case for initializers is to launch shared contexts for third party integrations into OpenBR. These cannot be launched during \nTransform\n::\ninit\n for example, because multiple instances of the \nTransform\n object could exist across multiple threads.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/initializer/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtual ~Initializer()\n\n\nVirtual function. Default destructor.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/initializer/functions/", 
            "text": "void initialize()\n\n\nThis is a pure virtual function. It is called once at the end of \ninitialize\n. Any global initialization that needs to occur should occur within this function.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void initialize() const = 0\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)\n\n\n\n\nvoid finalize()\n\n\nThis is a virtual function. It is called once at the beginning of \nfinalize\n. Any global finalization should occur within this function. This includes deallocating anything that was allocated in \ninitialize\n\n\n\n\n\n\nfunction definition\n:\n\n\nvirtual void finalize() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/initializer/functions/#initialize", 
            "text": "This is a pure virtual function. It is called once at the end of  initialize . Any global initialization that needs to occur should occur within this function.    function definition:  virtual void initialize() const = 0    parameters:  NONE   output:  (void)", 
            "title": "void initialize()"
        }, 
        {
            "location": "/api_docs/cpp_api/initializer/functions/#finalize", 
            "text": "This is a virtual function. It is called once at the beginning of  finalize . Any global finalization should occur within this function. This includes deallocating anything that was allocated in  initialize    function definition :  virtual void finalize() const    parameters:  NONE   output:  (void)", 
            "title": "void finalize()"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/transform/", 
            "text": "Inherits \nObject\n\n\nPlugin base class for processing a template.\n\n\nSee:\n\n\n\n\nMembers\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nTransforms support the idea of \ntraining\n and \nprojecting\n, whereby they are (optionally) given example images and are expected learn how to transform new instances into an alternative, hopefully more useful, basis for the recognition task at hand. Transforms can be chained together to support the declaration and use of arbitrary algorithms at run time.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindependent\n\n\nbool\n\n\nTrue if the transform is independent, false otherwise. Independent transforms process each \nMat\n in a \nTemplate\n independently. This means that a new instance of the transform is created for each \nMat\n. If the transform is \ntrainable\n and the training data has more then one \nMat\n per template, each created instance of the transform is trained separately. Please see \nTraining Algorithms\n for more details.\n\n\n\n\n\n\ntrainable\n\n\nbool\n\n\nTrue if the transform is trainable, false otherwise. Trainable transforms need to overload the \ntrain\n function.", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTransform(bool independent = true, bool trainable = true)\n\n\nDefault constructor for transforms. By default \nindependent\n and \ntrainable\n are set to true.\n\n\n\n\n\n\n~Transform()\n\n\nDefault Destructor, it doesn't do anything", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/", 
            "text": "Transform\n *make(\nQString\n str, \nQObject\n *parent)\n\n\nMake a transform from a string. This function converts the abbreviation characters \n+\n, \n/\n, \n{}\n, \n>\n, and \n()\n into their full-length alternatives.\n\n\n\n\n\n\n\n\nAbbreviation\n\n\nTranslation\n\n\n\n\n\n\n\n\n\n\n+\n\n\nPipeTransform\n. Each \nTransform\n linked by a \n+\n is turned into a child of a single \nPipeTransform\n. \"Example1+Example2\" becomes \"Pipe([Example1,Example2])\". \nTemplates\n are projected through the children of a pipe in series, the output of one become the input of the next.\n\n\n\n\n\n\n/\n\n\nForkTransform\n. Each \nTransform\n linked by a \n/\n is turned into a child of a single \nForkTransform\n. \"Example1/Example2\" becomes \"Fork([Example1,Example2])\". \nTemplates\n are projected the children of a fork in parallel, each receives the same input and the outputs are merged together.\n\n\n\n\n\n\n{}\n\n\nCacheTransform\n. Can only surround a single \nTransform\n. \"{Example}\" becomes \"Cache(Example)\". The results of a cached \nTransform\n are stored in a global cache using the \nfile\n name as a key.\n\n\n\n\n\n\n\n\nLoadStoreTransform\n. Can only surround a single \nTransform\n. \"\n\" becomes \"LoadStore(Example)\". Serialize and store a \nTransform\n after training or deserialize and load a \nTransform\n before projecting.\n\n\n\n\n\n\n()\n\n\nOrder of operations. Change the order of operations using parantheses.\n\n\n\n\n\n\n\n\nThe parsed string is then passed to \nFactory\n::\nmake\n to be turned into a transform.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic Transform *make(QString str, QObject *parent)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstr\n\n\nQString\n\n\nString describing the transform\n\n\n\n\n\n\nparent\n\n\nQObject\n *\n\n\nParent of the object to be created\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns a pointer to the \nTransform\n described by the string\n\n\n\n\nsee:\n \nFactory::make\n\n\nexample:\nTransform::make(\"Example1+Example2+\nModelFile\n\")-\ndescription(); // returns \"Pipe(transforms=[Example1,Example2,LoadStore(ModelFile)])\".\n\n\n\n\n\n\n\nQSharedPointer\nTransform\n fromAlgorithm(const \nQString\n \nalgorithm, bool preprocess=false)\n\n\nCreate a \nTransform\n from an OpenBR algorithm string. The \nTransform\n is created using everything to the left of a \n:\n or a \n!\n in the string.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QSharedPointer\nTransform\n fromAlgorithm(const QString \nalgorithm, bool preprocess=false)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalgorithm\n\n\nconst \nQString\n \n\n\nAlgorithm string to construct the \nTransform\n from\n\n\n\n\n\n\npreprocess\n\n\nbool\n\n\n(Optional) If true add a \nStreamTransform\n as the parent of the constructed \nTransform\n. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQSharedPointer\nTransform\n) Returns a pointer to the \nTransform\n described by the algorithm.\n\n\n\n\n\n\nexample:\n\n\nTransform::fromAlgorithm(\"EnrollmentTransform:Distance\")-\ndecription(); // returns \"EnrollmentTransform\"\nTransform::fromAlgorithm(\"EnrollmentTransform!DistanceTransform\")-\ndecription(); // returns \"EnrollmentTransform\"\nTransform::fromAlgorithm(\"EnrollmentTransform\")-\ndecription(); // returns \"EnrollmentTransform\"\n\n\n\n\n\n\nQSharedPointer\nTransform\n fromComparison(const \nQString\n \nalgorithm)\n\n\nCreate a\nTransform\n from an OpenBR algorithm string. The \nTransform\n is created using everything to the right of a \n:\n or a \n!\n in the string. If the separating symbol is a \n:\n the string to the right describes a distance. It is converted to a \nGalleryCompareTransform\n with the distance stored as a property. If the separating symbol is a \n!\n the string already describes a transform and is unchanged.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QSharedPointer\nTransform\n fromComparison(const QString \nalgorithm)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalgorithm\n\n\nconst \nQString\n \n\n\nAlgorithm string to construct the \nTransform\n from\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQSharedPointer\nTransform\n) Returns a pointer to the \nTransform\n described by the algorithm.\n\n\n\n\nexample:\nTransform::fromAlgorithm(\"EnrollmentTransform:Distance\")-\ndescription(); // returns \"GalleryCompare(distance=Distance)\"\"\nTransform::fromAlgorithm(\"EnrollmentTransform!DistanceTransform\"); // returns \"DistanceTransform\"\n\n\n\n\n\n\n\nTransform\n *deserialize(\nQDataStream\n \nstream)\n\n\nDeserialize a \nTransform\n from a stream.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic Transform *deserialize(QDataStream \nstream)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n \n\n\nStream containing the serialized transform\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns the deserialized transform\n\n\n\n\n\n\nTemplate\n \noperator\n(\nTemplate\n \nsrcdst, const \nTransform\n \nf)\n\n\nConvenience function for \nproject\n\n\n\n\n\n\nfunction definition:\n\n\ninline Template \noperator\n(Template \nsrcdst, const Transform \nf)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrcdst\n\n\nTemplate\n \n\n\nInput template. Will be overwritten with the output following call to \nproject\n\n\n\n\n\n\nf\n\n\nconst \nTransform\n \n\n\nTransform\n to project through.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTemplate\n \n) Returns the output of f::\nproject\n\n\n\n\nexample:\nTemplate t(\"picture1.jpg\");\nTransform *transform = Transform::make(\"Example\", NULL);\n\nt \n *transform; // projects t through Example. t is overwritten with the output of the project call\n\n\n\n\n\n\n\n\n\n\nTemplateList\n \noperator\n(\nTemplateList\n \nsrcdst, const \nTransform\n \nf)\n\n\nConvenience function for \nproject\n\n\n\n\n\n\nfunction definition:\n\n\ninline TemplateList \noperator\n(TemplateList \nsrcdst, const Transform \nf)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrcdst\n\n\nTemplateList\n \n\n\nInput templates. Will be overwritten with the output following call to \nproject\n\n\n\n\n\n\nf\n\n\nconst \nTransform\n \n\n\nTransform\n to project through.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTemplateList\n \n) Returns the output of f::\nproject\n\n\n\n\nexample:\nTemplateList tList(QList\nTemplate\n() \n Template(\"picture1.jpg\"));\nTransform *transform = Transform::make(\"Example\", NULL);\n\ntList \n *transform; // projects tList through Example. tList is overwritten with the output of the project call\n\n\n\n\n\n\n\n\n\n\nQDataStream\n \noperator\n(\nQDataStream\n \nstream, const \nTransform\n \nf)\n\n\nConvenience function for \nstore\n\n\n\n\n\n\nfunction definition:\n\n\ninline QDataStream \noperator\n(QDataStream \nstream, const Transform \nf)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n \n\n\nStream to store the transform in\n\n\n\n\n\n\nf\n\n\nconst \nTransform\n \n\n\nTransform to be stored\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQDataStream\n \n) Returns the stream with the transform stored in it\n\n\n\n\nexample:\nTransform *transform = Transform::make(\"Example(property1=value1,property2=value2)\");\n\nQDataStream stream;\nstream \n *transform; // stores \"Example(property1=value1,property2=value2)\" in the stream\n\n\n\n\n\n\n\n\n\n\nQDataStream\n \noperator\n(\nQDataStream\n \nstream, const \nTransform\n \nf)\n\n\nConvenience function for \nload\n\n\n\n\n\n\nfunction definition:\n\n\ninline QDataStream \noperator\n(QDataStream \nstream, const Transform \nf)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstream\n\n\nQDataStream\n \n\n\nStream to load the transform from\n\n\n\n\n\n\nf\n\n\nconst \nTransform\n \n\n\nTransform to store loaded information\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQDataStream\n \n) Returns the stream without the transform data\n\n\n\n\nexample:\nTransform *in = Transform::make(\"Example(property1=value1,property2=value2)\");\n\nQDataStream stream;\nstream \n *in; // stores \"Example(property1=value1,property2=value2)\" in the stream\n\nTransform out;\nstream \n out;\nout-\ndescription(); // returns \"Example(property1=value1,property2=value2)\"", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/#make", 
            "text": "Make a transform from a string. This function converts the abbreviation characters  + ,  / ,  {} ,  > , and  ()  into their full-length alternatives.     Abbreviation  Translation      +  PipeTransform . Each  Transform  linked by a  +  is turned into a child of a single  PipeTransform . \"Example1+Example2\" becomes \"Pipe([Example1,Example2])\".  Templates  are projected through the children of a pipe in series, the output of one become the input of the next.    /  ForkTransform . Each  Transform  linked by a  /  is turned into a child of a single  ForkTransform . \"Example1/Example2\" becomes \"Fork([Example1,Example2])\".  Templates  are projected the children of a fork in parallel, each receives the same input and the outputs are merged together.    {}  CacheTransform . Can only surround a single  Transform . \"{Example}\" becomes \"Cache(Example)\". The results of a cached  Transform  are stored in a global cache using the  file  name as a key.     LoadStoreTransform . Can only surround a single  Transform . \" \" becomes \"LoadStore(Example)\". Serialize and store a  Transform  after training or deserialize and load a  Transform  before projecting.    ()  Order of operations. Change the order of operations using parantheses.     The parsed string is then passed to  Factory :: make  to be turned into a transform.    function definition:  static Transform *make(QString str, QObject *parent)    parameters:     Parameter  Type  Description      str  QString  String describing the transform    parent  QObject  *  Parent of the object to be created       output:  ( Transform  *) Returns a pointer to the  Transform  described by the string   see:   Factory::make  example: Transform::make(\"Example1+Example2+ ModelFile \")- description(); // returns \"Pipe(transforms=[Example1,Example2,LoadStore(ModelFile)])\".", 
            "title": "Transform *make(QString str, QObject *parent)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/#fromalgorithm", 
            "text": "Create a  Transform  from an OpenBR algorithm string. The  Transform  is created using everything to the left of a  :  or a  !  in the string.    function definition:  static QSharedPointer Transform  fromAlgorithm(const QString  algorithm, bool preprocess=false)    parameters:     Parameter  Type  Description      algorithm  const  QString    Algorithm string to construct the  Transform  from    preprocess  bool  (Optional) If true add a  StreamTransform  as the parent of the constructed  Transform . Default is false.       output:  ( QSharedPointer Transform ) Returns a pointer to the  Transform  described by the algorithm.    example:  Transform::fromAlgorithm(\"EnrollmentTransform:Distance\")- decription(); // returns \"EnrollmentTransform\"\nTransform::fromAlgorithm(\"EnrollmentTransform!DistanceTransform\")- decription(); // returns \"EnrollmentTransform\"\nTransform::fromAlgorithm(\"EnrollmentTransform\")- decription(); // returns \"EnrollmentTransform\"", 
            "title": "QSharedPointerTransform fromAlgorithm(const QString algorithm, bool preprocess=false)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/#fromcomparison", 
            "text": "Create a Transform  from an OpenBR algorithm string. The  Transform  is created using everything to the right of a  :  or a  !  in the string. If the separating symbol is a  :  the string to the right describes a distance. It is converted to a  GalleryCompareTransform  with the distance stored as a property. If the separating symbol is a  !  the string already describes a transform and is unchanged.    function definition:  static QSharedPointer Transform  fromComparison(const QString  algorithm)    parameters:     Parameter  Type  Description      algorithm  const  QString    Algorithm string to construct the  Transform  from       output:  ( QSharedPointer Transform ) Returns a pointer to the  Transform  described by the algorithm.   example: Transform::fromAlgorithm(\"EnrollmentTransform:Distance\")- description(); // returns \"GalleryCompare(distance=Distance)\"\"\nTransform::fromAlgorithm(\"EnrollmentTransform!DistanceTransform\"); // returns \"DistanceTransform\"", 
            "title": "QSharedPointerTransform fromComparison(const QString algorithm)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/#deserialize", 
            "text": "Deserialize a  Transform  from a stream.    function definition:  static Transform *deserialize(QDataStream  stream)    parameters:     Parameter  Type  Description      stream  QDataStream    Stream containing the serialized transform       output:  ( Transform  *) Returns the deserialized transform", 
            "title": "Transform *deserialize(QDataStream stream)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/#template-operater-gtgt-1", 
            "text": "Convenience function for  project    function definition:  inline Template  operator (Template  srcdst, const Transform  f)    parameters:     Parameter  Type  Description      srcdst  Template    Input template. Will be overwritten with the output following call to  project    f  const  Transform    Transform  to project through.       output:  ( Template   ) Returns the output of f:: project   example: Template t(\"picture1.jpg\");\nTransform *transform = Transform::make(\"Example\", NULL);\n\nt   *transform; // projects t through Example. t is overwritten with the output of the project call", 
            "title": "Template operator(Template srcdst, const Transform f)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/#template-operater-gtgt-2", 
            "text": "Convenience function for  project    function definition:  inline TemplateList  operator (TemplateList  srcdst, const Transform  f)    parameters:     Parameter  Type  Description      srcdst  TemplateList    Input templates. Will be overwritten with the output following call to  project    f  const  Transform    Transform  to project through.       output:  ( TemplateList   ) Returns the output of f:: project   example: TemplateList tList(QList Template ()   Template(\"picture1.jpg\"));\nTransform *transform = Transform::make(\"Example\", NULL);\n\ntList   *transform; // projects tList through Example. tList is overwritten with the output of the project call", 
            "title": "TemplateList operator(TemplateList srcdst, const Transform f)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/#stream-operator-ltlt", 
            "text": "Convenience function for  store    function definition:  inline QDataStream  operator (QDataStream  stream, const Transform  f)    parameters:     Parameter  Type  Description      stream  QDataStream    Stream to store the transform in    f  const  Transform    Transform to be stored       output:  ( QDataStream   ) Returns the stream with the transform stored in it   example: Transform *transform = Transform::make(\"Example(property1=value1,property2=value2)\");\n\nQDataStream stream;\nstream   *transform; // stores \"Example(property1=value1,property2=value2)\" in the stream", 
            "title": "QDataStream operator(QDataStream stream, const Transform f)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/statics/#stream-operator-gtgt", 
            "text": "Convenience function for  load    function definition:  inline QDataStream  operator (QDataStream  stream, const Transform  f)    parameters:     Parameter  Type  Description      stream  QDataStream    Stream to load the transform from    f  const  Transform    Transform to store loaded information       output:  ( QDataStream   ) Returns the stream without the transform data   example: Transform *in = Transform::make(\"Example(property1=value1,property2=value2)\");\n\nQDataStream stream;\nstream   *in; // stores \"Example(property1=value1,property2=value2)\" in the stream\n\nTransform out;\nstream   out;\nout- description(); // returns \"Example(property1=value1,property2=value2)\"", 
            "title": "QDataStream operator(QDataStream stream, const Transform f)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/", 
            "text": "Transform\n *clone()\n\n\nThis is a virtual function. Make a deep copy of the transform.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Transform *clone() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nTransform\n)\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property READ get_property WRITE set_property RESET reset_property STORED false)\n    BR_PROPERTY(int, property, 1)\n\n    ...\n};\n\nTransform *transform = Transform::make(\"Example\", NULL);\ntransform-\nparameters(); // returns [\"property = 1\"]\n\nTransform *clone = transform-\nclone();\nclone-\nparameters(); // returns [\"property = 1\"]\n\ntransform-\nsetProperty(\"property\", 10);\ntransform-\nparameters(); // returns [\"property = 10\"]\nclone-\nparameters(); // returns [\"property = 1\"]\n\n\n\n\n\n\n\nvoid train(const \nTemplateList\n \ndata)\n\n\nThis is a virtual function. Train the transform on provided training data. This function should be overloaded for any transform that needs to be trained. \nTrainable\n must be set to true for this function to be called. If \nindependent\n is true a new instance of the transform will be trained for each \nMat\n stored in a \nTemplate\n in the provided training data. Each \nTemplate\n should have the same number of \nMats\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void train(const TemplateList \ndata)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst \nTemplateList\n \n\n\nTraining data. The format of the data depends on the transform to be trained. In some cases the transform requires a \"Label\" field in each \nTemplate\n \nfile's\n \nmetadata\n (normally these are classifiers like \nSVM\n). In other cases no metadata is required and training occurs on the raw image data only.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\n// Create data for a 2-class classification problem\nTemplate t1(\"training_pic1.jpg\");\nt1.file.set(\"Label\", 0);\nTemplate t2(\"training_pic2.jpg\");\nt2.file.set(\"Label\", 0);\nTemplate t3(\"training_pic3.jpg\");\nt3.file.set(\"Label\", 1);\nTemplate t4(\"training_pic4.jpg\");\nt4.file.set(\"Label\", 1);\n\nTemplateList training_data(QList\nTemplate\n() \n t1 \n t2 \n t3 \n t4);\n\nTransform *classifier = Transform::make(\"DataPrep+Classifier\");\nclassifier-\ntrain(training_data); // The data is projected through DataPrep, assuming it is untrainable, and then passed to the train method of Classifier\n\n\n\n\n\n\n\nvoid train(const \nQList\nTemplateList\n \ndata)\n\n\nThis is a virtual function. This version of train is meant for special-case, internal, transforms and for tranforms that require a specific number of templates at project time. If a transform requires a specific number of templates at project time it should be trained in batches that have the same number of templates. For example, if a transform requires exactly 5 templates when projecting it should get a list of \nTemplateLists\n, each with exactly 5 templates, at train time. Each \nTemplateList\n can then be treated as an individual input to the training function.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void train(const QList\n \ndata)\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst \nQList\nTemplateList\n \n\n\nSpecially formatted list of training input. Format should match what is passed to \nproject\n.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid project(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nThis is a pure virtual function. It must be overloaded by all derived classes. Project a template through the transform, modifying its contents in some way and storing the modified data in \ndst\n. This function has a strict \nTemplate\n in, \nTemplate\n out model. For a multiple \nTemplate\n in, multiple \nTemplate\n out model see [project]{: #project-2 }.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void project(const Template \nsrc, Template \ndst) const = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nInput template. It is immutable\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nOutput template. Should contain the modified data from the input template.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplate src(\"color_picture.jpg\"), dst;\n\nTransform *color_converter = Transfrom::make(\"Read+Cvt(Gray)\");\ncolor_converter-\nproject(src, dst); // returns a grayscale image stored in dst\n\n\n\n\n\n\n\nvoid project(const \nTemplateList\n \nsrc, \nTemplateList\n \ndst)\n\n\nThis is a virtual function. Project multiple \nTemplates\n in and get multiple, modified, \nTemplates\n out. Especially useful in cases like detection where the requirement is image in, multiple objects out. The default implementation calls \nproject\n on each \nTemplate\n in \nsrc\n and appends the results to \ndst\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void project(const TemplateList \nsrc, TemplateList \ndst) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nInput templates. It is immutable\n\n\n\n\n\n\ndst\n\n\nTemplateList\n \n\n\nOutput templates. Should contain the modified data from the input templates\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplateList src(QList\nTemplate\n() \n Template(\"image_with_faces.jpg\")), dst;\n\nTransform *face_detector = Transform::make(\"FaceDetector\");\nface_detector-\nproject(src, dst); // dst will have one template for every face detected in src\n\n\n\n\n\n\n\nvoid projectUpdate(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nThis is a virtual function. Very similar to \nproject\n except this version is not \nconst\n and can modify the internal state of the transform.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void projectUpdate(const Template \nsrc, Template \ndst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nInput template. It is immutable\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nOutput template. Should contain the modified data from the input template.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    int internalState;\n\n    void projectUpdate(const Template \nsrc, Template \ndst)\n    {\n        dst = src;\n        internalState++;\n    }\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nTemplate src(\"picture.jpg\"), dst;\n\nTransform *example = Transform::make(\"Example\");\nexample-\nprojectUpdate(src, dst); // dst is unchanged but Example's internalState has been incremented.\n\n\n\n\n\n\n\nvoid projectUpdate(const \nTemplateList\n \nsrc, \nTemplateList\n \ndst)\n\n\nThis is a virtual function. Very similar to \nproject\n except this version is not \nconst\n and can modify the internal state of the transform.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void projectUpdate(const TemplateList \nsrc, TemplateList \ndst)\n\n\n\n\n\n\n\nparameters:\n\n\nParameter | Type | Description\n--- | --- | ---\nsrc | const [TemplateList](../templatelist/templatelist.md) \n | Input templates. It is immutable\ndst | [TemplateList](../templatelist/templatelist.md) \n | Output templates. Should contain the modified data from the input templates\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    int internalState;\n\n    void projectUpdate(const TemplateList \nsrc, TemplateList \ndst)\n    {\n        dst = src;\n        internalState++;\n    }\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nTemplateList src(QList\nTemplate\n() \n Template(\"picture.jpg\")), dst;\n\nTransform *example = Transform::make(\"Example\");\nexample-\nprojectUpdate(src, dst); // dst is unchanged but Example's internalState has been incremented.\n\n\n\n\n\n\n\nvoid projectUpdate(\nTemplate\n \nsrcdst)\n\n\nIn-place version of \nprojectUpdate\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid projectUpdate(Template \nsrcdst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrcdst\n\n\nTemplate\n \n\n\nInput and output template. It is overwritten with the output value after projecting\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    int internalState;\n\n    void projectUpdate(const Template \nsrc, Template \ndst)\n    {\n        dst = src;\n        internalState++;\n    }\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nTemplate src(\"picture.jpg\");\n\nTransform *example = Transform::make(\"Example\");\nexample-\nprojectUpdate(src); // src is modified in-place and Example's internalState has been incremented.\n\n\n\n\n\n\n\nvoid projectUpdate(\nTemplateList\n \nsrcdst)\n\n\nIn-place version of \nprojectUpdate\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid projectUpdate(TemplateList \nsrcdst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrcdst\n\n\nTemplateList\n \n\n\nInput and output templates. It is overwritten with the output value after projecting\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nclass ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    int internalState;\n\n    void projectUpdate(const TemplateList \nsrc, TemplateList \ndst)\n    {\n        dst = src;\n        internalState++;\n    }\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nTemplateList src(QList\nTemplate\n() \n Template(\"picture.jpg\"));\n\nTransform *example = Transform::make(\"Example\");\nexample-\nprojectUpdate(src); // src is modified in-place and Example's internalState has been incremented.\n\n\n\n\n\n\n\nbool timeVarying()\n\n\nThis is a virtual function. Check if the transform is time varying. Time varying means the internal state of the transform needs to be updated during projection. Time varying transforms should overload this function to return true and implement \nprojectUpdate\n instead of \nproject\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual bool timeVarying() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns true if the transform is time varying and false otherwise\n\n\n\n\nTemplate\n operator()(const \nTemplate\n \nsrc)\n\n\nA convenience function to call \nproject\n\n\n\n\n\n\nfunction definition:\n\n\ninline Template operator()(const Template \nsrc) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nInput template. It is immutable.\n\n\n\n\n\n\n\n\n\n\n\n\noutput\n: (\nTemplate\n) Returns the result of calling \nproject\n\n\n\n\nexample:\nTemplate src(\"color_picture.jpg\");\n\nTransform *color_converter = Transfrom::make(\"Read+Cvt(Gray)\");\nTemplate dst = color_converter(src); // returns a grayscale image\n\n\n\n\n\n\n\nTemplateList\n operator()(const \nTemplateList\n \nsrc)\n\n\nA convenience function to call \nproject\n\n\n\n\n\n\nfunction definition:\n\n\ninline TemplateList operator()(const TemplateList \nsrc) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nInput templates. It is immutable.\n\n\n\n\n\n\n\n\n\n\n\n\noutput\n: (\nTemplateList\n) Returns the result of calling \nproject\n\n\n\n\nexample:\nTemplateList src(QList\nTemplate\n() \n Template(\"color_picture.jpg\"));\n\nTransform *color_converter = Transfrom::make(\"Read+Cvt(Gray)\");\nTemplateList dst = color_converter(src); // returns a list of grayscale images\n\n\n\n\n\n\n\nTransform\n *smartCopy(bool \nnewTransform)\n\n\nThis is a virtual function. Only \nTimeVaryingTransforms\n need to overload this method. Similar to \nclone\n, this function returns a deep copy of the transform. Unlike \nclone\n, which copies everything, this function should copy the minimum amount required so that \nprojectUpdate\n can be called safely on the original instance and the copy returned by this function concurrently.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Transform *smartCopy(bool \nnewTransform)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnewTransform\n\n\nbool \n\n\nTrue if the returned transform is newly allocated, false otherwise. This is used to handle deallocation. If newTransform is true, the caller of this function is responsible for deallocating it. If not, a \nQSharedPointer\n can wrap the output, and it will be deallocated elsewhere.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns a pointer to a deep, smart, copy of the transform\n\n\n\n\n\n\nTransform\n *smartCopy()\n\n\nConvenience function to call \nsmartCopy\n without arguments\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Transform *smartCopy()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nTransform\n *) Returns a pointer, to a deep, smart, copy of the transform\n\n\n\n\nTransform\n *simplify(bool \nnewTransform)\n\n\nThis is a virtual function. Get a simplified version of the transform for use at project time. The simplified version of the \nTransform\n does not include any \nTransforms\n that are only active at train time. It also removes any \nLoadStore\n transforms and keeps only their children. Transforms that only are active at train time (see \nDownsampleTrainingTransform\n as an example) should overload this function and return their children if they have any or NULL if they do not.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Transform * simplify(bool \nnewTransform)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnewTransform\n\n\nbool \n\n\nTrue if the simplified transform is newly allocated, false otherwise. If true, the caller of this function is responsible for deallocating the transform.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns a pointer to the simplified version of the transform\n\n\n\n\nexample:\nTransform *transform = Transform::make(\"DataProcessing+DownsampleTraining(Example)+\nModelFile\n\");\ntransfrom-\ndescription(); // returns \"DataProcessing+DownsampleTraining(Example)+LoadStore(transformString=TransformFromModelFile)\"\n\nbool newTransform;\ntransform-\nsimplify(newTransform)-\ndescription(); // returns \"DataProcessing+Example+TransformFromModelFile\"\n\n\n\n\n\n\n\nTransform\n *make(const \nQString\n \ndescription)\n\n\nThis is a protected function. Makes a child transform from a provided description by calling \nmake\n with parent = \nthis\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline Transform *make(const QString \ndescription)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndescription\n\n\nconst \nQString\n \n\n\nDescription of the child transform\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns a pointer to the created child transform", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#clone", 
            "text": "This is a virtual function. Make a deep copy of the transform.    function definition:  virtual Transform *clone() const    parameters:  NONE   output:  ( Transform )  example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    Q_PROPERTY(int property READ get_property WRITE set_property RESET reset_property STORED false)\n    BR_PROPERTY(int, property, 1)\n\n    ...\n};\n\nTransform *transform = Transform::make(\"Example\", NULL);\ntransform- parameters(); // returns [\"property = 1\"]\n\nTransform *clone = transform- clone();\nclone- parameters(); // returns [\"property = 1\"]\n\ntransform- setProperty(\"property\", 10);\ntransform- parameters(); // returns [\"property = 10\"]\nclone- parameters(); // returns [\"property = 1\"]", 
            "title": "Transform *clone()"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#train-1", 
            "text": "This is a virtual function. Train the transform on provided training data. This function should be overloaded for any transform that needs to be trained.  Trainable  must be set to true for this function to be called. If  independent  is true a new instance of the transform will be trained for each  Mat  stored in a  Template  in the provided training data. Each  Template  should have the same number of  Mats .    function definition:  virtual void train(const TemplateList  data)    parameters:     Parameter  Type  Description      data  const  TemplateList    Training data. The format of the data depends on the transform to be trained. In some cases the transform requires a \"Label\" field in each  Template   file's   metadata  (normally these are classifiers like  SVM ). In other cases no metadata is required and training occurs on the raw image data only.       output:  (void)   example: // Create data for a 2-class classification problem\nTemplate t1(\"training_pic1.jpg\");\nt1.file.set(\"Label\", 0);\nTemplate t2(\"training_pic2.jpg\");\nt2.file.set(\"Label\", 0);\nTemplate t3(\"training_pic3.jpg\");\nt3.file.set(\"Label\", 1);\nTemplate t4(\"training_pic4.jpg\");\nt4.file.set(\"Label\", 1);\n\nTemplateList training_data(QList Template ()   t1   t2   t3   t4);\n\nTransform *classifier = Transform::make(\"DataPrep+Classifier\");\nclassifier- train(training_data); // The data is projected through DataPrep, assuming it is untrainable, and then passed to the train method of Classifier", 
            "title": "void train(const TemplateList data)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#train-2", 
            "text": "This is a virtual function. This version of train is meant for special-case, internal, transforms and for tranforms that require a specific number of templates at project time. If a transform requires a specific number of templates at project time it should be trained in batches that have the same number of templates. For example, if a transform requires exactly 5 templates when projecting it should get a list of  TemplateLists , each with exactly 5 templates, at train time. Each  TemplateList  can then be treated as an individual input to the training function.    function definition:  virtual void train(const QList   data)    parameters:     Parameter  Type  Description      data  const  QList TemplateList    Specially formatted list of training input. Format should match what is passed to  project .       output:  (void)", 
            "title": "void train(const QListTemplateList data)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#project-1", 
            "text": "This is a pure virtual function. It must be overloaded by all derived classes. Project a template through the transform, modifying its contents in some way and storing the modified data in  dst . This function has a strict  Template  in,  Template  out model. For a multiple  Template  in, multiple  Template  out model see [project]{: #project-2 }.    function definition:  virtual void project(const Template  src, Template  dst) const = 0    parameters:     Parameter  Type  Description      src  const  Template    Input template. It is immutable    dst  Template    Output template. Should contain the modified data from the input template.       output:  (void)   example: Template src(\"color_picture.jpg\"), dst;\n\nTransform *color_converter = Transfrom::make(\"Read+Cvt(Gray)\");\ncolor_converter- project(src, dst); // returns a grayscale image stored in dst", 
            "title": "void project(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#project-2", 
            "text": "This is a virtual function. Project multiple  Templates  in and get multiple, modified,  Templates  out. Especially useful in cases like detection where the requirement is image in, multiple objects out. The default implementation calls  project  on each  Template  in  src  and appends the results to  dst .    function definition:  virtual void project(const TemplateList  src, TemplateList  dst) const    parameters:     Parameter  Type  Description      src  const  TemplateList    Input templates. It is immutable    dst  TemplateList    Output templates. Should contain the modified data from the input templates       output:  (void)   example: TemplateList src(QList Template ()   Template(\"image_with_faces.jpg\")), dst;\n\nTransform *face_detector = Transform::make(\"FaceDetector\");\nface_detector- project(src, dst); // dst will have one template for every face detected in src", 
            "title": "void project(const TemplateList src, TemplateList dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#projectupdate-1", 
            "text": "This is a virtual function. Very similar to  project  except this version is not  const  and can modify the internal state of the transform.    function definition:  virtual void projectUpdate(const Template  src, Template  dst)    parameters:     Parameter  Type  Description      src  const  Template    Input template. It is immutable    dst  Template    Output template. Should contain the modified data from the input template.       output:  (void)   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    int internalState;\n\n    void projectUpdate(const Template  src, Template  dst)\n    {\n        dst = src;\n        internalState++;\n    }\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nTemplate src(\"picture.jpg\"), dst;\n\nTransform *example = Transform::make(\"Example\");\nexample- projectUpdate(src, dst); // dst is unchanged but Example's internalState has been incremented.", 
            "title": "void projectUpdate(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#projectupdate-2", 
            "text": "This is a virtual function. Very similar to  project  except this version is not  const  and can modify the internal state of the transform.    function definition:  virtual void projectUpdate(const TemplateList  src, TemplateList  dst)    parameters:  Parameter | Type | Description\n--- | --- | ---\nsrc | const [TemplateList](../templatelist/templatelist.md)   | Input templates. It is immutable\ndst | [TemplateList](../templatelist/templatelist.md)   | Output templates. Should contain the modified data from the input templates    output:  (void)   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    int internalState;\n\n    void projectUpdate(const TemplateList  src, TemplateList  dst)\n    {\n        dst = src;\n        internalState++;\n    }\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nTemplateList src(QList Template ()   Template(\"picture.jpg\")), dst;\n\nTransform *example = Transform::make(\"Example\");\nexample- projectUpdate(src, dst); // dst is unchanged but Example's internalState has been incremented.", 
            "title": "void projectUpdate(const TemplateList src, TemplateList dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#projectupdate-3", 
            "text": "In-place version of  projectUpdate .    function definition:  void projectUpdate(Template  srcdst)    parameters:     Parameter  Type  Description      srcdst  Template    Input and output template. It is overwritten with the output value after projecting       output:  (void)   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    int internalState;\n\n    void projectUpdate(const Template  src, Template  dst)\n    {\n        dst = src;\n        internalState++;\n    }\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nTemplate src(\"picture.jpg\");\n\nTransform *example = Transform::make(\"Example\");\nexample- projectUpdate(src); // src is modified in-place and Example's internalState has been incremented.", 
            "title": "void projectUpdate(Template srcdst)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#projectupdate-4", 
            "text": "In-place version of  projectUpdate .    function definition:  void projectUpdate(TemplateList  srcdst)    parameters:     Parameter  Type  Description      srcdst  TemplateList    Input and output templates. It is overwritten with the output value after projecting       output:  (void)   example: class ExampleTransform : public Transform\n{\n    Q_OBJECT\n\n    int internalState;\n\n    void projectUpdate(const TemplateList  src, TemplateList  dst)\n    {\n        dst = src;\n        internalState++;\n    }\n\n    ...\n};\n\nBR_REGISTER(Transform, ExampleTransform)\n\nTemplateList src(QList Template ()   Template(\"picture.jpg\"));\n\nTransform *example = Transform::make(\"Example\");\nexample- projectUpdate(src); // src is modified in-place and Example's internalState has been incremented.", 
            "title": "void projectUpdate(TemplateList srcdst)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#timevarying", 
            "text": "This is a virtual function. Check if the transform is time varying. Time varying means the internal state of the transform needs to be updated during projection. Time varying transforms should overload this function to return true and implement  projectUpdate  instead of  project .    function definition:  virtual bool timeVarying() const    parameters:  NONE   output:  (bool) Returns true if the transform is time varying and false otherwise", 
            "title": "bool timeVarying()"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#operator-pp-1", 
            "text": "A convenience function to call  project    function definition:  inline Template operator()(const Template  src) const    parameters:     Parameter  Type  Description      src  const  Template    Input template. It is immutable.       output : ( Template ) Returns the result of calling  project   example: Template src(\"color_picture.jpg\");\n\nTransform *color_converter = Transfrom::make(\"Read+Cvt(Gray)\");\nTemplate dst = color_converter(src); // returns a grayscale image", 
            "title": "Template operator()(const Template src)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#operator-pp-2", 
            "text": "A convenience function to call  project    function definition:  inline TemplateList operator()(const TemplateList  src) const    parameters:     Parameter  Type  Description      src  const  TemplateList    Input templates. It is immutable.       output : ( TemplateList ) Returns the result of calling  project   example: TemplateList src(QList Template ()   Template(\"color_picture.jpg\"));\n\nTransform *color_converter = Transfrom::make(\"Read+Cvt(Gray)\");\nTemplateList dst = color_converter(src); // returns a list of grayscale images", 
            "title": "TemplateList operator()(const TemplateList src)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#smartcopy-1", 
            "text": "This is a virtual function. Only  TimeVaryingTransforms  need to overload this method. Similar to  clone , this function returns a deep copy of the transform. Unlike  clone , which copies everything, this function should copy the minimum amount required so that  projectUpdate  can be called safely on the original instance and the copy returned by this function concurrently.    function definition:  virtual Transform *smartCopy(bool  newTransform)    parameters:     Parameter  Type  Description      newTransform  bool   True if the returned transform is newly allocated, false otherwise. This is used to handle deallocation. If newTransform is true, the caller of this function is responsible for deallocating it. If not, a  QSharedPointer  can wrap the output, and it will be deallocated elsewhere.       output:  ( Transform  *) Returns a pointer to a deep, smart, copy of the transform", 
            "title": "Transform *smartCopy(bool newTransform)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#smartcopy-2", 
            "text": "Convenience function to call  smartCopy  without arguments    function definition:  virtual Transform *smartCopy()    parameters:  NONE   output:  ( Transform  *) Returns a pointer, to a deep, smart, copy of the transform", 
            "title": "Transform *smartCopy()"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#simplify", 
            "text": "This is a virtual function. Get a simplified version of the transform for use at project time. The simplified version of the  Transform  does not include any  Transforms  that are only active at train time. It also removes any  LoadStore  transforms and keeps only their children. Transforms that only are active at train time (see  DownsampleTrainingTransform  as an example) should overload this function and return their children if they have any or NULL if they do not.    function definition:  virtual Transform * simplify(bool  newTransform)    parameters:     Parameter  Type  Description      newTransform  bool   True if the simplified transform is newly allocated, false otherwise. If true, the caller of this function is responsible for deallocating the transform.       output:  ( Transform  *) Returns a pointer to the simplified version of the transform   example: Transform *transform = Transform::make(\"DataProcessing+DownsampleTraining(Example)+ ModelFile \");\ntransfrom- description(); // returns \"DataProcessing+DownsampleTraining(Example)+LoadStore(transformString=TransformFromModelFile)\"\n\nbool newTransform;\ntransform- simplify(newTransform)- description(); // returns \"DataProcessing+Example+TransformFromModelFile\"", 
            "title": "Transform *simplify(bool newTransform)"
        }, 
        {
            "location": "/api_docs/cpp_api/transform/functions/#make", 
            "text": "This is a protected function. Makes a child transform from a provided description by calling  make  with parent =  this .    function definition:  inline Transform *make(const QString  description)    parameters:     Parameter  Type  Description      description  const  QString    Description of the child transform       output:  ( Transform  *) Returns a pointer to the created child transform", 
            "title": "Transform *make(const QString description)"
        }, 
        {
            "location": "/api_docs/cpp_api/untrainabletransform/untrainabletransform/", 
            "text": "Inherits \nTransform\n\n\nA \nTransform\n that does not require training.\n\n\nSee:\n\n\n\n\nConstructors\n\n\n\n\nThis is a base class for \nTransforms\n that are not trainable. It overloads \ntrain\n, \nload\n, and \nstore\n so that they cannot be used in derived classes. Load and store are overloaded because a \nTransform\n that doesn't train should also have nothing to save.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/untrainabletransform/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUntrainableTransform(bool independent = true)\n\n\nConstruct an \nUntrainableTransform\n. This constructor calls the \nTransform\n \nconstructor\n with the provided value for \nindependent\n and \ntrainable\n set to false.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/metatransform/metatransform/", 
            "text": "Inherits \nTransform\n\n\nA \nTransform\n that expect multiple matrices per \nTemplate\n\n\nSee:\n\n\n\n\nConstructors\n\n\n\n\nMetaTransforms\n are \nTransforms\n that are not \nindependent\n. This means they expect more then one matrix in each input \nTemplate\n and a new instance of the transform should not be created for each matrix.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/metatransform/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMetaTransform()\n\n\nConstruct a \nMetaTransform\n. This constructor calls the \nTransform\n \nconstructor\n with \nindependent\n set to false.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/untrainablemetatransform/untrainablemetatransform/", 
            "text": "Inherits \nUntrainableTransform\n\n\nA \nTransform\n that expect multiple matrices per \nTemplate\n and is not \ntrainable\n\n\nSee:\n\n\n\n\nConstructors\n\n\n\n\nUntrainableMetaTransforms\n are \nUntrainableTransforms\n that are not \nindependent\n. This means they expect more then one matrix in each input \nTemplate\n and a new instance of the transform should not be created for each matrix.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/untrainablemetatransform/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUntrainableMetaTransform()\n\n\nConstruct an \nUntrainableMetaTransform\n. This constructor calls the \nUntrainableTransform\n \nconstructor\n with \nindependent\n set to false.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/metadatatransform/metadatatransform/", 
            "text": "Inherits \nTransform\n\n\nA \nTransform\n that requires only \nTemplate\n \nmetadata\n\n\nSee:\n\n\n\n\nConstructors\n\n\nFunctions\n\n\n\n\nMetadataTransforms\n are \nTransforms\n that operate soley on textual \nmetadata\n. They are \nnot\n \nindependent\n because \nTemplates\n can only every have one collection of \nmetadata\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/metadatatransform/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMetadataTransform(bool trainable = true)\n\n\nConstruct a \nMetadataTransform\n. This constructor calls the \nTransform\n \nconstructor\n with the provided value for \ntrainable\n and \nindependent\n set to false.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/metadatatransform/functions/", 
            "text": "void projectMetadata(const \nFile\n \nsrc, \nFile\n \ndst)\n\n\nThis is a pure virtual function. It must be overloaded by all derived classes. Project a \nTemplate's\n \nmetadata\n through the transform, modifying its contents in some way and storing the modified data in \ndst\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void projectMetadata(const File \nsrc, File \ndst) const = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nFile\n \n\n\nInput File. It is immutable\n\n\n\n\n\n\ndst\n\n\nFile\n \n\n\nOutput File. Should contain the modified data from the input template.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nclass IncrementPropertyTransform : public MetadataTransform\n{\n    Q_OBJECT\n    Q_PROPERTY(QString key READ get_key WRITE set_key RESET reset_key STORED false)\n    BR_PROPERTY(QString, key, \"\")\n\n    void projectMetadata(const File \nsrc, File \ndst) const\n    {\n        dst = src;\n        dst.set(key, src.get\nint\n(key, 0) + 1);\n    }\n};\n\nBR_REGISTER(Transform, IncrementPropertyTransform)\n\nMetadataTransform *m_transform = (MetadataTransform *)Transform::make(\"IncrementProperty(property1)\", NULL);\n\nFile in(\"picture.jpg\"), out;\nin.set(\"property1\", 10);\n\nm_transform-\nprojectMetadata(in, out);\nout.flat(); // Returns \"picture.jpg[property1=11]\"\n\n\n\n\n\n\n\nvoid project(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nProject a \nTemplate\n through the transform by passing its \nmetadata\n through \nprojectMetadata\n and storing the result in dst. All matrices in src are passed unchanged to dst.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid project(const Template \nsrc, Template \ndst) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nInput Template. It is immutable\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nOutput Template. Should contain the modified data from the input template.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/metadatatransform/functions/#projectmetadata", 
            "text": "This is a pure virtual function. It must be overloaded by all derived classes. Project a  Template's   metadata  through the transform, modifying its contents in some way and storing the modified data in  dst .    function definition:  virtual void projectMetadata(const File  src, File  dst) const = 0    parameters:     Parameter  Type  Description      src  const  File    Input File. It is immutable    dst  File    Output File. Should contain the modified data from the input template.       output:  (void)   example: class IncrementPropertyTransform : public MetadataTransform\n{\n    Q_OBJECT\n    Q_PROPERTY(QString key READ get_key WRITE set_key RESET reset_key STORED false)\n    BR_PROPERTY(QString, key, \"\")\n\n    void projectMetadata(const File  src, File  dst) const\n    {\n        dst = src;\n        dst.set(key, src.get int (key, 0) + 1);\n    }\n};\n\nBR_REGISTER(Transform, IncrementPropertyTransform)\n\nMetadataTransform *m_transform = (MetadataTransform *)Transform::make(\"IncrementProperty(property1)\", NULL);\n\nFile in(\"picture.jpg\"), out;\nin.set(\"property1\", 10);\n\nm_transform- projectMetadata(in, out);\nout.flat(); // Returns \"picture.jpg[property1=11]\"", 
            "title": "void projectMetadata(const File src, File dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/metadatatransform/functions/#project", 
            "text": "Project a  Template  through the transform by passing its  metadata  through  projectMetadata  and storing the result in dst. All matrices in src are passed unchanged to dst.    function definition:  void project(const Template  src, Template  dst) const    parameters:     Parameter  Type  Description      src  const  Template    Input Template. It is immutable    dst  Template    Output Template. Should contain the modified data from the input template.       output:  (void)", 
            "title": "void project(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/untrainablemetadatatransform/untrainablemetadatatransform/", 
            "text": "Inherits \nMetadataTransform\n\n\nA \nTransform\n that requires only \nTemplate\n \nmetadata\n and does not require training.\n\n\nSee:\n\n\n\n\nConstructors\n\n\n\n\nUntrainableMetadataTransforms\n are \nTransforms\n that operate soley on textual \nmetadata\n. They are \nnot\n \nindependent\n, because \nTemplates\n can only every have one collection of \nmetadata\n, and they are \nnot\n \ntrainable\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/untrainablemetadatatransform/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUntrainableMetadataTransform()\n\n\nConstruct an \nUntrainableMetadataTransform\n. This constructor calls the \nMetadataTransform\n \nconstructor\n with \ntrainable\n set to false.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/timevaryingtransform/", 
            "text": "Inherits \nTransform\n\n\nA \nTransform\n that can change state at project time.\n\n\nSee:\n\n\n\n\nMembers\n\n\nConstructors\n\n\nFunctions\n\n\n\n\nTimeVaryingTransforms are \nTransforms\n that need to change their state at project time. This is opposed to \nTransforms\n which can only change state at train time. Common examples include video processing across multiple frames, aggregate projection statistics etc.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/members/", 
            "text": "Members\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n timeInvariantAlias\n\n\nTimeInvariantWrapperTransform\n\n\nA special case helper class that ensures usually thread safe calls like \nproject\n can be called non-thread safe objects. In a very simplified description, this calls \nprojectUpdate\n instead of \nproject", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/constructors/", 
            "text": "Constructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTimeVaryingTransform(bool independent = true, bool trainable = true)\n\n\nDefault constructor. Calls \nTransform\n \nconstructor\n with the given value of \nindependent\n and \ntrainable\n. It also initializes \ntimeInvariantAlias\n.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/", 
            "text": "bool timeVarying()\n\n\nThis is a virtual function. Check if the transform is time varying. This always evaluates to true.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual bool timeVarying() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns true (the transform is always time varying)\n\n\n\n\nvoid project(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nThis is a virtual function. For \nTimeVaryingTransforms\n normal enrollment calls \nprojectUpdate\n. It is still possible to call this version of project instead but it must be done explicitly and is \nstrongly\n discouraged. If this function is called \ntimeInvariantAlias\n is used to call \nprojectUpdate\n in a thread safe way.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void project(const Template \nsrc, Template \ndst) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nThe input template\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nThe output template\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid project(const \nTemplateList\n \nsrc, \nTemplateList\n \ndst)\n\n\nThis is a virtual function. For \nTimeVaryingTransforms\n normal enrollment calls \nprojectUpdate\n. It is still possible to call this version of project instead but it must be done explicitly and is \nstrongly\n discouraged. If this function is called \ntimeInvariantAlias\n is used to call \nprojectUpdate\n in a thread safe way.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void project(const TemplateList \nsrc, TemplateList \ndst) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nThe input template list\n\n\n\n\n\n\ndst\n\n\nTemplateList\n \n\n\nThe output template list\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid projectUpdate(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nThis is a virtual function. This function should never be called because it is useless to implement a Template -\n Template call using project update. An error is thrown if it is called.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void projectUpdate(const Template \nsrc, Template \ndst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nThe input template\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nThe output template\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid projectUpdate(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nThis is a virtual function. This function should never be called because it is useless to implement a Template -\n Template call using project update. An error is thrown if it is called.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void projectUpdate(const Template \nsrc, Template \ndst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nThe input template\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nThe output template\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid projectUpdate(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nThis is a virtual function. This function should never be called because it is useless to implement a Template -\n Template call using project update. An error is thrown if it is called.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void projectUpdate(const Template \nsrc, Template \ndst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nThe input template\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nThe output template\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid projectUpdate(const \nTemplateList\n \nsrc, \nTemplateList\n \ndst)\n\n\nThis is a virtual function. This is the non-const alternative to \nproject\n. It allows the internal state of the transform to be update at project time.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void projectUpdate(const TemplateList \nsrc, TemplateList \ndst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nThe input template list\n\n\n\n\n\n\ndst\n\n\nTemplateList\n \n\n\nThe output template list\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nTransform\n *smartCopy(bool \nnewTransform)\n\n\nThis is a virtual function. Make a smart copy of the transform.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Transform *smartCopy(bool \nnewTransform)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnewTransform\n\n\nbool \n\n\nTrue if a new, simplified, transform was allocated inside this call, false otherwise\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns a copy of itself by default. newTransform is set to true in this case.", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/#timevarying", 
            "text": "This is a virtual function. Check if the transform is time varying. This always evaluates to true.    function definition:  virtual bool timeVarying() const    parameters:  NONE   output:  (bool) Returns true (the transform is always time varying)", 
            "title": "bool timeVarying()"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/#project-1", 
            "text": "This is a virtual function. For  TimeVaryingTransforms  normal enrollment calls  projectUpdate . It is still possible to call this version of project instead but it must be done explicitly and is  strongly  discouraged. If this function is called  timeInvariantAlias  is used to call  projectUpdate  in a thread safe way.    function definition:  virtual void project(const Template  src, Template  dst) const    parameters:     Parameter  Type  Description      src  const  Template    The input template    dst  Template    The output template       output:  (void)", 
            "title": "void project(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/#project-2", 
            "text": "This is a virtual function. For  TimeVaryingTransforms  normal enrollment calls  projectUpdate . It is still possible to call this version of project instead but it must be done explicitly and is  strongly  discouraged. If this function is called  timeInvariantAlias  is used to call  projectUpdate  in a thread safe way.    function definition:  virtual void project(const TemplateList  src, TemplateList  dst) const    parameters:     Parameter  Type  Description      src  const  TemplateList    The input template list    dst  TemplateList    The output template list       output:  (void)", 
            "title": "void project(const TemplateList src, TemplateList dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/#projectupdate-1", 
            "text": "This is a virtual function. This function should never be called because it is useless to implement a Template -  Template call using project update. An error is thrown if it is called.    function definition:  virtual void projectUpdate(const Template  src, Template  dst)    parameters:     Parameter  Type  Description      src  const  Template    The input template    dst  Template    The output template       output:  (void)", 
            "title": "void projectUpdate(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/#projectupdate-1", 
            "text": "This is a virtual function. This function should never be called because it is useless to implement a Template -  Template call using project update. An error is thrown if it is called.    function definition:  virtual void projectUpdate(const Template  src, Template  dst)    parameters:     Parameter  Type  Description      src  const  Template    The input template    dst  Template    The output template       output:  (void)", 
            "title": "void projectUpdate(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/#projectupdate-1", 
            "text": "This is a virtual function. This function should never be called because it is useless to implement a Template -  Template call using project update. An error is thrown if it is called.    function definition:  virtual void projectUpdate(const Template  src, Template  dst)    parameters:     Parameter  Type  Description      src  const  Template    The input template    dst  Template    The output template       output:  (void)", 
            "title": "void projectUpdate(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/#projectupdate-2", 
            "text": "This is a virtual function. This is the non-const alternative to  project . It allows the internal state of the transform to be update at project time.    function definition:  virtual void projectUpdate(const TemplateList  src, TemplateList  dst)    parameters:     Parameter  Type  Description      src  const  TemplateList    The input template list    dst  TemplateList    The output template list       output:  (void)", 
            "title": "void projectUpdate(const TemplateList src, TemplateList dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/timevaryingtransform/functions/#smartcopy", 
            "text": "This is a virtual function. Make a smart copy of the transform.    function definition:  virtual Transform *smartCopy(bool  newTransform)    parameters:     Parameter  Type  Description      newTransform  bool   True if a new, simplified, transform was allocated inside this call, false otherwise       output:  ( Transform  *) Returns a copy of itself by default. newTransform is set to true in this case.", 
            "title": "Transform *smartCopy(bool newTransform)"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/compositetransform/", 
            "text": "Inherits \nTimeVaryingTransform\n\n\nBase class for \nTransforms\n that aggregate subtransforms.\n\n\nSee:\n\n\n\n\nProperties\n\n\nMembers\n\n\nConstructors\n\n\nFunctions\n\n\n\n\nCompositeTransforms are the base class for \nTransforms\n that have a list of child transforms. It is used internally for plugins like pipes and forks. It inherits from \nTimeVaryingTransform\n so that it can properly handle having children (one or many) that are time varying.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/properties/", 
            "text": "Property\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntransforms\n\n\nQList\nTransform\n*\n\n\nList of child transforms", 
            "title": "Properties"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nisTimeVarying\n\n\nbool\n\n\nTrue if any child transform is time varying, false otherwise", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/constructors/", 
            "text": "Constructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCompositeTransform()\n\n\nDefault constructor. Calls the \nTimeVaryingTransform\n \nconstructor\n with \nindependent\n set to false.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/", 
            "text": "bool timeVarying()\n\n\nCheck if the transform is time varying. The transform is time varying if any of its children are time varying.\n\n\n\n\n\n\nfunction definition:\n\n\nbool timeVarying() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns \nisTimeVarying\n\n\n\n\nvoid init()\n\n\nInitialize the transform. If any of the child transform are time varying, \nisTimeVarying\n is set to true. Similarly if any of the child transforms are trainable, \ntrainable\n is set to true.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid init()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)\n\n\n\n\nvoid project(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nIf the transform is time varying call \ntimeInvariantAlias\n project, which ensures thread safety. If the transform is not time varying call \n_project\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void project(const Template \nsrc, Template \ndst) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nThe input template\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nThe output template\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid project(const \nTemplateList\n \nsrc, \nTemplateList\n \ndst)\n\n\nIf the transform is time varying call \ntimeInvariantAlias\n project, which ensures thread safety. If the transform is not time varying call \n_project\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void project(const TemplateList \nsrc, TemplateList \ndst) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nThe input template list\n\n\n\n\n\n\ndst\n\n\nTemplateList \n \n\n\nThe output template list\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid _project(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nThis is a pure virtual function. It should handle standard projection through the child transforms\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void _project(const Template \nsrc, Template \ndst) const = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nThe input template\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nThe output template\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid _project(const \nTemplateList\n \nsrc, \nTemplateList\n \ndst)\n\n\nThis is a pure virtual function. It should handle standard projection through the child transforms\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void _project(const TemplateList \nsrc, TemplateList \ndst) const = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nThe input template list\n\n\n\n\n\n\ndst\n\n\nTemplateList\n \n\n\nThe output template list\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nTransform\n *simplify(bool \nnewTransform)\n\n\nThis is a virtual function. Calls \nsimplify\n on each child transform.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Transform *simplify(bool \nnewTransform)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnewTransform\n\n\nbool \n\n\nTrue if a new, simplified, transform was allocated inside this call, false otherwise\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns itself if none of the children can be simplified. newTransform is false in this case. If any child can be simplified a new \nCompositeTransform\n is allocated and its children are set as the result of calling simplify on each of the old children. newTransform is true in this case\n\n\n\n\n\n\nTransform\n *smartCopy(bool \nnewTransform)\n\n\nGet a smart copy, meaning a copy only if one is required, of this transform\n\n\n\n\n\n\nfunction definition:\n\n\nTransform *smartCopy(bool \nnewTransform)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnewTransform\n\n\nbool \n\n\nTrue if a new, simplified, transform was allocated inside this call, false otherwise\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns itself if \nisTimeVarying\n is false (no copy needed). newTransform is set to false in this case. If \nisTimeVarying\n is true, a new \nCompositeTransform\n is allocated and its children are set to the result of calling smartCopy on each of the old children. newTransform is true in this case.", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/#timevarying", 
            "text": "Check if the transform is time varying. The transform is time varying if any of its children are time varying.    function definition:  bool timeVarying() const    parameters:  NONE   output:  (bool) Returns  isTimeVarying", 
            "title": "bool timeVarying()"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/#init", 
            "text": "Initialize the transform. If any of the child transform are time varying,  isTimeVarying  is set to true. Similarly if any of the child transforms are trainable,  trainable  is set to true.    function definition:  void init()    parameters:  NONE   output:  (void)", 
            "title": "void init()"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/#project-1", 
            "text": "If the transform is time varying call  timeInvariantAlias  project, which ensures thread safety. If the transform is not time varying call  _project .    function definition:  virtual void project(const Template  src, Template  dst) const    parameters:     Parameter  Type  Description      src  const  Template    The input template    dst  Template    The output template       output:  (void)", 
            "title": "void project(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/#project-2", 
            "text": "If the transform is time varying call  timeInvariantAlias  project, which ensures thread safety. If the transform is not time varying call  _project .    function definition:  virtual void project(const TemplateList  src, TemplateList  dst) const    parameters:     Parameter  Type  Description      src  const  TemplateList    The input template list    dst  TemplateList     The output template list       output:  (void)", 
            "title": "void project(const TemplateList src, TemplateList dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/#_project-1", 
            "text": "This is a pure virtual function. It should handle standard projection through the child transforms    function definition:  virtual void _project(const Template  src, Template  dst) const = 0    parameters:     Parameter  Type  Description      src  const  Template    The input template    dst  Template    The output template       output:  (void)", 
            "title": "void _project(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/#_project-2", 
            "text": "This is a pure virtual function. It should handle standard projection through the child transforms    function definition:  virtual void _project(const TemplateList  src, TemplateList  dst) const = 0    parameters:     Parameter  Type  Description      src  const  TemplateList    The input template list    dst  TemplateList    The output template list       output:  (void)", 
            "title": "void _project(const TemplateList src, TemplateList dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/#simplify", 
            "text": "This is a virtual function. Calls  simplify  on each child transform.    function definition:  virtual Transform *simplify(bool  newTransform)    parameters:     Parameter  Type  Description      newTransform  bool   True if a new, simplified, transform was allocated inside this call, false otherwise       output:  ( Transform  *) Returns itself if none of the children can be simplified. newTransform is false in this case. If any child can be simplified a new  CompositeTransform  is allocated and its children are set as the result of calling simplify on each of the old children. newTransform is true in this case", 
            "title": "Transform *simplify(bool newTransform)"
        }, 
        {
            "location": "/api_docs/cpp_api/compositetransform/functions/#smartcopy", 
            "text": "Get a smart copy, meaning a copy only if one is required, of this transform    function definition:  Transform *smartCopy(bool  newTransform)    parameters:     Parameter  Type  Description      newTransform  bool   True if a new, simplified, transform was allocated inside this call, false otherwise       output:  ( Transform  *) Returns itself if  isTimeVarying  is false (no copy needed). newTransform is set to false in this case. If  isTimeVarying  is true, a new  CompositeTransform  is allocated and its children are set to the result of calling smartCopy on each of the old children. newTransform is true in this case.", 
            "title": "Transform *smartCopy(bool newTransform)"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/wrappertransform/", 
            "text": "Inherits \nTimeVaryingTransform\n\n\nBase class for \nTransforms\n that have a single child transform\n\n\nSee:\n\n\n\n\nProperties\n\n\nConstructors\n\n\nFunctions\n\n\n\n\nWrapperTransforms are the base class for plugins that have a child transform. It inherits from \nTimeVaryingTransform\n so that it can properly handle a child transform that is also time varying, WrapperTransform itself has no requirement to be time varying. The main purpose of WrapperTransform is to intelligently implement \nsimplify\n and \nsmartCopy\n, all other calls are just passed to the child.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/properties/", 
            "text": "Property\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntransform\n\n\nTransform\n *\n\n\nThe child transform", 
            "title": "Properties"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/constructors/", 
            "text": "Constructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nWrapperTransform(bool independent = true)\n\n\nDefault constructor. Calls \nTimeVaryingTransform\n \nconstructor\n with the given value for independent.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/", 
            "text": "bool timeVarying()\n\n\nCheck whether the transform is timeVarying.\n\n\n\n\n\n\nfunction definition:\n\n\nbool timeVarying() const\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns true if the \nchild transform\n is time varying, false otherwise\n\n\n\n\nvoid train(const \nQList\n[TemplateList][../templatelist/templatelist.md)\n \ndata)\n\n\nCall train on the child transform\n\n\n\n\n\n\nfunction defintion:\n\n\nvoid train(const QList\nTemplateList\n \ndata)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nconst \nQList\nTemplateList\n \n\n\nThe training data\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid project(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nCall project on the child transform\n\n\n\n\n\n\nfunction definition:\n\n\nvoid project(const Template \nsrc, Template \ndst) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nThe input template\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nThe output template\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid project(const \nTemplateList\n \nsrc, \nTemplateList\n \ndst)\n\n\nCall project on the child transform\n\n\n\n\n\n\nfunction definition:\n\n\nvoid project(const TemplateList \nsrc, TemplateList \ndst) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nThe input template list\n\n\n\n\n\n\ndst\n\n\nTemplateList\n \n\n\nThe output template list\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid projectUpdate(const \nTemplate\n \nsrc, \nTemplate\n \ndst)\n\n\nCall projectUpdate on the child transform\n\n\n\n\n\n\nfunction definition:\n\n\nvoid projectUpdate(const Template \nsrc, Template \ndst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplate\n \n\n\nThe input template\n\n\n\n\n\n\ndst\n\n\nTemplate\n \n\n\nThe output template\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid projectUpdate(const \nTemplateList\n \nsrc, \nTemplateList\n \ndst)\n\n\nCall projectUpdate on the child transform\n\n\n\n\n\n\nfunction definition:\n\n\nvoid projectUpdate(const TemplateList \nsrc, TemplateList \ndst)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nThe input template list\n\n\n\n\n\n\ndst\n\n\nTemplateList\n \n\n\nThe output template list\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid init()\n\n\nInitialize the transform. Sets \ntrainable\n to match the child transform (if the child is trainable so is the wrapper)\n\n\n\n\n\n\nfunction definition:\n\n\nvoid init()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)\n\n\n\n\nvoid finalize(\nTemplateList\n \noutput)\n\n\nThis is a virtual function. Call finalize on the child transform\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void finalize(TemplateList \noutput)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noutput\n\n\nconst \nTemplateList\n \n\n\nThe output to finalize\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nTransform\n *simplify(bool \nnewTransform)\n\n\nThis is a virtual function. Calls simplify on the child transform.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Transform *simplify(bool \nnewTransform)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnewTransform\n\n\nbool \n\n\nTrue if a new, simplified, transform was allocated inside this call, false otherwise\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns itself if the child transform cannot be simplified. newTransform is set to false in this case. If the child can be simplified, a new WrapperTransform is allocated with the child transform set as the simplified version of the old child transform. newTransform is set to true in this case\n\n\n\n\n\n\nTransform\n *smartCopy(bool \nnewTransform)\n\n\nGet a smart copy, meaning a copy only if one is required, of this transform\n\n\n\n\n\n\nfunction definition:\n\n\nTransform *smartCopy(bool \nnewTransform)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnewTransform\n\n\nbool \n\n\nTrue if a new, simplified, transform was allocated inside this call, false otherwise\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTransform\n *) Returns itself if the child transform is not time varying (no copy needed). newTransform is set to false in this case. If the child is time varying make a copy by calling \nsmartCopy\n on the child. newTransform is set to true in this case.", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#timevarying", 
            "text": "Check whether the transform is timeVarying.    function definition:  bool timeVarying() const    parameters:  NONE   output:  (bool) Returns true if the  child transform  is time varying, false otherwise", 
            "title": "bool timeVarying()"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#train", 
            "text": "Call train on the child transform    function defintion:  void train(const QList TemplateList   data)    parameters:     Parameter  Type  Description      data  const  QList TemplateList    The training data       output:  (void)", 
            "title": "void train(const QList[TemplateList][../templatelist/templatelist.md) data)"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#project-1", 
            "text": "Call project on the child transform    function definition:  void project(const Template  src, Template  dst) const    parameters:     Parameter  Type  Description      src  const  Template    The input template    dst  Template    The output template       output:  (void)", 
            "title": "void project(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#project-2", 
            "text": "Call project on the child transform    function definition:  void project(const TemplateList  src, TemplateList  dst) const    parameters:     Parameter  Type  Description      src  const  TemplateList    The input template list    dst  TemplateList    The output template list       output:  (void)", 
            "title": "void project(const TemplateList src, TemplateList dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#projectupdate-1", 
            "text": "Call projectUpdate on the child transform    function definition:  void projectUpdate(const Template  src, Template  dst)    parameters:     Parameter  Type  Description      src  const  Template    The input template    dst  Template    The output template       output:  (void)", 
            "title": "void projectUpdate(const Template src, Template dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#projectupdate-2", 
            "text": "Call projectUpdate on the child transform    function definition:  void projectUpdate(const TemplateList  src, TemplateList  dst)    parameters:     Parameter  Type  Description      src  const  TemplateList    The input template list    dst  TemplateList    The output template list       output:  (void)", 
            "title": "void projectUpdate(const TemplateList src, TemplateList dst)"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#init", 
            "text": "Initialize the transform. Sets  trainable  to match the child transform (if the child is trainable so is the wrapper)    function definition:  void init()    parameters:  NONE   output:  (void)", 
            "title": "void init()"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#finalize", 
            "text": "This is a virtual function. Call finalize on the child transform    function definition:  virtual void finalize(TemplateList  output)    parameters:     Parameter  Type  Description      output  const  TemplateList    The output to finalize       output:  (void)", 
            "title": "void finalize(TemplateList output)"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#simplify", 
            "text": "This is a virtual function. Calls simplify on the child transform.    function definition:  virtual Transform *simplify(bool  newTransform)    parameters:     Parameter  Type  Description      newTransform  bool   True if a new, simplified, transform was allocated inside this call, false otherwise       output:  ( Transform  *) Returns itself if the child transform cannot be simplified. newTransform is set to false in this case. If the child can be simplified, a new WrapperTransform is allocated with the child transform set as the simplified version of the old child transform. newTransform is set to true in this case", 
            "title": "Transform *simplify(bool newTransform)"
        }, 
        {
            "location": "/api_docs/cpp_api/wrappertransform/functions/#smartcopy", 
            "text": "Get a smart copy, meaning a copy only if one is required, of this transform    function definition:  Transform *smartCopy(bool  newTransform)    parameters:     Parameter  Type  Description      newTransform  bool   True if a new, simplified, transform was allocated inside this call, false otherwise       output:  ( Transform  *) Returns itself if the child transform is not time varying (no copy needed). newTransform is set to false in this case. If the child is time varying make a copy by calling  smartCopy  on the child. newTransform is set to true in this case.", 
            "title": "Transform *smartCopy(bool newTransform)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/distance/", 
            "text": "Inherits \nObject\n\n\nPlugin base class for comparing two \nTemplates\n\n\nSee:\n\n\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nDistances are used to find the \ndistance\n or \nsimilarity\n between two feature vectors. A \ndistance\n is defined such that a higher value indicates a larger difference between templates. A \nsimilarity\n is the opposite, higher values indicate a smaller difference between templates (they are more similar).", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtual ~Distance()\n\n\nThe default destructor. It doesn't do anything.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/statics/", 
            "text": "Distance\n *make(\nQString\n str, \nQObject\n *parent)\n\n\nMake a \nDistance\n from a string. This function converts the abbreviation character \n+\n into it's full-length alternative.\n\n\n\n\n\n\n\n\nAbbreviation\n\n\nTranslation\n\n\n\n\n\n\n\n\n\n\n+\n\n\nPipeDistance\n. Each \nDistance\n linked by a \n+\n is turned into a child of a single \nPipeDistance\n. \"Distance1+Distance2\" becomes \"Pipe([Distance1,Distance2])\". \nTemplates\n are projected through the children of a pipe in series, the output of one become the input of the next.\n\n\n\n\n\n\n\n\nThe expanded string is then passed to \nFactory\n::\nmake\n to be turned into a distance.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic Distance *make(QString str, QObject *parent)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstr\n\n\nQString\n\n\nString describing the distance\n\n\n\n\n\n\nparent\n\n\nQObject\n *\n\n\nParent of the object to be created\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nDistance\n *) Returns a pointer to the \nDistance\n described by the string\n\n\n\n\nsee:\n \nFactory::make\n\n\nexample:\nDistance::make(\"Distance1+Distance2+Distance3\")-\ndescription(); // returns \"Pipe(distances=[Distance1,Distance2,Distance3])\".\n\n\n\n\n\n\n\nQSharedPointer\nDistance\n fromAlgorithm(const \nQString\n \nalgorithm)\n\n\nCreate a \nDistance\n from an OpenBR algorithm string. The \nDistance\n is created using everything to the right of a \n:\n or a \n!\n in the string.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic QSharedPointer\nDistance\n fromAlgorithm(const QString \nalgorithm)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalgorithm\n\n\nconst \nQString\n \n\n\nAlgorithm string to construct the \nDistance\n from\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQSharedPointer\nDistance\n) Returns a pointer to the \nDistance\n described by the algorithm.\n\n\n\n\n\n\nexample:\n\n\nDistance::fromAlgorithm(\"EnrollmentTransform:Distance\")-\ndecription(); // returns \"Distance\"\nDistance::fromAlgorithm(\"EnrollmentTransform!Distance1+Distance2\")-\ndecription(); // returns \"Pipe(distances=[Distance1,Distance2])", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/statics/#make", 
            "text": "Make a  Distance  from a string. This function converts the abbreviation character  +  into it's full-length alternative.     Abbreviation  Translation      +  PipeDistance . Each  Distance  linked by a  +  is turned into a child of a single  PipeDistance . \"Distance1+Distance2\" becomes \"Pipe([Distance1,Distance2])\".  Templates  are projected through the children of a pipe in series, the output of one become the input of the next.     The expanded string is then passed to  Factory :: make  to be turned into a distance.    function definition:  static Distance *make(QString str, QObject *parent)    parameters:     Parameter  Type  Description      str  QString  String describing the distance    parent  QObject  *  Parent of the object to be created       output:  ( Distance  *) Returns a pointer to the  Distance  described by the string   see:   Factory::make  example: Distance::make(\"Distance1+Distance2+Distance3\")- description(); // returns \"Pipe(distances=[Distance1,Distance2,Distance3])\".", 
            "title": "Distance *make(QString str, QObject *parent)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/statics/#fromalgorithm", 
            "text": "Create a  Distance  from an OpenBR algorithm string. The  Distance  is created using everything to the right of a  :  or a  !  in the string.    function definition:  static QSharedPointer Distance  fromAlgorithm(const QString  algorithm)    parameters:     Parameter  Type  Description      algorithm  const  QString    Algorithm string to construct the  Distance  from       output:  ( QSharedPointer Distance ) Returns a pointer to the  Distance  described by the algorithm.    example:  Distance::fromAlgorithm(\"EnrollmentTransform:Distance\")- decription(); // returns \"Distance\"\nDistance::fromAlgorithm(\"EnrollmentTransform!Distance1+Distance2\")- decription(); // returns \"Pipe(distances=[Distance1,Distance2])", 
            "title": "QSharedPointerDistance fromAlgorithm(const QString algorithm)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/", 
            "text": "bool trainable()\n\n\nThis is a virtual function. Check if the distance is trainable. The default version returns true. Distances that are not trainable should derive from \nUntrainableDistance\n instead.\n\n\n\n\n\n\nfunction defintion:\n\n\nvirtual bool trainable()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns true if the distance is trainable, false otherwise.\n\n\n\n\nvoid train(const \nTemplateList\n \nsrc)\n\n\nThis is a pure virtual function. Train the distance on a provided \nTemplateList\n of data. The structure of the data is dependent on the distance to be trained. Distances that are not trainable should derive from \nUntrainableDistance\n so they do not have to overload this function.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void train(const TemplateList \nsrc) = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc\n\n\nconst \nTemplateList\n \n\n\nTraining data for the distance.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\n// Create data for a 2-class classification problem\nTemplate t1(\"training_pic1.jpg\");\nt1.file.set(\"Label\", 0);\nTemplate t2(\"training_pic2.jpg\");\nt2.file.set(\"Label\", 0);\nTemplate t3(\"training_pic3.jpg\");\nt3.file.set(\"Label\", 1);\nTemplate t4(\"training_pic4.jpg\");\nt4.file.set(\"Label\", 1);\n\nTemplateList training_data(QList\nTemplate\n() \n t1 \n t2 \n t3 \n t4);\n\nTransform *distance = Distance::fromAlgorithm(\"Enrollment:Distance\");\ndistance-\ntrain(training_data); // Images are enrolled through Enrollment and the passed to Distance for training\n\n\n\n\n\n\n\nvoid compare(const \nTemplateList\n \ntarget, const [TemplateList] \nquery, \nOutput\n)\n\n\nThis is a virtual function. Compare two \nTemplateLists\n and store the results in a provided output.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void compare(const TemplateList \ntarget, const TemplateList \nquery, Output *output) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntarget\n\n\nconst \nTemplateList\n \n\n\nList of templates to compare the query against\n\n\n\n\n\n\nquery\n\n\nconst \nTemplateList\n \n\n\nList of templates to compare against the target\n\n\n\n\n\n\noutput\n\n\nOutput\n *\n\n\nOutput\n plugin to use to store the results of the comparisons\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nQList\nfloat\n compare(const \nTemplateList\n \ntarget, const \nTemplate\n \nquery)\n\n\nThis is a virtual function. Compare a query against a list of targets. Each comparison results in a floating point response which is the distance between the query and a specific target.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual QList\nfloat\n compare(const TemplateList \ntargets, const Template \nquery) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargets\n\n\nconst \nTemplateList\n \n\n\nList of templates to compare the query against\n\n\n\n\n\n\nquery\n\n\nconst \nTemplate\n \n\n\nQuery template to be compared\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQList\nfloat\n) Returns a list of the responses from each comparison between the query and a target.\n\n\n\n\nexample:\nTemplate t1(\"target_picture1.jpg\");\nTemplate t2(\"target_picture2.jpg\");\nTemplate t3(\"target_picture3.jpg\");\n\nTemplateList targets = TemplateList() \n t1 \n t2 \n t3;\n\nTemplate query(\"query_picture.jpg\");\n\nalgorithm = \"Enrollment:Distance\";\n\nTransform *transform = Transform::fromAlgorithm(algorithm);\nDistance *distance = Distance::fromAlgorithm(algorithm);\n\ntargets \n *transform;\nquery   \n *transform;\n\ndistance-\ncompare(targets, query); // returns [0.37, -0.56, 4.35] *Note results are made up!\n\n\n\n\n\n\n\nfloat compare(const \nTemplate\n \na, const \nTemplate\n \nb)\n\n\nThis is a virtual function. Compare two templates and get the difference between them.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual float compare(const Template \na, const Template \nb) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na\n\n\nconst \nTemplate\n \n\n\nFirst template to compare\n\n\n\n\n\n\nb\n\n\nconst \nTemplate\n \n\n\nSecond template to compare\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the calculated difference between the provided templates\n\n\n\n\nexample:\n\n\n\n\nTemplate a(\"picture_a.jpg\");\nTemplate b(\"picture_b.jpg\");\n\n\nalgorithm = \"Enrollment:Distance\";\n\n\nTransform \ntransform = Transform::fromAlgorithm(algorithm);\nDistance \ndistance = Distance::fromAlgorithm(algorithm);\n\n\na \n \ntransform;\nb \n \ntransform;\n\n\ndistance-\ncompare(a, b); // returns 16.43 *Note results are made up!\n\n\nfloat compare(const \nMat\n \na, const \nMat\n \nb)\n\n\nThis is a virtual function. Compare two \nMats\n and get the difference between them.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual float compare(const Mat \na, const Mat \nb) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na\n\n\nconst \nMat\n \n\n\nFirst matrix to compare\n\n\n\n\n\n\nb\n\n\nconst \nMat\n \n\n\nSecond matrix to compare\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the calculated difference between the provided \nMats\n\n\n\n\nexample:\nTemplate a(\"picture_a.jpg\");\nTemplate b(\"picture_b.jpg\");\n\nalgorithm = \"Enrollment:Distance\";\n\nTransform *transform = Transform::fromAlgorithm(algorithm);\nDistance *distance = Distance::fromAlgorithm(algorithm);\n\na \n *transform;\nb \n *transform;\n\ndistance-\ncompare(a.m(), b.m()); // returns 16.43 *Note results are made up!\n\n\n\n\n\n\n\nfloat compare(const uchar *a, const uchar *b, size_t size)\n\n\nThis is a virtual function. Compare two buffers and get the difference between them\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual float compare(const uchar *a, const uchar *b, size_t size) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\na\n\n\nconst uchar *\n\n\nFirst buffer to compare\n\n\n\n\n\n\nb\n\n\nconst uchar *\n\n\nSecond buffer to compare\n\n\n\n\n\n\nsize\n\n\nsize_t\n\n\nSize of buffers a and b (they must be the same size)\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the calculated difference between the provided buffers\n\n\n\n\nexample:\nTemplate a(\"picture_a.jpg\");\nTemplate b(\"picture_b.jpg\");\n\nalgorithm = \"Enrollment:Distance\";\n\nTransform *transform = Transform::fromAlgorithm(algorithm);\nDistance *distance = Distance::fromAlgorithm(algorithm);\n\na \n *transform;\nb \n *transform;\n\ndistance-\ncompare(a.m().ptr(), b.m().ptr()); // returns -4.32 *Note results are made up!\n\n\n\n\n\n\n\nDistance\n *make(const \nQString\n \ndescription)\n\n\nThis is a protected function. Makes a child distance from a provided description by calling \nmake\n with parent = \nthis\n.\n\n\n\n\n\n\nfunction definition:\n\n\ninline Distance *make(const QString \ndescription)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndescription\n\n\nconst \nQString\n \n\n\nDescription of the child distance\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nDistance\n *) Returns a pointer to the created child distance", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/#trainable", 
            "text": "This is a virtual function. Check if the distance is trainable. The default version returns true. Distances that are not trainable should derive from  UntrainableDistance  instead.    function defintion:  virtual bool trainable()    parameters:  NONE   output:  (bool) Returns true if the distance is trainable, false otherwise.", 
            "title": "bool trainable()"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/#train", 
            "text": "This is a pure virtual function. Train the distance on a provided  TemplateList  of data. The structure of the data is dependent on the distance to be trained. Distances that are not trainable should derive from  UntrainableDistance  so they do not have to overload this function.    function definition:  virtual void train(const TemplateList  src) = 0    parameters:     Parameter  Type  Description      src  const  TemplateList    Training data for the distance.       output:  (void)   example: // Create data for a 2-class classification problem\nTemplate t1(\"training_pic1.jpg\");\nt1.file.set(\"Label\", 0);\nTemplate t2(\"training_pic2.jpg\");\nt2.file.set(\"Label\", 0);\nTemplate t3(\"training_pic3.jpg\");\nt3.file.set(\"Label\", 1);\nTemplate t4(\"training_pic4.jpg\");\nt4.file.set(\"Label\", 1);\n\nTemplateList training_data(QList Template ()   t1   t2   t3   t4);\n\nTransform *distance = Distance::fromAlgorithm(\"Enrollment:Distance\");\ndistance- train(training_data); // Images are enrolled through Enrollment and the passed to Distance for training", 
            "title": "void train(const TemplateList src)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/#compare-1", 
            "text": "This is a virtual function. Compare two  TemplateLists  and store the results in a provided output.    function definition:  virtual void compare(const TemplateList  target, const TemplateList  query, Output *output) const    parameters:     Parameter  Type  Description      target  const  TemplateList    List of templates to compare the query against    query  const  TemplateList    List of templates to compare against the target    output  Output  *  Output  plugin to use to store the results of the comparisons       output:  (void)", 
            "title": "void compare(const TemplateList target, const [TemplateList] query, Output)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/#compare-2", 
            "text": "This is a virtual function. Compare a query against a list of targets. Each comparison results in a floating point response which is the distance between the query and a specific target.    function definition:  virtual QList float  compare(const TemplateList  targets, const Template  query) const    parameters:     Parameter  Type  Description      targets  const  TemplateList    List of templates to compare the query against    query  const  Template    Query template to be compared       output:  ( QList float ) Returns a list of the responses from each comparison between the query and a target.   example: Template t1(\"target_picture1.jpg\");\nTemplate t2(\"target_picture2.jpg\");\nTemplate t3(\"target_picture3.jpg\");\n\nTemplateList targets = TemplateList()   t1   t2   t3;\n\nTemplate query(\"query_picture.jpg\");\n\nalgorithm = \"Enrollment:Distance\";\n\nTransform *transform = Transform::fromAlgorithm(algorithm);\nDistance *distance = Distance::fromAlgorithm(algorithm);\n\ntargets   *transform;\nquery     *transform;\n\ndistance- compare(targets, query); // returns [0.37, -0.56, 4.35] *Note results are made up!", 
            "title": "QListfloat compare(const TemplateList target, const Template query)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/#compare-3", 
            "text": "This is a virtual function. Compare two templates and get the difference between them.    function definition:  virtual float compare(const Template  a, const Template  b) const    parameters:     Parameter  Type  Description      a  const  Template    First template to compare    b  const  Template    Second template to compare       output:  (float) Returns the calculated difference between the provided templates   example:   Template a(\"picture_a.jpg\");\nTemplate b(\"picture_b.jpg\");  algorithm = \"Enrollment:Distance\";  Transform  transform = Transform::fromAlgorithm(algorithm);\nDistance  distance = Distance::fromAlgorithm(algorithm);  a    transform;\nb    transform;  distance- compare(a, b); // returns 16.43 *Note results are made up!", 
            "title": "float compare(const Template a, const Template b)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/#compare-4", 
            "text": "This is a virtual function. Compare two  Mats  and get the difference between them.    function definition:  virtual float compare(const Mat  a, const Mat  b) const    parameters:     Parameter  Type  Description      a  const  Mat    First matrix to compare    b  const  Mat    Second matrix to compare       output:  (float) Returns the calculated difference between the provided  Mats   example: Template a(\"picture_a.jpg\");\nTemplate b(\"picture_b.jpg\");\n\nalgorithm = \"Enrollment:Distance\";\n\nTransform *transform = Transform::fromAlgorithm(algorithm);\nDistance *distance = Distance::fromAlgorithm(algorithm);\n\na   *transform;\nb   *transform;\n\ndistance- compare(a.m(), b.m()); // returns 16.43 *Note results are made up!", 
            "title": "float compare(const Mat a, const Mat b)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/#compare-5", 
            "text": "This is a virtual function. Compare two buffers and get the difference between them    function definition:  virtual float compare(const uchar *a, const uchar *b, size_t size) const    parameters:     Parameter  Type  Description      a  const uchar *  First buffer to compare    b  const uchar *  Second buffer to compare    size  size_t  Size of buffers a and b (they must be the same size)       output:  (float) Returns the calculated difference between the provided buffers   example: Template a(\"picture_a.jpg\");\nTemplate b(\"picture_b.jpg\");\n\nalgorithm = \"Enrollment:Distance\";\n\nTransform *transform = Transform::fromAlgorithm(algorithm);\nDistance *distance = Distance::fromAlgorithm(algorithm);\n\na   *transform;\nb   *transform;\n\ndistance- compare(a.m().ptr(), b.m().ptr()); // returns -4.32 *Note results are made up!", 
            "title": "float compare(const uchar *a, const uchar *b, size_t size)"
        }, 
        {
            "location": "/api_docs/cpp_api/distance/functions/#make", 
            "text": "This is a protected function. Makes a child distance from a provided description by calling  make  with parent =  this .    function definition:  inline Distance *make(const QString  description)    parameters:     Parameter  Type  Description      description  const  QString    Description of the child distance       output:  ( Distance  *) Returns a pointer to the created child distance", 
            "title": "Distance *make(const QString description)"
        }, 
        {
            "location": "/api_docs/cpp_api/untrainabledistance/untrainabledistance/", 
            "text": "Inherits \nDistance\n\n\nA \nDistance\n that does not require training.\n\n\nSee:\n\n\nThis is a base class for \nDistances\n that are not trainable. It overloads \ntrainable\n to return false and \ntrain\n so that it cannot be used in derived classes.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/output/output/", 
            "text": "Inherits from \nObject\n\n\nPlugin base class for storing template comparison results.\n\n\nSee:\n\n\n\n\nMembers\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nAn \nOutput\n is a \nFile\n representing the result comparing templates. \nFile\n::\nsuffix\n is used to determine which plugin should handle the output. The currently supported extensions are:\n\n\n\n\ntxt\n\n\ntail\n\n\nrr\n\n\nrank\n\n\nnull\n\n\nmtx\n\n\nmelt\n\n\nhist\n\n\nheat\n\n\neval\n\n\ncsv\n\n\nbest\n\n\n\n\nMany of these extensions are unique to OpenBR. Please look at the relevant \nOutput plugin\n for information on formatting and other concerns.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/output/properties/", 
            "text": "Property\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nblockRows\n\n\nint\n\n\nRow count for incremental writing block\n\n\n\n\n\n\nblockCols\n\n\nint\n\n\nColumn count for incremental writing block", 
            "title": "Properties"
        }, 
        {
            "location": "/api_docs/cpp_api/output/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetFiles\n\n\nFileList\n\n\nList of files representing the target templates\n\n\n\n\n\n\nqueryFiles\n\n\nFileList\n\n\nList of files representing the query templates\n\n\n\n\n\n\nselfSimilar\n\n\nbool\n\n\nTrue if targetFiles == queryFiles, false otherwise", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/output/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtual ~Output()\n\n\nDefault Destructor. Derived classes should overload this to handle serialization to disk.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/output/statics/", 
            "text": "Output *make(const \nFile\n \nfile, const \nFileList\n \ntargetFiles, const \nFileList\n \nqueryFiles)\n\n\nMake an \nOutput\n from a string and lists of target and query files. This function calls \ninitialize\n, which should be overloaded by derived classes to handle initialization. The provided file is first split using \nFile\n::\nsplit\n and each resulting file is turned into an \nOutput\n that is stored in a linked-list.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic Output *make(const File \nfile, const FileList \ntargetFiles, const FileList \nqueryFiles)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nconst \nFile\n \n\n\nFile describing the output or outputs to construct\n\n\n\n\n\n\ntargetFiles\n\n\nconst \nFileList\n \n\n\nList of files representing the target templates\n\n\n\n\n\n\nqueryFiles\n\n\nconst \nFileList\n \n\n\nList of files representing the query templates\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nOutput\n *) Returns a pointer to the first output in the linked list\n\n\n\n\nexample:\nTemplateList targets = TemplateList() \n Template(\"target1.jpg\") \n Template(\"target2.jpg\") \n Template(\"target3.jpg\");\nTemplateList queries = TemplateList() \n Template(\"query1.jpg\") \n Template(\"query2.jpg\");\n\nOutput *output1 = Output::make(\"output.mtx\", targets, queries); // returns a pointer to an Output at \"output.mtx\"\nOutput *output2 = Output::make(\"output1.mtx;output2.mtx\", targets, queries); // returns a pointer to the output created with \"output1.mtx\" with a pointer to the output created with \"output2.mtx\"", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/output/statics/#make", 
            "text": "Make an  Output  from a string and lists of target and query files. This function calls  initialize , which should be overloaded by derived classes to handle initialization. The provided file is first split using  File :: split  and each resulting file is turned into an  Output  that is stored in a linked-list.    function definition:  static Output *make(const File  file, const FileList  targetFiles, const FileList  queryFiles)    parameters:     Parameter  Type  Description      file  const  File    File describing the output or outputs to construct    targetFiles  const  FileList    List of files representing the target templates    queryFiles  const  FileList    List of files representing the query templates       output:  ( Output  *) Returns a pointer to the first output in the linked list   example: TemplateList targets = TemplateList()   Template(\"target1.jpg\")   Template(\"target2.jpg\")   Template(\"target3.jpg\");\nTemplateList queries = TemplateList()   Template(\"query1.jpg\")   Template(\"query2.jpg\");\n\nOutput *output1 = Output::make(\"output.mtx\", targets, queries); // returns a pointer to an Output at \"output.mtx\"\nOutput *output2 = Output::make(\"output1.mtx;output2.mtx\", targets, queries); // returns a pointer to the output created with \"output1.mtx\" with a pointer to the output created with \"output2.mtx\"", 
            "title": "Output *make(const File file, const FileList targetFiles, const FileList queryFiles)"
        }, 
        {
            "location": "/api_docs/cpp_api/output/functions/", 
            "text": "void initialize(const \nFileList\n \ntargetFiles, const \nFileList\n \nqueryFiles)\n\n\nThis is a virtual function. Initialize the output with provided target and query files.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void initialize(const [FileList](../filelist/filelist.md) \ntargetFiles, const [FileList](../filelist/filelist.md) \nqueryFiles)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetFiles\n\n\nconst \nFileList\n \n\n\nTarget files to initialize the Output with\n\n\n\n\n\n\nqueryFiles\n\n\nconst \nFileList\n \n\n\nQuery files to initialize the Output with\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplateList targets = TemplateList() \n Template(\"target1.jpg\") \n Template(\"target2.jpg\") \n Template(\"target3.jpg\");\nTemplateList queries = TemplateList() \n Template(\"query1.jpg\") \n Template(\"query2.jpg\");\n\nOutput *output = Factory::make\nOutput\n(\"output.mtx\");\noutput-\ninitialize(targets, queries); // This is the same as calling Output::make(\"output.mtx\", targets, queries)\n\n\n\n\n\n\n\nvoid setBlock(int rowBlock, int columnBlock)\n\n\nThis is a virtual function. Set the read offset of the Output.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void setBlock(int rowBlock, int columnBlock)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrowBlock\n\n\nint\n\n\nRow position of the offset\n\n\n\n\n\n\ncolumnBlock\n\n\nint\n\n\nColumn position of the offset\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid setRelative(float value, int i, int j)\n\n\nThis is a virtual function. Set a value in the Output. \ni\n and \nj\n are \nrelative\n to the current block.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void setRelative(float value, int i, int j)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nfloat\n\n\nValue to set in the output\n\n\n\n\n\n\ni\n\n\nint\n\n\nRow value relative to the current block\n\n\n\n\n\n\nj\n\n\nint\n\n\nColumn value relative to the current block\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid set(float value, int i, int j)\n\n\nThis is a pure virtual function. Set a value in the output.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void set(float value, int i, int j) = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nfloat\n\n\nValue to be inserted into the output\n\n\n\n\n\n\ni\n\n\nint\n\n\nRow index to insert at\n\n\n\n\n\n\nj\n\n\nint\n\n\nColumn index to insert at\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/output/functions/#initialize", 
            "text": "This is a virtual function. Initialize the output with provided target and query files.    function definition:  virtual void initialize(const [FileList](../filelist/filelist.md)  targetFiles, const [FileList](../filelist/filelist.md)  queryFiles)    parameters:     Parameter  Type  Description      targetFiles  const  FileList    Target files to initialize the Output with    queryFiles  const  FileList    Query files to initialize the Output with       output:  (void)   example: TemplateList targets = TemplateList()   Template(\"target1.jpg\")   Template(\"target2.jpg\")   Template(\"target3.jpg\");\nTemplateList queries = TemplateList()   Template(\"query1.jpg\")   Template(\"query2.jpg\");\n\nOutput *output = Factory::make Output (\"output.mtx\");\noutput- initialize(targets, queries); // This is the same as calling Output::make(\"output.mtx\", targets, queries)", 
            "title": "void initialize(const FileList targetFiles, const FileList queryFiles)"
        }, 
        {
            "location": "/api_docs/cpp_api/output/functions/#setblock", 
            "text": "This is a virtual function. Set the read offset of the Output.    function definition:  virtual void setBlock(int rowBlock, int columnBlock)    parameters:     Parameter  Type  Description      rowBlock  int  Row position of the offset    columnBlock  int  Column position of the offset       output:  (void)", 
            "title": "void setBlock(int rowBlock, int columnBlock)"
        }, 
        {
            "location": "/api_docs/cpp_api/output/functions/#setrelative", 
            "text": "This is a virtual function. Set a value in the Output.  i  and  j  are  relative  to the current block.    function definition:  virtual void setRelative(float value, int i, int j)    parameters:     Parameter  Type  Description      value  float  Value to set in the output    i  int  Row value relative to the current block    j  int  Column value relative to the current block       output:  (void)", 
            "title": "void setRelative(float value, int i, int j)"
        }, 
        {
            "location": "/api_docs/cpp_api/output/functions/#set", 
            "text": "This is a pure virtual function. Set a value in the output.    function definition:  virtual void set(float value, int i, int j) = 0    parameters:     Parameter  Type  Description      value  float  Value to be inserted into the output    i  int  Row index to insert at    j  int  Column index to insert at       output:  (void)", 
            "title": "void set(float value, int i, int j)"
        }, 
        {
            "location": "/api_docs/cpp_api/matrixoutput/matrixoutput/", 
            "text": "Inherits from \nOutput\n\n\nSee:\n\n\n\n\nMembers\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nA special case output specifically for matrix data.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/matrixoutput/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\nMat\n\n\nMatrix to store comparison data", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/matrixoutput/statics/", 
            "text": "static \nMatrixOutput\n *make(const \nFileList\n \ntargetFiles, const \nFileList\n \nqueryFiles)\n\n\nMake an \nMatrixOutput\n from lists of target and query files. This function calls \nOutput\n::\nmake\n using the string \"Matrix\". \nOutput\n::\nmake\n in turn calls \ninitialize\n. Initialize calls \ninitialize\n which should be overloaded by derived classes to handle initialization.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic MatrixOutput *make(const FileList \ntargetFiles, const FileList \nqueryFiles)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetFiles\n\n\nconst \nFileList\n \n\n\nList of files representing the target templates\n\n\n\n\n\n\nqueryFiles\n\n\nconst \nFileList\n \n\n\nList of files representing the query templates\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nMatrixOutput\n *) Returns a pointer to the first output in the linked list\n\n\n\n\nexample:\nTemplateList targets = TemplateList() \n Template(\"target1.jpg\") \n Template(\"target2.jpg\") \n Template(\"target3.jpg\");\nTemplateList queries = TemplateList() \n Template(\"query1.jpg\") \n Template(\"query2.jpg\");\n\nMatrixOutput *output = MatrixOutput::make(targets, queries); // returns a pointer to a MatrixOutput", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/matrixoutput/statics/#make", 
            "text": "Make an  MatrixOutput  from lists of target and query files. This function calls  Output :: make  using the string \"Matrix\".  Output :: make  in turn calls  initialize . Initialize calls  initialize  which should be overloaded by derived classes to handle initialization.    function definition:  static MatrixOutput *make(const FileList  targetFiles, const FileList  queryFiles)    parameters:     Parameter  Type  Description      targetFiles  const  FileList    List of files representing the target templates    queryFiles  const  FileList    List of files representing the query templates       output:  ( MatrixOutput  *) Returns a pointer to the first output in the linked list   example: TemplateList targets = TemplateList()   Template(\"target1.jpg\")   Template(\"target2.jpg\")   Template(\"target3.jpg\");\nTemplateList queries = TemplateList()   Template(\"query1.jpg\")   Template(\"query2.jpg\");\n\nMatrixOutput *output = MatrixOutput::make(targets, queries); // returns a pointer to a MatrixOutput", 
            "title": "static MatrixOutput *make(const FileList targetFiles, const FileList queryFiles)"
        }, 
        {
            "location": "/api_docs/cpp_api/matrixoutput/functions/", 
            "text": "QString\n toString(int row, int column)\n\n\nGet a value in \ndata\n as a string using a provided row and column index.\n\n\n\n\n\n\nfunction definition:\n\n\nQString toString(int row, int column) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrow\n\n\nint\n\n\nRow index of value\n\n\n\n\n\n\ncolumn\n\n\nint\n\n\nColumn index of value\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nQString\n) Returns the value stored at (row, column) as a string\n\n\n\n\nexample:\nTemplateList targets = TemplateList() \n Template(\"target1.jpg\") \n Template(\"target2.jpg\") \n Template(\"target3.jpg\");\nTemplateList queries = TemplateList() \n Template(\"query1.jpg\") \n Template(\"query2.jpg\");\n\nMatrixOutput *output = MatrixOutput::make(targets, queries);\noutput-\nset(10.0, 1, 2);\noutput-\ntoString(1, 2); // Returns \"10\"\noutput-\ntoString(2, 2); // ERROR: row index is out of range\n\n\n\n\n\n\n\nvoid initialize(const \nFileList\n \ntargetFiles, const \nFileList\n \nqueryFiles)\n\n\nInitialize the output. This function calls \ninitialize\n which should be overloaded by derived classes that need to be initialized. After calling \ninitialize\n, \ndata\n is initialized to be of size queryFiles.size() x targetFiles.size().\n\n\n\n\n\n\nfunction definition:\n\n\nvoid initialize(const FileList \ntargetFiles, const FileList \nqueryFiles)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetFiles\n\n\nconst \nFileList\n \n\n\nList of target files for initialization\n\n\n\n\n\n\nqueryFiles\n\n\nconst \nFileList\n \n\n\nList of query files for initialization\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\n\n\nvoid set(float value, int i, int j)\n\n\nSet a value in \ndata\n at the provided row and column indices.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid set(float value, int i, int j)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nfloat\n\n\nValue to be set\n\n\n\n\n\n\ni\n\n\nint\n\n\nRow index into \ndata\n\n\n\n\n\n\nj\n\n\nint\n\n\nColumn index into \ndata\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplateList targets = TemplateList() \n Template(\"target1.jpg\") \n Template(\"target2.jpg\") \n Template(\"target3.jpg\");\nTemplateList queries = TemplateList() \n Template(\"query1.jpg\") \n Template(\"query2.jpg\");\n\nMatrixOutput *output = MatrixOutput::make(targets, queries);\noutput-\nset(6.0, 0, 1);\noutput-\ntoString(0, 1); // Returns \"6.0\"\n\noutput-\nset(10.0, 1, 2);\noutput-\ntoString(1, 2); // Returns \"10.0\"", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/matrixoutput/functions/#tostring", 
            "text": "Get a value in  data  as a string using a provided row and column index.    function definition:  QString toString(int row, int column) const    parameters:     Parameter  Type  Description      row  int  Row index of value    column  int  Column index of value       output:  ( QString ) Returns the value stored at (row, column) as a string   example: TemplateList targets = TemplateList()   Template(\"target1.jpg\")   Template(\"target2.jpg\")   Template(\"target3.jpg\");\nTemplateList queries = TemplateList()   Template(\"query1.jpg\")   Template(\"query2.jpg\");\n\nMatrixOutput *output = MatrixOutput::make(targets, queries);\noutput- set(10.0, 1, 2);\noutput- toString(1, 2); // Returns \"10\"\noutput- toString(2, 2); // ERROR: row index is out of range", 
            "title": "QString toString(int row, int column)"
        }, 
        {
            "location": "/api_docs/cpp_api/matrixoutput/functions/#initialize", 
            "text": "Initialize the output. This function calls  initialize  which should be overloaded by derived classes that need to be initialized. After calling  initialize ,  data  is initialized to be of size queryFiles.size() x targetFiles.size().    function definition:  void initialize(const FileList  targetFiles, const FileList  queryFiles)    parameters:     Parameter  Type  Description      targetFiles  const  FileList    List of target files for initialization    queryFiles  const  FileList    List of query files for initialization       output:  (void)", 
            "title": "void initialize(const FileList targetFiles, const FileList queryFiles)"
        }, 
        {
            "location": "/api_docs/cpp_api/matrixoutput/functions/#set", 
            "text": "Set a value in  data  at the provided row and column indices.    function definition:  void set(float value, int i, int j)    parameters:     Parameter  Type  Description      value  float  Value to be set    i  int  Row index into  data    j  int  Column index into  data       output:  (void)   example: TemplateList targets = TemplateList()   Template(\"target1.jpg\")   Template(\"target2.jpg\")   Template(\"target3.jpg\");\nTemplateList queries = TemplateList()   Template(\"query1.jpg\")   Template(\"query2.jpg\");\n\nMatrixOutput *output = MatrixOutput::make(targets, queries);\noutput- set(6.0, 0, 1);\noutput- toString(0, 1); // Returns \"6.0\"\n\noutput- set(10.0, 1, 2);\noutput- toString(1, 2); // Returns \"10.0\"", 
            "title": "void set(float value, int i, int j)"
        }, 
        {
            "location": "/api_docs/cpp_api/format/format/", 
            "text": "Inherits \nObject\n\n\nPlugin base class for reading a template from disk.\n\n\nSee:\n\n\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nA \nformat\n is a \nFile\n representing a \nTemplate\n on disk. \nFile\n::\nsuffix\n is used to determine which derived format plugin should handle a file. Currently supported extensions are:\n\n\n\n\nOpenCV image formats\n\n\nxml\n\n\nscores\n\n\nurl\n\n\nraw\n\n\npost\n\n\nnull\n\n\nmtx\n\n\nmask\n\n\nmat\n\n\nlffs\n\n\nebts\n\n\ncsv\n\n\nbinary\n\n\n\n\nMany of these extensions are unique to OpenBR. Please look at the relevant \nFormat plugin\n for information on formatting and other concerns.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/format/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtual ~Format()\n\n\nDefault destructor. It doesn't do anything", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/format/statics/", 
            "text": "Template\n read(const \nQString\n \nfile)\n\n\nRead a \nTemplate\n from disk at the provide file location. A derived class format is chosen based on the suffix of the provided file.\n\n\n\n\nfunction definition:\n\n\n\n\nstatic Template read(const QString \nfile)\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nconst \nQString\n \n\n\nFile to load a \nTemplate\n from.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTemplate\n) Returns a \nTemplate\n loaded from disk.\n\n\n\n\nexample:\nFormat::read(\"picture.jpg\"); // returns a template loaded from \"picture.jpg\". The proper Format to load jpg images is selected automatically\n\n\n\n\n\n\n\nvoid write(const \nQString\n \nfile, const \nTemplate\n \nt)\n\n\nWrite a template to disk at the provided file location.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic void write(const QString \nfile, const Template \nt)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nconst \nQString\n \n\n\nFile to write a \nTemplate\n to\n\n\n\n\n\n\nt\n\n\nconst \nTemplate\n \n\n\nTemplate\n to write to disk\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplate t(\"picture.jpg\");\n\nFormat::write(\"new_pic_location.jpg\", t); // Write t to \"new_pic_location.jpg\"", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/format/statics/#read", 
            "text": "Read a  Template  from disk at the provide file location. A derived class format is chosen based on the suffix of the provided file.   function definition:   static Template read(const QString  file)    parameters:     Parameter  Type  Description      file  const  QString    File to load a  Template  from.       output:  ( Template ) Returns a  Template  loaded from disk.   example: Format::read(\"picture.jpg\"); // returns a template loaded from \"picture.jpg\". The proper Format to load jpg images is selected automatically", 
            "title": "Template read(const QString file)"
        }, 
        {
            "location": "/api_docs/cpp_api/format/statics/#write", 
            "text": "Write a template to disk at the provided file location.    function definition:  static void write(const QString  file, const Template  t)    parameters:     Parameter  Type  Description      file  const  QString    File to write a  Template  to    t  const  Template    Template  to write to disk       output:  (void)   example: Template t(\"picture.jpg\");\n\nFormat::write(\"new_pic_location.jpg\", t); // Write t to \"new_pic_location.jpg\"", 
            "title": "void write(const QString file, const Template t)"
        }, 
        {
            "location": "/api_docs/cpp_api/format/functions/", 
            "text": "Template\n read()\n\n\nThis is a pure virtual function. Read a template from disk at \nfile\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Template read() const = 0\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nTemplate\n) Returns a template loaded from disk\n\n\nexample:\nFormat *format = Factory::make\nFormat\n(\"picture.jpg\")\nformat-\nread(); // returns a template loaded from \"picture.jpg\"\n\n\n\n\n\n\n\nvoid write(const \nTemplate\n \nt)\n\n\nThis is a pure virtual function. Write a provide template to disk at \nfile\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void write(const Template \nt) const = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nconst \nTemplate\n \n\n\nTemplate\n to write to disk\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nFormat *format = Factory::make\nFormat\n(\"new_pic_location.jpg\");\n\nTemplate t(\"picture.jpg\");\nformat-\nwrite(t); // write t to \"new_pic_location\"", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/format/functions/#read", 
            "text": "This is a pure virtual function. Read a template from disk at  file .    function definition:  virtual Template read() const = 0    parameters:  NONE   output:  ( Template ) Returns a template loaded from disk  example: Format *format = Factory::make Format (\"picture.jpg\")\nformat- read(); // returns a template loaded from \"picture.jpg\"", 
            "title": "Template read()"
        }, 
        {
            "location": "/api_docs/cpp_api/format/functions/#write", 
            "text": "This is a pure virtual function. Write a provide template to disk at  file    function definition:  virtual void write(const Template  t) const = 0    parameters:     Parameter  Type  Description      t  const  Template    Template  to write to disk       output:  (void)   example: Format *format = Factory::make Format (\"new_pic_location.jpg\");\n\nTemplate t(\"picture.jpg\");\nformat- write(t); // write t to \"new_pic_location\"", 
            "title": "void write(const Template t)"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/gallery/", 
            "text": "Inherits \nObject\n\n\nPlugin base class for storing a list of enrolled templates.\n\n\nSee:\n\n\n\n\nProperties\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nA \ngallery\n is a file representing a \nTemplateList\n serialized to disk. \nFile\n::\nsuffix\n is used to determine which plugin should handle the gallery. The currently supported extensions are\n\n\n\n\nxml\n\n\navi\n\n\nwmv\n\n\nmp4\n\n\nwebcam\n\n\nvbb (OpenCV format)\n\n\ntxt\n\n\nturk\n\n\ntemplate\n\n\nstat\n\n\nseq\n\n\npost\n\n\nmem (\nNOTE:\n Mem galleries live only in RAM; they should be used for caching and not for normal I/O)\n\n\nmatrix\n\n\nlandmarks\n\n\ngoogle\n\n\nflat\n\n\nFDDB\n\n\ndb\n\n\ncsv\n\n\ncrawl\n\n\ngal\n\n\nut\n\n\nurl\n\n\njson\n\n\narff\n\n\n\n\nMany of these extensions are unique to OpenBR. Please look at the relevant \nGallery plugin\n for information on formatting and other concerns.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/properties/", 
            "text": "Property\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nreadBlockSize\n\n\nint\n\n\nSize in bytes of each block to be read", 
            "title": "Properties"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtual ~Gallery()\n\n\nDefault Destructor. Derived classes should overload this to handle serialization to disk.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/statics/", 
            "text": "Gallery\n *make(const \nFile\n \nfile)\n\n\nMake a \nGallery\n from a string. The provided file is first split using \nFile\n::\nsplit\n and each resulting file is turned into a \nGallery\n that is stored in a linked-list.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic Gallery *make(const File \nfile)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nconst \nFile\n \n\n\nFile describing the gallery or galleries to construct\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nGallery\n *) Returns a pointer to the first gallery in the linked list\n\n\n\n\nexample:\nGallery *gallery1 = Gallery::make(\"gallery_file.xml\"); // returns a pointer to the gallery\nGallery *gallery2 = Gallery::make(\"gallery_file1.xml;gallery_file2.xml\"); // returns a pointer to the gallery created with \"gallery_file1.xml\" with a pointer to the gallery created with \"gallery_file2.xml\"", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/statics/#make", 
            "text": "Make a  Gallery  from a string. The provided file is first split using  File :: split  and each resulting file is turned into a  Gallery  that is stored in a linked-list.    function definition:  static Gallery *make(const File  file)    parameters:     Parameter  Type  Description      file  const  File    File describing the gallery or galleries to construct       output:  ( Gallery  *) Returns a pointer to the first gallery in the linked list   example: Gallery *gallery1 = Gallery::make(\"gallery_file.xml\"); // returns a pointer to the gallery\nGallery *gallery2 = Gallery::make(\"gallery_file1.xml;gallery_file2.xml\"); // returns a pointer to the gallery created with \"gallery_file1.xml\" with a pointer to the gallery created with \"gallery_file2.xml\"", 
            "title": "Gallery *make(const File file)"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/functions/", 
            "text": "TemplateList\n read()\n\n\nRead all of them templates stored in the \nGallery\n from disk into memory. For incremental reads see \nreadBlock\n\n\n\n\n\n\nfunction definition:\n\n\nTemplateList read()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nTemplateList\n) Returns a list of all of the templates read from disk\n\n\nexample:\nGallery *gallery = Gallery::make(\"gallery_file.xml\");\ngallery-\nread(); // returns a TemplateList of every template stored in the gallery\n\n\n\n\n\n\n\n\n\n\nFileList\n files()\n\n\nRead all of the filese stored in the \nGallery\n from disk into memory.\n\n\n\n\n\n\nfunction definition:\n\n\nFileList files()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (\nFileList\n) Returns a list of all of the files read from disk\n\n\nexample:\nGallery *gallery = Gallery::make(\"gallery_file.xml\");\ngallery-\nfiles(); // returns a FileList of every file stored in the gallery\n\n\n\n\n\n\n\n\n\n\nTemplateList\n readBlock(bool *done)\n\n\nThis is a pure virtual function. Incrementally read a block of templates from disk into memory. The size of the block is set by \nreadBlockSize\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual TemplateList readBlock(bool *done) = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndone\n\n\nbool *\n\n\nSet to true by the function if the last block has been read, false otherwise\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nTemplateList\n) Returns a block of templates loaded from disk\n\n\n\n\nexample:\nGallery *gallery = Gallery::make(\"gallery_file.xml\");\n\nbool done = false\nwhile(!done)\n    gallery-\nreadBlock(\ndone); // Each iteration of the loop reads a new block until the end of the gallery is reached\n\n\n\n\n\n\n\n\n\n\nvoid writeBlock(const \nTemplateList\n \ntemplates)\n\n\nWrite the provided templates to disk. This function calls \nwrite\n which should be overloaded by all derived classes. If the gallery is a linked list (see \nmake\n) each gallery writes the provided templates sequentially.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid writeBlock(const TemplateList \ntemplates)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntemplates\n\n\nconst \nTemplateList\n \n\n\nList of templates to write to disk\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplate t1(\"picture1.jpg\");\nt1.file.set(\"property\", 1);\nTemplate t2(\"picture2.jpg\");\nt2.file.set(\"property\", 2)\n\nTemplateList tList = TemplateList() \n t1 \n t2;\n\nGallery *gallery = Gallery::make(\"gallery_file.xml\");\ngallery-\nwriteBlock(tList); // write the templatelist to disk\n\n\n\n\n\n\n\n\n\n\nvoid write(const \nTemplate\n \nt)\n\n\nThis is a pure virtual function. Write a single template to disk.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void write(const Template \nt) = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nt\n\n\nconst \nTemplate\n \n\n\nTemplate to write to disk\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\nTemplate t1(\"picture1.jpg\");\nt1.file.set(\"property\", 1);\nTemplate t2(\"picture2.jpg\");\nt2.file.set(\"property\", 2)\n\nGallery *gallery = Gallery::make(\"gallery_file.xml\");\ngallery-\nwrite(t1); // write template1 to disk\ngallery-\nwrite(t2); // write template2 to disk\n\n\n\n\n\n\n\nqint64 totalSize()\n\n\nThis is a virtual function. Get the total size of the gallery. Default implementation returns \nINT_MAX\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual qint64 totalSize()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (qint64) Returns the total size of the gallery in bytes\n\n\n\n\nqint64 position()\n\n\nThis is a virtual function. Get the current position of the read index in the gallery. The next call to \nreadBlock\n will read starting at the reported position.\n\n\n\n\n\n\nfunction output:\n\n\nvirtual qint64 position()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (qint64) Returns the current read position in the gallery\n\n\nexample:\nGallery *gallery = Gallery::make(\"gallery_file.xml\");\n\ngallery-\nposition(); // returns 0\nbool done; gallery-\nreadBlock(\ndone);\ngallery-\nposition(); // returns readBlockSize", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/functions/#read", 
            "text": "Read all of them templates stored in the  Gallery  from disk into memory. For incremental reads see  readBlock    function definition:  TemplateList read()    parameters:  NONE   output:  ( TemplateList ) Returns a list of all of the templates read from disk  example: Gallery *gallery = Gallery::make(\"gallery_file.xml\");\ngallery- read(); // returns a TemplateList of every template stored in the gallery", 
            "title": "TemplateList read()"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/functions/#files", 
            "text": "Read all of the filese stored in the  Gallery  from disk into memory.    function definition:  FileList files()    parameters:  NONE   output:  ( FileList ) Returns a list of all of the files read from disk  example: Gallery *gallery = Gallery::make(\"gallery_file.xml\");\ngallery- files(); // returns a FileList of every file stored in the gallery", 
            "title": "FileList files()"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/functions/#readblock", 
            "text": "This is a pure virtual function. Incrementally read a block of templates from disk into memory. The size of the block is set by  readBlockSize .    function definition:  virtual TemplateList readBlock(bool *done) = 0    parameters:     Parameter  Type  Description      done  bool *  Set to true by the function if the last block has been read, false otherwise       output:  ( TemplateList ) Returns a block of templates loaded from disk   example: Gallery *gallery = Gallery::make(\"gallery_file.xml\");\n\nbool done = false\nwhile(!done)\n    gallery- readBlock( done); // Each iteration of the loop reads a new block until the end of the gallery is reached", 
            "title": "TemplateList readBlock(bool *done)"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/functions/#writeblock", 
            "text": "Write the provided templates to disk. This function calls  write  which should be overloaded by all derived classes. If the gallery is a linked list (see  make ) each gallery writes the provided templates sequentially.    function definition:  void writeBlock(const TemplateList  templates)    parameters:     Parameter  Type  Description      templates  const  TemplateList    List of templates to write to disk       output:  (void)   example: Template t1(\"picture1.jpg\");\nt1.file.set(\"property\", 1);\nTemplate t2(\"picture2.jpg\");\nt2.file.set(\"property\", 2)\n\nTemplateList tList = TemplateList()   t1   t2;\n\nGallery *gallery = Gallery::make(\"gallery_file.xml\");\ngallery- writeBlock(tList); // write the templatelist to disk", 
            "title": "void writeBlock(const TemplateList templates)"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/functions/#write", 
            "text": "This is a pure virtual function. Write a single template to disk.    function definition:  virtual void write(const Template  t) = 0    parameters:     Parameter  Type  Description      t  const  Template    Template to write to disk       output:  (void)   example: Template t1(\"picture1.jpg\");\nt1.file.set(\"property\", 1);\nTemplate t2(\"picture2.jpg\");\nt2.file.set(\"property\", 2)\n\nGallery *gallery = Gallery::make(\"gallery_file.xml\");\ngallery- write(t1); // write template1 to disk\ngallery- write(t2); // write template2 to disk", 
            "title": "void write(const Template t)"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/functions/#totalsize", 
            "text": "This is a virtual function. Get the total size of the gallery. Default implementation returns  INT_MAX .    function definition:  virtual qint64 totalSize()    parameters:  NONE   output:  (qint64) Returns the total size of the gallery in bytes", 
            "title": "qint64 totalSize()"
        }, 
        {
            "location": "/api_docs/cpp_api/gallery/functions/#position", 
            "text": "This is a virtual function. Get the current position of the read index in the gallery. The next call to  readBlock  will read starting at the reported position.    function output:  virtual qint64 position()    parameters:  NONE   output:  (qint64) Returns the current read position in the gallery  example: Gallery *gallery = Gallery::make(\"gallery_file.xml\");\n\ngallery- position(); // returns 0\nbool done; gallery- readBlock( done);\ngallery- position(); // returns readBlockSize", 
            "title": "qint64 position()"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/filegallery/", 
            "text": "Inherits \nGallery\n\n\nA \nGallery\n that handles data stored on disk (as opposed to data already in memory).\n\n\nSee:\n\n\n\n\nMembers\n\n\nConstructors\n\n\nFunctions\n\n\n\n\nFileGalleries\n are the base abstraction for all \nGalleries\n that handle I/O with the hard drive. They automatically track the size and current position of a file and also provide convienience opererators for opening them for reading and writing.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/members/", 
            "text": "Member\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nf\n\n\nQFile\n\n\nThe file on disk. It has the same name as \nfile", 
            "title": "Members"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtual ~FileGallery()\n\n\nDefault destructor. Closes \nf", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/functions/", 
            "text": "void init()\n\n\nInitialize the \nFileGallery\n. This sets \nf\n using the file name from \nfile\n. It also calls \nGallery\n::\ninit\n.\n\n\n\n\n\n\nfunction definition:\n\n\nvoid init()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)\n\n\n\n\nqint64 totalSize()\n\n\nGet the total size of the file. This is useful for estimating progress.\n\n\n\n\n\n\nfunction definition:\n\n\nqint64 totalSize()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (qint64) Returns the total size of the file in bytes\n\n\n\n\nqint64 position()\n\n\nGet the current index in the file. This is useful for reading and writing blocks of data\n\n\n\n\n\n\nfunction definition:\n\n\nqint64 position()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (qint64) Returns the current position in the file\n\n\n\n\nbool readOpen()\n\n\nOpen \nf\n in read-only mode\n\n\n\n\n\n\nfunction definition:\n\n\nbool readOpen()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (bool) Returns true if the file was opened successfully, false otherwise\n\n\n\n\nvoid writeOnly()\n\n\nOpen \nf\n in write-only mode\n\n\n\n\n\n\nfunction definition:\n\n\nvoid writeOpen()\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (void)", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/functions/#init", 
            "text": "Initialize the  FileGallery . This sets  f  using the file name from  file . It also calls  Gallery :: init .    function definition:  void init()    parameters:  NONE   output:  (void)", 
            "title": "void init()"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/functions/#totalsize", 
            "text": "Get the total size of the file. This is useful for estimating progress.    function definition:  qint64 totalSize()    parameters:  NONE   output:  (qint64) Returns the total size of the file in bytes", 
            "title": "qint64 totalSize()"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/functions/#pos", 
            "text": "Get the current index in the file. This is useful for reading and writing blocks of data    function definition:  qint64 position()    parameters:  NONE   output:  (qint64) Returns the current position in the file", 
            "title": "qint64 position()"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/functions/#readopen", 
            "text": "Open  f  in read-only mode    function definition:  bool readOpen()    parameters:  NONE   output:  (bool) Returns true if the file was opened successfully, false otherwise", 
            "title": "bool readOpen()"
        }, 
        {
            "location": "/api_docs/cpp_api/filegallery/functions/#writeonly", 
            "text": "Open  f  in write-only mode    function definition:  void writeOpen()    parameters:  NONE   output:  (void)", 
            "title": "void writeOnly()"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/representation/", 
            "text": "Inherits \nObject\n.\n\n\nPlugin base class for converting images into feature vectors\n\n\nSee:\n\n\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nRepresentations\n are used to convert images to feature vectors lazily (only when necessary). They are similar to \nTransforms\n in many respects but differ in a few key areas. \nTransforms\n should be used to construct feature vectors if it is desirable to construct a vector before evaluation that encompasses the entire feature space (or a smaller subset learned during training). \nRepresentations\n should be used if their is a large \npossible\n feature space but a few select features are necessary for a particular computation. This is often the case in tree architectures, where each node has an associated feature. The \npossible\n feature space is all of the features associated with all of the nodes, but the \nrequired\n features are only the features associated with nodes that are actually visited. The purpose of \nRepresentations\n is to allow these features to be calculated as needed instead of calculating all of the features before hand, which is less efficient.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtual ~Representation()\n\n\nDefault destructor. It doesn' do anything.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/statics/", 
            "text": "Representation\n *make(\nQString\n str, \nQObject\n *parent)\n\n\nMake a \nRepresentation\n from a string. The string is passed to \nFactory\n::\nmake\n to be turned into a representation.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic Representation *make(QString str, QObject *parent)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstr\n\n\nQString\n\n\nString describing the representation\n\n\n\n\n\n\nparent\n\n\nQObject\n *\n\n\nParent of the object to be created\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nRepresentation\n *) Returns a pointer to the \nRepresentation\n described by the string\n\n\n\n\nsee:\n \nFactory::make\n\n\nexample:\nRepresentation *rep = Representation::make(\"Representation(property1=value1)\");\nrep-\ndescription(); // Returns \"Representation(property1=value1)\"", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/statics/#make", 
            "text": "Make a  Representation  from a string. The string is passed to  Factory :: make  to be turned into a representation.    function definition:  static Representation *make(QString str, QObject *parent)    parameters:     Parameter  Type  Description      str  QString  String describing the representation    parent  QObject  *  Parent of the object to be created       output:  ( Representation  *) Returns a pointer to the  Representation  described by the string   see:   Factory::make  example: Representation *rep = Representation::make(\"Representation(property1=value1)\");\nrep- description(); // Returns \"Representation(property1=value1)\"", 
            "title": "Representation *make(QString str, QObject *parent)"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/functions/", 
            "text": "Mat\n preprocess(const \nMat\n \nimage)\n\n\nThis is a virtual function. Preprocess an image into the desired format for the representation. Default implementation returns the image unmodified.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual Mat preprocess(const Mat \nimage) const\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nimage\n\n\nconst \nMat\n \n\n\nImage to be preprocessed\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nMat\n) Returns the preprocessed image\n\n\n\n\nexample:\nTemplate in(\"picture.jpg\");\n\nRepresentation *rep = Representation::make(\"RepresentationThatRequiresGrayscale\");\nrep-\npreprocess(in); // returns the original image converted to grayscale\n\n\n\n\n\n\n\nvoid train(const \nQList\nMat\n \nimages, const \nQList\nfloat\n \nlabels)\n\n\nThis is a virtual function. Train the representation using the provided images and associated labels. Default implementation does no training.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void train(const QList\nMat\n \nimages, const QList\nfloat\n \nlabels)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nimages\n\n\nconst \nQList\nMat\n \n\n\nTraining images\n\n\n\n\n\n\nlabels\n\n\nconst \nQList\nfloat\n \n\n\nTraining labels\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\n// Create data for a 2-class classification problem\nQList\nMat\n images = QList\nMat\n() \n Template(\"training_pic1.jpg\").m()\n                                 \n Template(\"training_pic2.jpg\").m()\n                                 \n Template(\"training_pic3.jpg\").m()\n                                 \n Template(\"training_pic4.jpg\").m();\n\nQList\nfloat\n labels = QList\nfloat\n() \n 0 \n 0 \n 1 \n 1;\n\nRepresentation *rep = Representation::make(\"Representation\");\nrep-\ntrain(images, labels);\n\n\n\n\n\n\n\nMat\n evaluate(const \nMat\n \nimage, const \nQList\nint\n \nindices = \nQList\nint\n())\n\n\nThis is a pure virtual function. For a provided input image calculate only the feature responses associated with the provided indices. The indices are expected relative to the entire feature space. If the indices list is empty the response of the entire feature space is calculated.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual cv::Mat evaluate(const Mat \nimage, const QList\nint\n \nindices = QList\nint\n()) const = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nimage\n\n\nconst \nMat\n \n\n\nThe image to be converted\n\n\n\n\n\n\nindices\n\n\nconst \nQList\nint\n \n\n\n(Optional) A list of indices corresponding to the desired features to calculate. If the list is empty all features are calculated.\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nMat\n) Returns a 1xN feature vector where N is the number of indices provided. If no indices are provided N equals the size of the feature space.\n\n\n\n\nexample:\nTemplate image(\"picture.jpg\");\n\nRepresentation *rep = Representation::make(\"Representation\");\nrep-\nevaluate(image, QList\nint\n() \n 7 \n 10 \n 72 ); // returns a 1x3 Mat feature vector\n\n\n\n\n\n\n\nint numFeatures()\n\n\nThis is a pure virtual function. Get the size of the feature space.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual int numFeatures() const = 0\n\n\n\n\n\n\n\nparameters:\n NONE\n\n\n\n\noutput:\n (int) Returns the size of the feature space\n\n\nexample:\nRepresentation *rep1 = Representation::make(\"RepresentationWith1000features\");\nRepresentation *rep2 = Representation::make(\"RepresentationWith25643features\");\n\nrep1-\nnumFeatures(); // returns 1000\nrep2-\nnumFeatures(); // returns 25643", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/functions/#preprocess", 
            "text": "This is a virtual function. Preprocess an image into the desired format for the representation. Default implementation returns the image unmodified.    function definition:  virtual Mat preprocess(const Mat  image) const    parameters:     Parameter  Type  Description      image  const  Mat    Image to be preprocessed       output:  ( Mat ) Returns the preprocessed image   example: Template in(\"picture.jpg\");\n\nRepresentation *rep = Representation::make(\"RepresentationThatRequiresGrayscale\");\nrep- preprocess(in); // returns the original image converted to grayscale", 
            "title": "Mat preprocess(const Mat image)"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/functions/#train", 
            "text": "This is a virtual function. Train the representation using the provided images and associated labels. Default implementation does no training.    function definition:  virtual void train(const QList Mat   images, const QList float   labels)    parameters:     Parameter  Type  Description      images  const  QList Mat    Training images    labels  const  QList float    Training labels       output:  (void)   example: // Create data for a 2-class classification problem\nQList Mat  images = QList Mat ()   Template(\"training_pic1.jpg\").m()\n                                   Template(\"training_pic2.jpg\").m()\n                                   Template(\"training_pic3.jpg\").m()\n                                   Template(\"training_pic4.jpg\").m();\n\nQList float  labels = QList float ()   0   0   1   1;\n\nRepresentation *rep = Representation::make(\"Representation\");\nrep- train(images, labels);", 
            "title": "void train(const QListMat images, const QListfloat labels)"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/functions/#evaluate", 
            "text": "This is a pure virtual function. For a provided input image calculate only the feature responses associated with the provided indices. The indices are expected relative to the entire feature space. If the indices list is empty the response of the entire feature space is calculated.    function definition:  virtual cv::Mat evaluate(const Mat  image, const QList int   indices = QList int ()) const = 0    parameters:     Parameter  Type  Description      image  const  Mat    The image to be converted    indices  const  QList int    (Optional) A list of indices corresponding to the desired features to calculate. If the list is empty all features are calculated.       output:  ( Mat ) Returns a 1xN feature vector where N is the number of indices provided. If no indices are provided N equals the size of the feature space.   example: Template image(\"picture.jpg\");\n\nRepresentation *rep = Representation::make(\"Representation\");\nrep- evaluate(image, QList int ()   7   10   72 ); // returns a 1x3 Mat feature vector", 
            "title": "Mat evaluate(const Mat image, const QListint indices = QListint())"
        }, 
        {
            "location": "/api_docs/cpp_api/representation/functions/#numfeatures", 
            "text": "This is a pure virtual function. Get the size of the feature space.    function definition:  virtual int numFeatures() const = 0    parameters:  NONE   output:  (int) Returns the size of the feature space  example: Representation *rep1 = Representation::make(\"RepresentationWith1000features\");\nRepresentation *rep2 = Representation::make(\"RepresentationWith25643features\");\n\nrep1- numFeatures(); // returns 1000\nrep2- numFeatures(); // returns 25643", 
            "title": "int numFeatures()"
        }, 
        {
            "location": "/api_docs/cpp_api/classifier/classifier/", 
            "text": "Inherits \nObject\n\n\nSee:\n\n\n\n\nConstructors\n\n\nStatic Functions\n\n\nFunctions\n\n\n\n\nClassifiers are used to assign images to a specific class, or to a particular value along a regression line.  Although \nTransforms\n can also be used for this purpose, \nClassifiers\n provide a simpler and more consistent API.", 
            "title": "Overview"
        }, 
        {
            "location": "/api_docs/cpp_api/classifier/constructors/", 
            "text": "Constructor / Destructor\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvirtual ~Classifier()\n\n\nDefault destructor. It doesn' do anything.", 
            "title": "Constructors"
        }, 
        {
            "location": "/api_docs/cpp_api/classifier/statics/", 
            "text": "Classifier\n *make(\nQString\n str, \nQObject\n *parent)\n\n\nMake a \nClassifier\n from a string. The string is passed to \nFactory\n::\nmake\n to be turned into a classifier.\n\n\n\n\n\n\nfunction definition:\n\n\nstatic Classifier *make(QString str, QObject *parent)\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstr\n\n\nQString\n\n\nString describing the classifier\n\n\n\n\n\n\nparent\n\n\nQObject\n *\n\n\nParent of the object to be created\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (\nClassifier\n *) Returns a pointer to the \nClassifier\n described by the string\n\n\n\n\nsee:\n \nFactory::make\n\n\nexample:\nClassifier *classifier = Classifier::make(\"Classifier(representation=Representation(property1=value1)\");\nclassifier-\ndescription(); // Returns \"Classifier(representation=Representation(property1=value1))\"", 
            "title": "Static Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/classifier/statics/#make", 
            "text": "Make a  Classifier  from a string. The string is passed to  Factory :: make  to be turned into a classifier.    function definition:  static Classifier *make(QString str, QObject *parent)    parameters:     Parameter  Type  Description      str  QString  String describing the classifier    parent  QObject  *  Parent of the object to be created       output:  ( Classifier  *) Returns a pointer to the  Classifier  described by the string   see:   Factory::make  example: Classifier *classifier = Classifier::make(\"Classifier(representation=Representation(property1=value1)\");\nclassifier- description(); // Returns \"Classifier(representation=Representation(property1=value1))\"", 
            "title": "Classifier *make(QString str, QObject *parent)"
        }, 
        {
            "location": "/api_docs/cpp_api/classifier/functions/", 
            "text": "void train(const \nQList\nMat\n \nimages, const \nQList\nfloat\n \nlabels)\n\n\nThis is a pure, virtual function. Train the classifier using the provided images and labels.\n\n\n\n\n\n\nfunction definition:\n\n\nvirtual void train(const QList\nMat\n \nimages, const QList\nfloat\n \nlabels) = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescriptions\n\n\n\n\n\n\n\n\n\n\nimages\n\n\nconst \nQList\nMat\n \n\n\nTraining images\n\n\n\n\n\n\nlabels\n\n\nconst \nQList\nfloat\n \n\n\nTraining labels\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (void)\n\n\n\n\nexample:\n// Create data for a 2-class classification problem\nQList\nMat\n images = QList\nMat\n() \n Template(\"training_pic1.jpg\").m()\n                                 \n Template(\"training_pic2.jpg\").m()\n                                 \n Template(\"training_pic3.jpg\").m()\n                                 \n Template(\"training_pic4.jpg\").m();\n\nQList\nfloat\n labels = QList\nfloat\n() \n 0 \n 0 \n 1 \n 1;\n\nClassifier *classifier = Classifier::make(\"Classifier\");\nrep-\ntrain(images, labels);\n\n\n\n\n\n\n\nfloat classify(const \nMat\n \nimage) const\n\n\nThis is a pure virtual function. Classify a provided input image.\n\n\n\n\n\n\nfunction description:\n\n\nvirtual float classify(const Mat \nimage) const = 0\n\n\n\n\n\n\n\nparameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nimage\n\n\nconst \nMat\n \n\n\nInput image to be classified\n\n\n\n\n\n\n\n\n\n\n\n\noutput:\n (float) Returns the classification value of the image. The value can be a confidence, a regression, or a class. In 2-class classification is it often a confidence which has been normalized such that 0 is the inflection point. Values below zero represent a negative classification and values above represent a positive classification.\n\n\n\n\nexample:\n\n        Classifier *classifier = Classifier::make(\"2ClassClassifier\"); // assume classifier is already trained\nTemplate p1(\"pos_image1.jpg\"); // positive sample\nTemplate n1(\"neg_image1.jpg\"); // negative sample\n\nclassifier-\nclassify(p1); // returns confidence \n 0\nclassifier-\nclassify(n1); // returns confidence \n 0", 
            "title": "Functions"
        }, 
        {
            "location": "/api_docs/cpp_api/classifier/functions/#train", 
            "text": "This is a pure, virtual function. Train the classifier using the provided images and labels.    function definition:  virtual void train(const QList Mat   images, const QList float   labels) = 0    parameters:     Parameter  Type  Descriptions      images  const  QList Mat    Training images    labels  const  QList float    Training labels       output:  (void)   example: // Create data for a 2-class classification problem\nQList Mat  images = QList Mat ()   Template(\"training_pic1.jpg\").m()\n                                   Template(\"training_pic2.jpg\").m()\n                                   Template(\"training_pic3.jpg\").m()\n                                   Template(\"training_pic4.jpg\").m();\n\nQList float  labels = QList float ()   0   0   1   1;\n\nClassifier *classifier = Classifier::make(\"Classifier\");\nrep- train(images, labels);", 
            "title": "void train(const QListMat images, const QListfloat labels)"
        }, 
        {
            "location": "/api_docs/cpp_api/classifier/functions/#classify", 
            "text": "This is a pure virtual function. Classify a provided input image.    function description:  virtual float classify(const Mat  image) const = 0    parameters:     Parameter  Type  Description      image  const  Mat    Input image to be classified       output:  (float) Returns the classification value of the image. The value can be a confidence, a regression, or a class. In 2-class classification is it often a confidence which has been normalized such that 0 is the inflection point. Values below zero represent a negative classification and values above represent a positive classification.   example: \n        Classifier *classifier = Classifier::make(\"2ClassClassifier\"); // assume classifier is already trained Template p1(\"pos_image1.jpg\"); // positive sample\nTemplate n1(\"neg_image1.jpg\"); // negative sample\n\nclassifier- classify(p1); // returns confidence   0\nclassifier- classify(n1); // returns confidence   0", 
            "title": "float classify(const Mat image) const"
        }, 
        {
            "location": "/plugin_docs/classification/", 
            "text": "AdaBoostTransform\n\n\nWraps OpenCV's Ada Boost framework\n\n\n\n\nfile:\n classification/adaboost.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nsee:\n \n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenum\n\n\ntype\n\n\nType of Adaboost to perform. Options are:\nDiscrete\nReal\nLogit\nGentle\nDefault is Real.\n\n\n\n\n\n\nenum\n\n\nsplitCriteria\n\n\nSplitting criteria used to choose optimal splits during a weak tree construction. Options are:\nDefault\nGini\nMisclass\nSqerr\nDefault is Default.\n\n\n\n\n\n\nint\n\n\nweakCount\n\n\nMaximum number of weak classifiers per stage. Default is 100.\n\n\n\n\n\n\nfloat\n\n\ntrimRate\n\n\nA threshold between 0 and 1 used to save computational time. Samples with summary weight\n\n\n\n\n\n\nint\n\n\nfolds\n\n\nOpenCV parameter variable. Default value is 0.\n\n\n\n\n\n\nint\n\n\nmaxDepth\n\n\nMaximum height of each weak classifier tree. Default is 1 (stumps).\n\n\n\n\n\n\nbool\n\n\nreturnConfidence\n\n\nReturn the confidence value of the classification or the class value of the classification. Default is true (return confidence value).\n\n\n\n\n\n\nbool\n\n\noverwriteMat\n\n\nIf true, the output template will be a 1x1 matrix with value equal to the confidence or classification (depending on returnConfidence). If false the output template will be the same as the input template. Default is true.\n\n\n\n\n\n\nQString\n\n\ninputVariable\n\n\nMetadata variable storing the label for each template. Default is \"Label\".\n\n\n\n\n\n\nQString\n\n\noutputVariable\n\n\nMetadata variable to store the confidence or classification of each template (depending on returnConfidence). If overwriteMat is true nothing will be written here. Default is \"\".\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBBLDAAlignmentTransform\n\n\nBoosted Binary LDA classifier for local alignment.\n\n\n\n\nfile:\n classification/lda.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nDFFSTransform\n\n\nComputes \nDistance\n From Feature Space (DFFS)\n\n\n\n\nfile:\n classification/lda.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nMoghaddam, Baback, and Alex Pentland.\n\n \n\"Probabilistic visual learning for object representation.\"\n\n Pattern Analysis and Machine Intelligence, IEEE Transactions on 19.7 (1997): 696-710.\n\n\n\n\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeep\n\n\nfloat\n\n\nSets PCA keep property. Default is 0.95.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDLibShapeResourceMaker\n\n\nWrapper to dlib's landmarker.\n\n\n\n\nfile:\n classification/dlib.cpp\n\n\ninherits:\n \nResourceMaker\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nDObjectDetectorTransform\n\n\nWrapper to dlib's trainable object detector.\n\n\n\n\nfile:\n classification/dlib.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nEBIFTransform\n\n\nFace Recognition Using Early Biologically Inspired Features\n\n\n\n\nfile:\n classification/ebif.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nLi, Min, et al.\n\n \n\"Face recognition using early biologically inspired features.\"\n\n Biometrics: Theory, Applications and Systems (BTAS), 2013 IEEE Sixth International Conference on. IEEE, 2013.\n\n\n\n\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nN\n\n\nint\n\n\nThe number of scales. Default is 6.\n\n\n\n\n\n\nM\n\n\nint\n\n\nThe number of orientations between 0 and pi. Default is 9.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nForestInductionTransform\n\n\nWraps OpenCV's random trees framework to induce features\n\n\n\n\nfile:\n classification/forest.cpp\n\n\ninherits:\n \nForestTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nsee:\n \n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuseRegressionValue\n\n\nbool\n\n\nSCOTT FILL ME IN.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nForestTransform\n\n\nWraps OpenCV's random trees framework\n\n\n\n\nfile:\n classification/forest.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nsee:\n \n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nclassification\n\n\nbool\n\n\nIf true the labels are expected to be categorical. Otherwise they are expected to be numerical. Default is true.\n\n\n\n\n\n\nsplitPercentage\n\n\nfloat\n\n\nUsed to calculate the minimum number of samples per split in a random tree. The minimum number of samples is calculated as the number of samples x splitPercentage. Default is 0.01.\n\n\n\n\n\n\nmaxDepth\n\n\nint\n\n\nThe maximum depth of each decision tree. Default is std::numeric_limits\n::max() and typically should be set by the user.\n\n\n\n\n\n\nmaxTrees\n\n\nint\n\n\nThe maximum number of trees in the forest. Default is 10.\n\n\n\n\n\n\nforestAccuracy\n\n\nfloat\n\n\nA sufficient accuracy for the forest for training to terminate. Used if termCrit is EPS or Both. Default is 0.1.\n\n\n\n\n\n\nreturnConfidence\n\n\nbool\n\n\nIf both classification and returnConfidence are use a fuzzy class label as the output of the forest. Default is true.\n\n\n\n\n\n\noverwriteMat\n\n\nbool\n\n\nIf true set dst to be a 1x1 Mat with the forest response as its value. Otherwise append the forest response to metadata using outputVariable as a key. Default is true.\n\n\n\n\n\n\ninputVariable\n\n\nQString\n\n\nThe metadata key for each templates label. Default is \"Label\".\n\n\n\n\n\n\noutputVariable\n\n\nQString\n\n\nThe metadata key for the forest response if overwriteMat is false. Default is \"\".\n\n\n\n\n\n\nweight\n\n\nbool\n\n\nIf true and classification is true the random forest will use prior accuracies. Default is false.\n\n\n\n\n\n\ntermCrit\n\n\nenum\n\n\nTermination criteria for training the random forest. Options are Iter, EPS and Both. Iter terminates when the maximum number of trees is reached. EPS terminates when forestAccuracy is met. Both terminates when either is true. Default is Iter.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIPC2013FaceRecognitionTransform\n\n\nIntel Perceptual Computing SDK 2013 Face Recognition\n\n\n\n\nfile:\n classification/ipc2013.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nLDATransform\n\n\nProjects input into learned Linear Discriminant Analysis subspace.\n\n\n\n\nfile:\n classification/lda.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nBrendan Klare\n, \nJosh Klontz\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npcaKeep\n\n\nfloat\n\n\nBRENDAN OR JOSH FILL ME IN. Default is 0.98.\n\n\n\n\n\n\npcaWhiten\n\n\nbool\n\n\nBRENDAN OR JOSH FILL ME IN. Default is false.\n\n\n\n\n\n\ndirectLDA\n\n\nint\n\n\nBRENDAN OR JOSH FILL ME IN. Default is 0.\n\n\n\n\n\n\ndirectDrop\n\n\nfloat\n\n\nBRENDAN OR JOSH FILL ME IN. Default is 0.1.\n\n\n\n\n\n\ninputVariable\n\n\nQString\n\n\nBRENDAN OR JOSH FILL ME IN. Default is \"Label\".\n\n\n\n\n\n\nisBinary\n\n\nbool\n\n\nBRENDAN OR JOSH FILL ME IN. Default is false.\n\n\n\n\n\n\nnormalize\n\n\nbool\n\n\nBRENDAN OR JOSH FILL ME IN. Default is true.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinear\n\n\nWraps LibLinear's Linear SVM framework.\n\n\n\n\nfile:\n classification/liblinear.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nMLPTransform\n\n\nWraps OpenCV's multi-layer perceptron framework\n\n\n\n\nfile:\n classification/mlp.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nsee:\n \n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkernel\n\n\nenum\n\n\nType of MLP kernel to use. Options are Identity, Sigmoid, Gaussian. Default is Sigmoid.\n\n\n\n\n\n\nalpha\n\n\nfloat\n\n\nDetermines activation function for neural network. See OpenCV documentation for more details. Default is 1.\n\n\n\n\n\n\nbeta\n\n\nfloat\n\n\nDetermines activation function for neural network. See OpenCV documentation for more details. Default is 1.\n\n\n\n\n\n\ninputVariables\n\n\nQStringList\n\n\nMetadata keys for the labels associated with each template. There should be the same number of keys in the list as there are neurons in the final layer. Default is QStringList().\n\n\n\n\n\n\noutputVariables\n\n\nQStringList\n\n\nMetadata keys to store the output of the neural network. There should be the same number of keys in the list as there are neurons in the final layer. Default is QStringList().\n\n\n\n\n\n\nneuronsPerLayer\n\n\nQList\n\n\nThe number of neurons in each layer of the net. Default is QList\n() \n 1 \n 1.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNT4Compare\n\n\nCompare templates with Neurotech SDK 4\n\n\n\n\nfile:\n classification/nt4.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nJosh Klontz\n, \nE. Taborsky\n\n\nproperties:\n None\n\n\n\n\n\n\nNT4DetectFace\n\n\nNeurotech face detection\n\n\n\n\nfile:\n classification/nt4.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n, \nE. Taborsky\n\n\nproperties:\n None\n\n\n\n\n\n\nNT4EnrollFace\n\n\nEnroll face in Neurotech SDK 4\n\n\n\n\nfile:\n classification/nt4.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nNT4EnrollIris\n\n\nEnroll iris in Neurotech SDK 4\n\n\n\n\nfile:\n classification/nt4.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nE. Taborsky\n\n\nproperties:\n None\n\n\n\n\n\n\nPCATransform\n\n\nProjects input into learned Principal Component Analysis subspace.\n\n\n\n\nfile:\n classification/lda.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nBrendan Klare\n, \nJosh Klontz\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeep\n\n\nfloat\n\n\nOptions are:\nkeep \n 0 - All eigenvalues are retained\nkeep == 0 - No PCA is performed and the eigenvectors form an identity matrix\n0 \n keep \n 1 - Keep is the fraction of the variance to retain\nkeep \n= 1 - keep is the number of leading eigenvectors to retain\nDefault is 0.95.\n\n\n\n\n\n\ndrop\n\n\nint\n\n\nBRENDAN OR JOSH FILL ME IN. Default is 0.\n\n\n\n\n\n\nwhiten\n\n\nbool\n\n\nBRENDAN OR JOSH FILL ME IN. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPP4Compare\n\n\nCompare faces using PittPatt 4.\n\n\n\n\nfile:\n classification/pp4.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nPP4EnrollTransform\n\n\nEnroll faces in PittPatt 4\n\n\n\n\nfile:\n classification/pp4.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetectOnly\n\n\nbool\n\n\nIf true, return all detected faces. Otherwise, return only faces that are suitable for recognition. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPP5CompareDistance\n\n\nCompare templates with PP5. PP5 distance is known to be asymmetric\n\n\n\n\nfile:\n classification/pp5.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n, \nE. Taborsky\n\n\nproperties:\n None\n\n\n\n\n\n\nPP5EnrollTransform\n\n\nEnroll faces in PP5\n\n\n\n\nfile:\n classification/pp5.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n, \nE. Taborsky\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetectOnly\n\n\nbool\n\n\nIf true, enroll all detected faces. Otherwise, only enroll faces suitable for recognition. Default is false.\n\n\n\n\n\n\nrequireLandmarks\n\n\nbool\n\n\nIf true, require the right eye, left eye, and nose base to be detectable by PP5. If this does not happen FTE is set to true for that template. Default is false.\n\n\n\n\n\n\nadaptiveMinSize\n\n\nfloat\n\n\nThe minimum face size as a percentage of total image width. 0.1 corresponds to a minimum face size of 10% the total image width. Default is 0.01.\n\n\n\n\n\n\nminSize\n\n\nint\n\n\nThe absolute minimum face size to search for. This is not a pixel value. Please see PittPatt documentation for the relationship between minSize and pixel IPD. Default is 4.\n\n\n\n\n\n\nlandmarkRange\n\n\nenum\n\n\nRange of landmarks to search for. Options are Frontal, Extended, Full, and Comprehensive. Default is Comprehensive.\n\n\n\n\n\n\nsearchPruningAggressiveness\n\n\nint\n\n\nThe amount of aggressiveness involved in search for faces in images. 0 means all scales and locations are searched. 1 means fewer detectors are used in the early stages but all scales are still searched. 2-4 means that the largest faces are found first and then fewer scales are searched. Default is 0.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPP5GalleryTransform\n\n\nDOCUMENT ME\n\n\n\n\nfile:\n classification/pp5.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nRowWisePCATransform\n\n\nPCA on each row.\n\n\n\n\nfile:\n classification/lda.cpp\n\n\ninherits:\n \nPCATransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nSVMTransform\n\n\nWraps OpenCV's SVM framework.\n\n\n\n\nfile:\n classification/svm.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\n\n\nread:\n\n\n\n\nC. Burges.\n\n \n\"A tutorial on support vector machines for pattern recognition\"\n\n Knowledge Discovery and Data Mining 2(2), 1998.\n\n\n\n\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nKernel\n\n\nenum\n\n\nThe type of SVM kernel to use. Options are Linear, Poly, RBF, Sigmoid. Default is Linear.\n\n\n\n\n\n\nType\n\n\nenum\n\n\nThe type of SVM to do. Options are C_SVC, NU_SVC, ONE_CLASS, EPS_SVR, NU_SVR. Default is C_SVC.\n\n\n\n\n\n\nC\n\n\nfloat\n\n\nParameter C of an SVM optimization problem. Needed when Type is C_SVC, EPS_SVR or NU_SVR. Default is -1.\n\n\n\n\n\n\ngamma\n\n\nfloat\n\n\nParameter gamma of a kernel function. Needed when Kernel is Poly, RBF, or Sigmoid. Default is -1.\n\n\n\n\n\n\ninputVariable\n\n\nQString\n\n\nMetadata variable storing the label for each template. Default is \"Label\".\n\n\n\n\n\n\noutputVariable\n\n\nQString\n\n\nMetadata variable to store the prediction value of the trained SVM. If type is EPS_SVR or NU_SVR the stored value is the output of the SVM. Otherwise the value is the output of the SVM mapped through the reverse lookup table. Default is \"\".\n\n\n\n\n\n\nreturnDFVal\n\n\nbool\n\n\nIf true, dst is set to a 1x1 Mat with value equal to the predicted output of the SVM. Default is false.\n\n\n\n\n\n\ntermCriteria\n\n\nint\n\n\nThe maximum number of training iterations. Default is 1000.\n\n\n\n\n\n\nfolds\n\n\nint\n\n\nCross validation parameter used for autoselecting other parameters. Default is 5.\n\n\n\n\n\n\nbalanceFolds\n\n\nbool\n\n\nIf true and the problem is 2-class classification then more balanced cross validation subsets are created. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSparseLDATransform\n\n\nProjects input into learned Linear Discriminant Analysis subspace learned on a sparse subset of features with the highest weight in the original LDA algorithm.\n\n\n\n\nfile:\n classification/lda.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvarThreshold\n\n\nfloat\n\n\nBRENDAN FILL ME IN. Default is 1.5.\n\n\n\n\n\n\npcaKeep\n\n\nfloat\n\n\nBRENDAN FILL ME IN. Default is 0.98.\n\n\n\n\n\n\nnormalize\n\n\nbool\n\n\nBRENDAN FILL ME IN. Default is true.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTurkClassifierTransform\n\n\nConvenience class for training turk attribute regressors\n\n\n\n\nfile:\n classification/turk.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nQString\n\n\nMetadata key to pass input values to SVM. Actual lookup key is \"key_value\" where value is each value in the parameter values. Default is \"\".\n\n\n\n\n\n\nvalues\n\n\nQStringList\n\n\nMetadata keys to pass input values to SVM. Actual lookup key is \"key_value\" where key is the parameter key and value is each value in this list. Each passed value trains a new SVM with the input values found in metadata\n\"key_value\"\n. Default is \"\".\n\n\n\n\n\n\nisMeta\n\n\nbool\n\n\nIf true, \"Average+SaveMat(predicted_key_value)\" is appended to each classifier. If false, nothing is appended. Default is false.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWCDATransform\n\n\nProjects input into a within-class minimizing subspace.\n\n\nLike LDA but without the explicit between-class consideration.\n\n\nNote on Compression:\nProjection matricies can become quite large, resulting in proportionally large model files.\nWCDA automatically alleviates this issue with lossy compression of the projection matrix.\nEach element is stored as an 8-bit integer instead of a 32-bit float, resulting in a 75% reduction in the size of the projection matrix.\nA non-linear (sqrt) scaling is used because element values are distributed around 0, in affect allowing for higher precision storage of the more frequently occuring values.\n\n\n\n\nfile:\n classification/lda.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None", 
            "title": "Classification"
        }, 
        {
            "location": "/plugin_docs/classification/#adaboosttransform", 
            "text": "Wraps OpenCV's Ada Boost framework   file:  classification/adaboost.cpp  inherits:   Transform  author(s):   Scott Klum  see:     properties:     Property  Type  Description      enum  type  Type of Adaboost to perform. Options are: Discrete Real Logit Gentle Default is Real.    enum  splitCriteria  Splitting criteria used to choose optimal splits during a weak tree construction. Options are: Default Gini Misclass Sqerr Default is Default.    int  weakCount  Maximum number of weak classifiers per stage. Default is 100.    float  trimRate  A threshold between 0 and 1 used to save computational time. Samples with summary weight    int  folds  OpenCV parameter variable. Default value is 0.    int  maxDepth  Maximum height of each weak classifier tree. Default is 1 (stumps).    bool  returnConfidence  Return the confidence value of the classification or the class value of the classification. Default is true (return confidence value).    bool  overwriteMat  If true, the output template will be a 1x1 matrix with value equal to the confidence or classification (depending on returnConfidence). If false the output template will be the same as the input template. Default is true.    QString  inputVariable  Metadata variable storing the label for each template. Default is \"Label\".    QString  outputVariable  Metadata variable to store the confidence or classification of each template (depending on returnConfidence). If overwriteMat is true nothing will be written here. Default is \"\".", 
            "title": "AdaBoostTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#bbldaalignmenttransform", 
            "text": "Boosted Binary LDA classifier for local alignment.   file:  classification/lda.cpp  inherits:   MetaTransform  author(s):   Unknown  properties:  None", 
            "title": "BBLDAAlignmentTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#dffstransform", 
            "text": "Computes  Distance  From Feature Space (DFFS)   file:  classification/lda.cpp  inherits:   Transform  author(s):   Josh Klontz   read:   Moghaddam, Baback, and Alex Pentland. \n  \"Probabilistic visual learning for object representation.\" \n Pattern Analysis and Machine Intelligence, IEEE Transactions on 19.7 (1997): 696-710.     properties:     Property  Type  Description      keep  float  Sets PCA keep property. Default is 0.95.", 
            "title": "DFFSTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#dlibshaperesourcemaker", 
            "text": "Wrapper to dlib's landmarker.   file:  classification/dlib.cpp  inherits:   ResourceMaker  author(s):   Scott Klum  properties:  None", 
            "title": "DLibShapeResourceMaker"
        }, 
        {
            "location": "/plugin_docs/classification/#dobjectdetectortransform", 
            "text": "Wrapper to dlib's trainable object detector.   file:  classification/dlib.cpp  inherits:   Transform  author(s):   Scott Klum  properties:  None", 
            "title": "DObjectDetectorTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#ebiftransform", 
            "text": "Face Recognition Using Early Biologically Inspired Features   file:  classification/ebif.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz   read:   Li, Min, et al. \n  \"Face recognition using early biologically inspired features.\" \n Biometrics: Theory, Applications and Systems (BTAS), 2013 IEEE Sixth International Conference on. IEEE, 2013.     properties:     Property  Type  Description      N  int  The number of scales. Default is 6.    M  int  The number of orientations between 0 and pi. Default is 9.", 
            "title": "EBIFTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#forestinductiontransform", 
            "text": "Wraps OpenCV's random trees framework to induce features   file:  classification/forest.cpp  inherits:   ForestTransform  author(s):   Scott Klum  see:     properties:     Property  Type  Description      useRegressionValue  bool  SCOTT FILL ME IN.", 
            "title": "ForestInductionTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#foresttransform", 
            "text": "Wraps OpenCV's random trees framework   file:  classification/forest.cpp  inherits:   Transform  author(s):   Scott Klum  see:     properties:     Property  Type  Description      classification  bool  If true the labels are expected to be categorical. Otherwise they are expected to be numerical. Default is true.    splitPercentage  float  Used to calculate the minimum number of samples per split in a random tree. The minimum number of samples is calculated as the number of samples x splitPercentage. Default is 0.01.    maxDepth  int  The maximum depth of each decision tree. Default is std::numeric_limits ::max() and typically should be set by the user.    maxTrees  int  The maximum number of trees in the forest. Default is 10.    forestAccuracy  float  A sufficient accuracy for the forest for training to terminate. Used if termCrit is EPS or Both. Default is 0.1.    returnConfidence  bool  If both classification and returnConfidence are use a fuzzy class label as the output of the forest. Default is true.    overwriteMat  bool  If true set dst to be a 1x1 Mat with the forest response as its value. Otherwise append the forest response to metadata using outputVariable as a key. Default is true.    inputVariable  QString  The metadata key for each templates label. Default is \"Label\".    outputVariable  QString  The metadata key for the forest response if overwriteMat is false. Default is \"\".    weight  bool  If true and classification is true the random forest will use prior accuracies. Default is false.    termCrit  enum  Termination criteria for training the random forest. Options are Iter, EPS and Both. Iter terminates when the maximum number of trees is reached. EPS terminates when forestAccuracy is met. Both terminates when either is true. Default is Iter.", 
            "title": "ForestTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#ipc2013facerecognitiontransform", 
            "text": "Intel Perceptual Computing SDK 2013 Face Recognition   file:  classification/ipc2013.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "IPC2013FaceRecognitionTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#ldatransform", 
            "text": "Projects input into learned Linear Discriminant Analysis subspace.   file:  classification/lda.cpp  inherits:   Transform  author(s):   Brendan Klare ,  Josh Klontz   properties:     Property  Type  Description      pcaKeep  float  BRENDAN OR JOSH FILL ME IN. Default is 0.98.    pcaWhiten  bool  BRENDAN OR JOSH FILL ME IN. Default is false.    directLDA  int  BRENDAN OR JOSH FILL ME IN. Default is 0.    directDrop  float  BRENDAN OR JOSH FILL ME IN. Default is 0.1.    inputVariable  QString  BRENDAN OR JOSH FILL ME IN. Default is \"Label\".    isBinary  bool  BRENDAN OR JOSH FILL ME IN. Default is false.    normalize  bool  BRENDAN OR JOSH FILL ME IN. Default is true.", 
            "title": "LDATransform"
        }, 
        {
            "location": "/plugin_docs/classification/#linear", 
            "text": "Wraps LibLinear's Linear SVM framework.   file:  classification/liblinear.cpp  inherits:   Transform  author(s):   Scott Klum  properties:  None", 
            "title": "Linear"
        }, 
        {
            "location": "/plugin_docs/classification/#mlptransform", 
            "text": "Wraps OpenCV's multi-layer perceptron framework   file:  classification/mlp.cpp  inherits:   MetaTransform  author(s):   Scott Klum  see:     properties:     Property  Type  Description      kernel  enum  Type of MLP kernel to use. Options are Identity, Sigmoid, Gaussian. Default is Sigmoid.    alpha  float  Determines activation function for neural network. See OpenCV documentation for more details. Default is 1.    beta  float  Determines activation function for neural network. See OpenCV documentation for more details. Default is 1.    inputVariables  QStringList  Metadata keys for the labels associated with each template. There should be the same number of keys in the list as there are neurons in the final layer. Default is QStringList().    outputVariables  QStringList  Metadata keys to store the output of the neural network. There should be the same number of keys in the list as there are neurons in the final layer. Default is QStringList().    neuronsPerLayer  QList  The number of neurons in each layer of the net. Default is QList ()   1   1.", 
            "title": "MLPTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#nt4compare", 
            "text": "Compare templates with Neurotech SDK 4   file:  classification/nt4.cpp  inherits:   Distance  author(s):   Josh Klontz ,  E. Taborsky  properties:  None", 
            "title": "NT4Compare"
        }, 
        {
            "location": "/plugin_docs/classification/#nt4detectface", 
            "text": "Neurotech face detection   file:  classification/nt4.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz ,  E. Taborsky  properties:  None", 
            "title": "NT4DetectFace"
        }, 
        {
            "location": "/plugin_docs/classification/#nt4enrollface", 
            "text": "Enroll face in Neurotech SDK 4   file:  classification/nt4.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "NT4EnrollFace"
        }, 
        {
            "location": "/plugin_docs/classification/#nt4enrolliris", 
            "text": "Enroll iris in Neurotech SDK 4   file:  classification/nt4.cpp  inherits:   UntrainableTransform  author(s):   E. Taborsky  properties:  None", 
            "title": "NT4EnrollIris"
        }, 
        {
            "location": "/plugin_docs/classification/#pcatransform", 
            "text": "Projects input into learned Principal Component Analysis subspace.   file:  classification/lda.cpp  inherits:   Transform  author(s):   Brendan Klare ,  Josh Klontz   properties:     Property  Type  Description      keep  float  Options are: keep   0 - All eigenvalues are retained keep == 0 - No PCA is performed and the eigenvectors form an identity matrix 0   keep   1 - Keep is the fraction of the variance to retain keep  = 1 - keep is the number of leading eigenvectors to retain Default is 0.95.    drop  int  BRENDAN OR JOSH FILL ME IN. Default is 0.    whiten  bool  BRENDAN OR JOSH FILL ME IN. Default is false.", 
            "title": "PCATransform"
        }, 
        {
            "location": "/plugin_docs/classification/#pp4compare", 
            "text": "Compare faces using PittPatt 4.   file:  classification/pp4.cpp  inherits:   Distance  author(s):   Josh Klontz  properties:  None", 
            "title": "PP4Compare"
        }, 
        {
            "location": "/plugin_docs/classification/#pp4enrolltransform", 
            "text": "Enroll faces in PittPatt 4   file:  classification/pp4.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz   properties:     Property  Type  Description      detectOnly  bool  If true, return all detected faces. Otherwise, return only faces that are suitable for recognition. Default is false.", 
            "title": "PP4EnrollTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#pp5comparedistance", 
            "text": "Compare templates with PP5. PP5 distance is known to be asymmetric   file:  classification/pp5.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz ,  E. Taborsky  properties:  None", 
            "title": "PP5CompareDistance"
        }, 
        {
            "location": "/plugin_docs/classification/#pp5enrolltransform", 
            "text": "Enroll faces in PP5   file:  classification/pp5.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz ,  E. Taborsky   properties:     Property  Type  Description      detectOnly  bool  If true, enroll all detected faces. Otherwise, only enroll faces suitable for recognition. Default is false.    requireLandmarks  bool  If true, require the right eye, left eye, and nose base to be detectable by PP5. If this does not happen FTE is set to true for that template. Default is false.    adaptiveMinSize  float  The minimum face size as a percentage of total image width. 0.1 corresponds to a minimum face size of 10% the total image width. Default is 0.01.    minSize  int  The absolute minimum face size to search for. This is not a pixel value. Please see PittPatt documentation for the relationship between minSize and pixel IPD. Default is 4.    landmarkRange  enum  Range of landmarks to search for. Options are Frontal, Extended, Full, and Comprehensive. Default is Comprehensive.    searchPruningAggressiveness  int  The amount of aggressiveness involved in search for faces in images. 0 means all scales and locations are searched. 1 means fewer detectors are used in the early stages but all scales are still searched. 2-4 means that the largest faces are found first and then fewer scales are searched. Default is 0.", 
            "title": "PP5EnrollTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#pp5gallerytransform", 
            "text": "DOCUMENT ME   file:  classification/pp5.cpp  inherits:   UntrainableMetaTransform  author(s):   Unknown  properties:  None", 
            "title": "PP5GalleryTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#rowwisepcatransform", 
            "text": "PCA on each row.   file:  classification/lda.cpp  inherits:   PCATransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RowWisePCATransform"
        }, 
        {
            "location": "/plugin_docs/classification/#svmtransform", 
            "text": "Wraps OpenCV's SVM framework.   file:  classification/svm.cpp  inherits:   Transform  author(s):   Josh Klontz  see:     read:   C. Burges. \n  \"A tutorial on support vector machines for pattern recognition\" \n Knowledge Discovery and Data Mining 2(2), 1998.     properties:     Property  Type  Description      Kernel  enum  The type of SVM kernel to use. Options are Linear, Poly, RBF, Sigmoid. Default is Linear.    Type  enum  The type of SVM to do. Options are C_SVC, NU_SVC, ONE_CLASS, EPS_SVR, NU_SVR. Default is C_SVC.    C  float  Parameter C of an SVM optimization problem. Needed when Type is C_SVC, EPS_SVR or NU_SVR. Default is -1.    gamma  float  Parameter gamma of a kernel function. Needed when Kernel is Poly, RBF, or Sigmoid. Default is -1.    inputVariable  QString  Metadata variable storing the label for each template. Default is \"Label\".    outputVariable  QString  Metadata variable to store the prediction value of the trained SVM. If type is EPS_SVR or NU_SVR the stored value is the output of the SVM. Otherwise the value is the output of the SVM mapped through the reverse lookup table. Default is \"\".    returnDFVal  bool  If true, dst is set to a 1x1 Mat with value equal to the predicted output of the SVM. Default is false.    termCriteria  int  The maximum number of training iterations. Default is 1000.    folds  int  Cross validation parameter used for autoselecting other parameters. Default is 5.    balanceFolds  bool  If true and the problem is 2-class classification then more balanced cross validation subsets are created. Default is false.", 
            "title": "SVMTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#sparseldatransform", 
            "text": "Projects input into learned Linear Discriminant Analysis subspace learned on a sparse subset of features with the highest weight in the original LDA algorithm.   file:  classification/lda.cpp  inherits:   Transform  author(s):   Brendan Klare   properties:     Property  Type  Description      varThreshold  float  BRENDAN FILL ME IN. Default is 1.5.    pcaKeep  float  BRENDAN FILL ME IN. Default is 0.98.    normalize  bool  BRENDAN FILL ME IN. Default is true.", 
            "title": "SparseLDATransform"
        }, 
        {
            "location": "/plugin_docs/classification/#turkclassifiertransform", 
            "text": "Convenience class for training turk attribute regressors   file:  classification/turk.cpp  inherits:   Transform  author(s):   Josh Klontz   properties:     Property  Type  Description      key  QString  Metadata key to pass input values to SVM. Actual lookup key is \"key_value\" where value is each value in the parameter values. Default is \"\".    values  QStringList  Metadata keys to pass input values to SVM. Actual lookup key is \"key_value\" where key is the parameter key and value is each value in this list. Each passed value trains a new SVM with the input values found in metadata \"key_value\" . Default is \"\".    isMeta  bool  If true, \"Average+SaveMat(predicted_key_value)\" is appended to each classifier. If false, nothing is appended. Default is false.", 
            "title": "TurkClassifierTransform"
        }, 
        {
            "location": "/plugin_docs/classification/#wcdatransform", 
            "text": "Projects input into a within-class minimizing subspace.  Like LDA but without the explicit between-class consideration.  Note on Compression:\nProjection matricies can become quite large, resulting in proportionally large model files.\nWCDA automatically alleviates this issue with lossy compression of the projection matrix.\nEach element is stored as an 8-bit integer instead of a 32-bit float, resulting in a 75% reduction in the size of the projection matrix.\nA non-linear (sqrt) scaling is used because element values are distributed around 0, in affect allowing for higher precision storage of the more frequently occuring values.   file:  classification/lda.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "WCDATransform"
        }, 
        {
            "location": "/plugin_docs/cluster/", 
            "text": "CollectNNTransform\n\n\nCollect nearest neighbors and append them to metadata.\n\n\n\n\nfile:\n cluster/collectnn.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeep\n\n\nint\n\n\nThe maximum number of nearest neighbors to keep. Default is 20.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKMeansTransform\n\n\nWraps OpenCV kmeans and flann.\n\n\n\n\nfile:\n cluster/kmeans.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkTrain\n\n\nint\n\n\nThe number of random centroids to make at train time. Default is 256.\n\n\n\n\n\n\nkSearch\n\n\nint\n\n\nThe number of nearest neighbors to search for at runtime. Default is 1.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKNNTransform\n\n\nK nearest neighbors classifier.\n\n\n\n\nfile:\n cluster/knn.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nLogNNTransform\n\n\nLog nearest neighbors to specified file.\n\n\n\n\nfile:\n cluster/lognn.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfileName\n\n\nQString\n\n\nThe name of the log file. An empty fileName won't be written to. Default is \"\".\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRandomCentroidsTransform\n\n\nChooses k random points to be centroids.\n\n\n\n\nfile:\n cluster/randomcentroids.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nsee:\n \n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkTrain\n\n\nint\n\n\nThe number of random centroids to make at train time. Default is 256.\n\n\n\n\n\n\nkSearch\n\n\nint\n\n\nThe number of nearest neighbors to search for at runtime. Default is 1.", 
            "title": "Cluster"
        }, 
        {
            "location": "/plugin_docs/cluster/#collectnntransform", 
            "text": "Collect nearest neighbors and append them to metadata.   file:  cluster/collectnn.cpp  inherits:   UntrainableMetaTransform  author(s):   Charles Otto   properties:     Property  Type  Description      keep  int  The maximum number of nearest neighbors to keep. Default is 20.", 
            "title": "CollectNNTransform"
        }, 
        {
            "location": "/plugin_docs/cluster/#kmeanstransform", 
            "text": "Wraps OpenCV kmeans and flann.   file:  cluster/kmeans.cpp  inherits:   Transform  author(s):   Josh Klontz  see:     properties:     Property  Type  Description      kTrain  int  The number of random centroids to make at train time. Default is 256.    kSearch  int  The number of nearest neighbors to search for at runtime. Default is 1.", 
            "title": "KMeansTransform"
        }, 
        {
            "location": "/plugin_docs/cluster/#knntransform", 
            "text": "K nearest neighbors classifier.   file:  cluster/knn.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "KNNTransform"
        }, 
        {
            "location": "/plugin_docs/cluster/#lognntransform", 
            "text": "Log nearest neighbors to specified file.   file:  cluster/lognn.cpp  inherits:   TimeVaryingTransform  author(s):   Charles Otto   properties:     Property  Type  Description      fileName  QString  The name of the log file. An empty fileName won't be written to. Default is \"\".", 
            "title": "LogNNTransform"
        }, 
        {
            "location": "/plugin_docs/cluster/#randomcentroidstransform", 
            "text": "Chooses k random points to be centroids.   file:  cluster/randomcentroids.cpp  inherits:   Transform  author(s):   Austin Blanton  see:     properties:     Property  Type  Description      kTrain  int  The number of random centroids to make at train time. Default is 256.    kSearch  int  The number of nearest neighbors to search for at runtime. Default is 1.", 
            "title": "RandomCentroidsTransform"
        }, 
        {
            "location": "/plugin_docs/core/", 
            "text": "CacheTransform\n\n\nCaches \nTransform\n::project() results.\n\n\n\n\nfile:\n core/cache.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCollectOutputTransform\n\n\nDOCUMENT ME CHARLES\n\n\n\n\nfile:\n core/stream.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nContractTransform\n\n\nIt's like the opposite of ExpandTransform, but not really\n\n\nGiven a \nTemplateList\n as input, concatenate them into a single \nTemplate\n\n\n\n\nfile:\n core/contract.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nCrossValidateTransform\n\n\nCross validate a trainable \nTransform\n.\n\n\nTwo flags can be put in \nFile\n metadata that are related to cross-validation and are used to\nextend a testing gallery:\n\n\n\n\n\n\n\n\nflag\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\nallPartitions\n\n\nThis flag is intended to be used when comparing the performance of an untrainable algorithm (e.g. a COTS algorithm) against a trainable algorithm that was trained using cross-validation. All templates with the allPartitions flag will be compared against for every partition. As untrainable algorithms will have no use for the CrossValidateTransform, this flag is only meaningful at comparison time (but care has been taken so that one can train and enroll without issue if these \nFile\ns are present in the used \nGallery\n).\n\n\n\n\n\n\nduplicatePartitions\n\n\nThis flag is similar to allPartitions in that it causes the same template to be used during comparison for every partition. The difference is that duplicatePartitions will duplicate each marked template and project it into the model space constituded by the child transforms of CrossValidateTransform. Again, care has been take such that one can train with these templates in the used \nGallery\n successfully (they will simply be omitted).\n\n\n\n\n\n\n\n\nTo use an extended \nGallery\n, add an allPartitions=\"true\" flag to the gallery sigset for those images that should be compared\nagainst for all testing partitions.\n\n\n\n\nfile:\n core/crossvalidate.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n, \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nDirectStreamTransform\n\n\nDOCUMENT ME CHARLES\n\n\n\n\nfile:\n core/stream.cpp\n\n\ninherits:\n \nCompositeTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nDiscardTemplatesTransform\n\n\nDOCUMENT ME\n\n\n\n\nfile:\n core/discardtemplates.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nDiscardTransform\n\n\nRemoves all matrices from a \nTemplate\n.\n\n\n\n\nfile:\n core/discard.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDistributeTemplateTransform\n\n\nDOCUMENT ME CHARLES\n\n\n\n\nfile:\n core/distributetemplate.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nDownsampleTrainingTransform\n\n\nDOCUMENT ME JOSH\n\n\n\n\nfile:\n core/downsampletraining.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nEventTransform\n\n\nDOCUMENT ME\n\n\n\n\nfile:\n core/event.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nExpandTransform\n\n\nPerforms an expansion step on an input \nTemplateList\n. Each matrix in each input \nTemplate\n is expanded into its own \nTemplate\n.\n\n\n\n\nfile:\n core/expand.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nFTETransform\n\n\nFlags images that failed to enroll based on the specified \nTransform\n.\n\n\n\n\nfile:\n core/fte.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nFirstTransform\n\n\nRemoves all but the first matrix from the \nTemplate\n.\n\n\n\n\nfile:\n core/first.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nForkTransform\n\n\nTransforms in parallel.\n\n\nThe source \nTemplate\n is seperately given to each transform and the results are appended together.\n\n\n\n\nfile:\n core/fork.cpp\n\n\ninherits:\n \nCompositeTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nGalleryCompareTransform\n\n\nCompare each \nTemplate\n to a fixed \nGallery\n (with name = galleryName), using the specified distance.\ndst will contain a 1 by n vector of scores.\n\n\n\n\nfile:\n core/gallerycompare.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nIdentityTransform\n\n\nA no-op \nTransform\n.\n\n\n\n\nfile:\n core/identity.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nIndependentTransform\n\n\nClones the \nTransform\n so that it can be applied independently.\n\n\nIndependent \nTransform\ns expect single-matrix \nTemplate\n.\n\n\n\n\nfile:\n core/independent.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nJNITransform\n\n\nExecute Java code from OpenBR using the JNI\n\n\n\n\nfile:\n core/jni.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJordan Cheney\n\n\nproperties:\n None\n\n\n\n\n\n\nLikelyTransform\n\n\nGeneric interface to Likely JIT compiler\n\n\n\n\nfile:\n core/likely.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nsee:\n\n\n\n\nHomepage\n\n\nAPI Documentation\n\n\n\n\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\n\n\nLoadStoreTransform\n\n\nCaches \nTransform\n training.\n\n\n\n\nfile:\n core/loadstore.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nPipeTransform\n\n\nTransforms in series.\n\n\nThe source \nTemplate\n is given to the first transform and the resulting \nTemplate\n is passed to the next transform, etc.\n\n\n\n\nfile:\n core/pipe.cpp\n\n\ninherits:\n \nCompositeTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nProcessWrapperTransform\n\n\nInterface to a separate process\n\n\n\n\nfile:\n core/processwrapper.cpp\n\n\ninherits:\n \nWrapperTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nProgressCounterTransform\n\n\nDOCUMENT ME CHARLES\n\n\n\n\nfile:\n core/progresscounter.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nPropagateTransform\n\n\nEnsures that a template will be propogated.\n\n\n\n\nfile:\n core/propagate.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nRemoveTransform\n\n\nRemoves the matrix from the \nTemplate\n at the specified index.\n\n\n\n\nfile:\n core/remove.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRestTransform\n\n\nRemoves the first matrix from the \nTemplate\n.\n\n\n\n\nfile:\n core/rest.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nSchrodingerTransform\n\n\nGenerates two \nTemplate\n, one of which is passed through a \nTransform\n and the other\nis not. No cats were harmed in the making of this \nTransform\n.\n\n\n\n\nfile:\n core/schrodinger.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nSingletonTransform\n\n\nA globally shared \nTransform\n.\n\n\n\n\nfile:\n core/singleton.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nStreamTransform\n\n\nDOCUMENT ME CHARLES\n\n\n\n\nfile:\n core/stream.cpp\n\n\ninherits:\n \nWrapperTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None", 
            "title": "Core"
        }, 
        {
            "location": "/plugin_docs/core/#cachetransform", 
            "text": "Caches  Transform ::project() results.   file:  core/cache.cpp  inherits:   MetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CacheTransform"
        }, 
        {
            "location": "/plugin_docs/core/#collectoutputtransform", 
            "text": "DOCUMENT ME CHARLES   file:  core/stream.cpp  inherits:   TimeVaryingTransform  author(s):   Charles Otto  properties:  None", 
            "title": "CollectOutputTransform"
        }, 
        {
            "location": "/plugin_docs/core/#contracttransform", 
            "text": "It's like the opposite of ExpandTransform, but not really  Given a  TemplateList  as input, concatenate them into a single  Template   file:  core/contract.cpp  inherits:   UntrainableMetaTransform  author(s):   Charles Otto  properties:  None", 
            "title": "ContractTransform"
        }, 
        {
            "location": "/plugin_docs/core/#crossvalidatetransform", 
            "text": "Cross validate a trainable  Transform .  Two flags can be put in  File  metadata that are related to cross-validation and are used to\nextend a testing gallery:     flag  description      allPartitions  This flag is intended to be used when comparing the performance of an untrainable algorithm (e.g. a COTS algorithm) against a trainable algorithm that was trained using cross-validation. All templates with the allPartitions flag will be compared against for every partition. As untrainable algorithms will have no use for the CrossValidateTransform, this flag is only meaningful at comparison time (but care has been taken so that one can train and enroll without issue if these  File s are present in the used  Gallery ).    duplicatePartitions  This flag is similar to allPartitions in that it causes the same template to be used during comparison for every partition. The difference is that duplicatePartitions will duplicate each marked template and project it into the model space constituded by the child transforms of CrossValidateTransform. Again, care has been take such that one can train with these templates in the used  Gallery  successfully (they will simply be omitted).     To use an extended  Gallery , add an allPartitions=\"true\" flag to the gallery sigset for those images that should be compared\nagainst for all testing partitions.   file:  core/crossvalidate.cpp  inherits:   MetaTransform  author(s):   Josh Klontz ,  Scott Klum  properties:  None", 
            "title": "CrossValidateTransform"
        }, 
        {
            "location": "/plugin_docs/core/#directstreamtransform", 
            "text": "DOCUMENT ME CHARLES   file:  core/stream.cpp  inherits:   CompositeTransform  author(s):   Charles Otto  properties:  None", 
            "title": "DirectStreamTransform"
        }, 
        {
            "location": "/plugin_docs/core/#discardtemplatestransform", 
            "text": "DOCUMENT ME   file:  core/discardtemplates.cpp  inherits:   UntrainableMetaTransform  author(s):   Unknown  properties:  None", 
            "title": "DiscardTemplatesTransform"
        }, 
        {
            "location": "/plugin_docs/core/#discardtransform", 
            "text": "Removes all matrices from a  Template .   file:  core/discard.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "DiscardTransform"
        }, 
        {
            "location": "/plugin_docs/core/#distributetemplatetransform", 
            "text": "DOCUMENT ME CHARLES   file:  core/distributetemplate.cpp  inherits:   MetaTransform  author(s):   Unknown  properties:  None", 
            "title": "DistributeTemplateTransform"
        }, 
        {
            "location": "/plugin_docs/core/#downsampletrainingtransform", 
            "text": "DOCUMENT ME JOSH   file:  core/downsampletraining.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "DownsampleTrainingTransform"
        }, 
        {
            "location": "/plugin_docs/core/#eventtransform", 
            "text": "DOCUMENT ME   file:  core/event.cpp  inherits:   UntrainableMetaTransform  author(s):   Unknown  properties:  None", 
            "title": "EventTransform"
        }, 
        {
            "location": "/plugin_docs/core/#expandtransform", 
            "text": "Performs an expansion step on an input  TemplateList . Each matrix in each input  Template  is expanded into its own  Template .   file:  core/expand.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "ExpandTransform"
        }, 
        {
            "location": "/plugin_docs/core/#ftetransform", 
            "text": "Flags images that failed to enroll based on the specified  Transform .   file:  core/fte.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "FTETransform"
        }, 
        {
            "location": "/plugin_docs/core/#firsttransform", 
            "text": "Removes all but the first matrix from the  Template .   file:  core/first.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "FirstTransform"
        }, 
        {
            "location": "/plugin_docs/core/#forktransform", 
            "text": "Transforms in parallel.  The source  Template  is seperately given to each transform and the results are appended together.   file:  core/fork.cpp  inherits:   CompositeTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "ForkTransform"
        }, 
        {
            "location": "/plugin_docs/core/#gallerycomparetransform", 
            "text": "Compare each  Template  to a fixed  Gallery  (with name = galleryName), using the specified distance.\ndst will contain a 1 by n vector of scores.   file:  core/gallerycompare.cpp  inherits:   Transform  author(s):   Charles Otto  properties:  None", 
            "title": "GalleryCompareTransform"
        }, 
        {
            "location": "/plugin_docs/core/#identitytransform", 
            "text": "A no-op  Transform .   file:  core/identity.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "IdentityTransform"
        }, 
        {
            "location": "/plugin_docs/core/#independenttransform", 
            "text": "Clones the  Transform  so that it can be applied independently.  Independent  Transform s expect single-matrix  Template .   file:  core/independent.cpp  inherits:   MetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "IndependentTransform"
        }, 
        {
            "location": "/plugin_docs/core/#jnitransform", 
            "text": "Execute Java code from OpenBR using the JNI   file:  core/jni.cpp  inherits:   UntrainableTransform  author(s):   Jordan Cheney  properties:  None", 
            "title": "JNITransform"
        }, 
        {
            "location": "/plugin_docs/core/#likelytransform", 
            "text": "Generic interface to Likely JIT compiler   file:  core/likely.cpp  inherits:   Transform  author(s):   Josh Klontz   see:   Homepage  API Documentation     properties:  None", 
            "title": "LikelyTransform"
        }, 
        {
            "location": "/plugin_docs/core/#loadstoretransform", 
            "text": "Caches  Transform  training.   file:  core/loadstore.cpp  inherits:   MetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "LoadStoreTransform"
        }, 
        {
            "location": "/plugin_docs/core/#pipetransform", 
            "text": "Transforms in series.  The source  Template  is given to the first transform and the resulting  Template  is passed to the next transform, etc.   file:  core/pipe.cpp  inherits:   CompositeTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "PipeTransform"
        }, 
        {
            "location": "/plugin_docs/core/#processwrappertransform", 
            "text": "Interface to a separate process   file:  core/processwrapper.cpp  inherits:   WrapperTransform  author(s):   Charles Otto  properties:  None", 
            "title": "ProcessWrapperTransform"
        }, 
        {
            "location": "/plugin_docs/core/#progresscountertransform", 
            "text": "DOCUMENT ME CHARLES   file:  core/progresscounter.cpp  inherits:   TimeVaryingTransform  author(s):   Unknown  properties:  None", 
            "title": "ProgressCounterTransform"
        }, 
        {
            "location": "/plugin_docs/core/#propagatetransform", 
            "text": "Ensures that a template will be propogated.   file:  core/propagate.cpp  inherits:   UntrainableMetaTransform  author(s):   Scott Klum  properties:  None", 
            "title": "PropagateTransform"
        }, 
        {
            "location": "/plugin_docs/core/#removetransform", 
            "text": "Removes the matrix from the  Template  at the specified index.   file:  core/remove.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RemoveTransform"
        }, 
        {
            "location": "/plugin_docs/core/#resttransform", 
            "text": "Removes the first matrix from the  Template .   file:  core/rest.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RestTransform"
        }, 
        {
            "location": "/plugin_docs/core/#schrodingertransform", 
            "text": "Generates two  Template , one of which is passed through a  Transform  and the other\nis not. No cats were harmed in the making of this  Transform .   file:  core/schrodinger.cpp  inherits:   MetaTransform  author(s):   Scott Klum  properties:  None", 
            "title": "SchrodingerTransform"
        }, 
        {
            "location": "/plugin_docs/core/#singletontransform", 
            "text": "A globally shared  Transform .   file:  core/singleton.cpp  inherits:   MetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "SingletonTransform"
        }, 
        {
            "location": "/plugin_docs/core/#streamtransform", 
            "text": "DOCUMENT ME CHARLES   file:  core/stream.cpp  inherits:   WrapperTransform  author(s):   Charles Otto  properties:  None", 
            "title": "StreamTransform"
        }, 
        {
            "location": "/plugin_docs/distance/", 
            "text": "AttributeDistance\n\n\nAttenuation function based distance from attributes\n\n\n\n\nfile:\n distance/attribute.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nBayesianQuantizationDistance\n\n\nBayesian quantization \nDistance\n\n\n\n\nfile:\n distance/bayesianquantization.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nByteL1Distance\n\n\nFast 8-bit L1 distance\n\n\n\n\nfile:\n distance/byteL1.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCrossValidateDistance\n\n\nCross validate a \nDistance\n metric.\n\n\n\n\nfile:\n distance/crossvalidate.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDefaultDistance\n\n\nDistDistance wrapper.\n\n\n\n\nfile:\n distance/default.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDistDistance\n\n\nStandard \nDistance\n metrics\n\n\n\n\nfile:\n distance/dist.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nEMDDistance\n\n\nComputes Earth Mover's \nDistance\n\n https://www.cs.duke.edu/~tomasi/papers/rubner/rubnerTr98.pdf\n\n\n\n\nfile:\n distance/emd.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nFilterDistance\n\n\nChecks target metadata against filters.\n\n\n\n\nfile:\n distance/filter.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nFuseDistance\n\n\nFuses similarity scores across multiple matrices of compared \nTemplate\n\n\n\n\nfile:\n distance/fuse.cpp\n\n\ninherits:\n \nListDistance\n\n\nauthor(s):\n \nScott Klum\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nenum\n\n\nPossible values are:\nMean\nsum\nmin\nmax\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHalfByteL1Distance\n\n\nFast 4-bit L1 distance\n\n\n\n\nfile:\n distance/halfbyteL1.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nHeatMapDistance\n\n\n1v1 heat map comparison\n\n\n\n\nfile:\n distance/heatmap.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nIdenticalDistance\n\n\nReturns true if the \nTemplate\n are identical, false otherwise.\n\n\n\n\nfile:\n distance/identical.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nKeyPointMatcherDistance\n\n\nWraps OpenCV Key Point Matcher\n\n\n\n\nfile:\n distance/keypointmatcher.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nL1Distance\n\n\nL1 distance computed using eigen.\n\n\n\n\nfile:\n distance/L1.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nL2Distance\n\n\nL2 distance computed using eigen.\n\n\n\n\nfile:\n distance/L2.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nMatchProbabilityDistance\n\n\nMatch Probability\n\n\n\n\nfile:\n distance/matchprobability.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nMetadataDistance\n\n\nChecks target metadata against query metadata.\n\n\n\n\nfile:\n distance/metadata.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nNegativeLogPlusOneDistance\n\n\nReturns -log(distance(a,b)+1)\n\n\n\n\nfile:\n distance/neglogplusone.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nOnlineDistance\n\n\nOnline \nDistance\n metric to attenuate match scores across multiple frames\n\n\n\n\nfile:\n distance/online.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nBrendan klare\n\n\nproperties:\n None\n\n\n\n\n\n\nPermuteDistance\n\n\nCompares all permutations of matrices from one template to the other, and fuses the scores via the operation specified.\n\n\n\n\nfile:\n distance/permute.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nPipeDistance\n\n\nDistances in series.\n\n\nThe \nTemplate\n are compared using each \nDistance\n in order.\nIf the result of the comparison with any given distance is -FLOAT_MAX then this result is returned early.\nOtherwise the returned result is the value of comparing the \nTemplate\n using the last \nDistance\n.\n\n\n\n\nfile:\n distance/pipe.cpp\n\n\ninherits:\n \nListDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRejectDistance\n\n\nSets \nDistance\n to -FLOAT_MAX if a target \nTemplate\n has/doesn't have a key.\n\n\n\n\nfile:\n distance/reject.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nSVMDistance\n\n\nSVM Regression on \nTemplate\n absolute differences.\n\n\n\n\nfile:\n distance/svm.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nSumDistance\n\n\nSum match scores across multiple \nDistance\n\n\n\n\nfile:\n distance/sum.cpp\n\n\ninherits:\n \nListDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nThresholdDistance\n\n\nApplys a hard threshold to similarity values.\n\n\n\n\nfile:\n distance/threshold.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nTurkDistance\n\n\nUnmaps Turk HITs to be compared against query mats\n\n\n\n\nfile:\n distance/turk.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nUnitDistance\n\n\nLinear normalizes of a \nDistance\n so the mean impostor score is 0 and the mean genuine score is 1.\n\n\n\n\nfile:\n distance/unit.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nZScoreDistance\n\n\nPerforms zscore normalization on distances at test time by learning mean\nand standard deviation parameters during training.\n\n\n\n\nfile:\n distance/zscore.cpp\n\n\ninherits:\n \nDistance\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None", 
            "title": "Distance"
        }, 
        {
            "location": "/plugin_docs/distance/#attributedistance", 
            "text": "Attenuation function based distance from attributes   file:  distance/attribute.cpp  inherits:   UntrainableDistance  author(s):   Scott Klum  properties:  None", 
            "title": "AttributeDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#bayesianquantizationdistance", 
            "text": "Bayesian quantization  Distance   file:  distance/bayesianquantization.cpp  inherits:   Distance  author(s):   Josh Klontz  properties:  None", 
            "title": "BayesianQuantizationDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#bytel1distance", 
            "text": "Fast 8-bit L1 distance   file:  distance/byteL1.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "ByteL1Distance"
        }, 
        {
            "location": "/plugin_docs/distance/#crossvalidatedistance", 
            "text": "Cross validate a  Distance  metric.   file:  distance/crossvalidate.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "CrossValidateDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#defaultdistance", 
            "text": "DistDistance wrapper.   file:  distance/default.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "DefaultDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#distdistance", 
            "text": "Standard  Distance  metrics   file:  distance/dist.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "DistDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#emddistance", 
            "text": "Computes Earth Mover's  Distance \n https://www.cs.duke.edu/~tomasi/papers/rubner/rubnerTr98.pdf   file:  distance/emd.cpp  inherits:   UntrainableDistance  author(s):   Scott Klum  properties:  None", 
            "title": "EMDDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#filterdistance", 
            "text": "Checks target metadata against filters.   file:  distance/filter.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "FilterDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#fusedistance", 
            "text": "Fuses similarity scores across multiple matrices of compared  Template   file:  distance/fuse.cpp  inherits:   ListDistance  author(s):   Scott Klum   properties:     Property  Type  Description      Operation  enum  Possible values are: Mean sum min max .", 
            "title": "FuseDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#halfbytel1distance", 
            "text": "Fast 4-bit L1 distance   file:  distance/halfbyteL1.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "HalfByteL1Distance"
        }, 
        {
            "location": "/plugin_docs/distance/#heatmapdistance", 
            "text": "1v1 heat map comparison   file:  distance/heatmap.cpp  inherits:   Distance  author(s):   Scott Klum  properties:  None", 
            "title": "HeatMapDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#identicaldistance", 
            "text": "Returns true if the  Template  are identical, false otherwise.   file:  distance/identical.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "IdenticalDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#keypointmatcherdistance", 
            "text": "Wraps OpenCV Key Point Matcher   file:  distance/keypointmatcher.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "KeyPointMatcherDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#l1distance", 
            "text": "L1 distance computed using eigen.   file:  distance/L1.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "L1Distance"
        }, 
        {
            "location": "/plugin_docs/distance/#l2distance", 
            "text": "L2 distance computed using eigen.   file:  distance/L2.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "L2Distance"
        }, 
        {
            "location": "/plugin_docs/distance/#matchprobabilitydistance", 
            "text": "Match Probability   file:  distance/matchprobability.cpp  inherits:   Distance  author(s):   Josh Klontz  properties:  None", 
            "title": "MatchProbabilityDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#metadatadistance", 
            "text": "Checks target metadata against query metadata.   file:  distance/metadata.cpp  inherits:   UntrainableDistance  author(s):   Scott Klum  properties:  None", 
            "title": "MetadataDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#negativelogplusonedistance", 
            "text": "Returns -log(distance(a,b)+1)   file:  distance/neglogplusone.cpp  inherits:   Distance  author(s):   Josh Klontz  properties:  None", 
            "title": "NegativeLogPlusOneDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#onlinedistance", 
            "text": "Online  Distance  metric to attenuate match scores across multiple frames   file:  distance/online.cpp  inherits:   UntrainableDistance  author(s):   Brendan klare  properties:  None", 
            "title": "OnlineDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#permutedistance", 
            "text": "Compares all permutations of matrices from one template to the other, and fuses the scores via the operation specified.   file:  distance/permute.cpp  inherits:   Distance  author(s):   Scott Klum  properties:  None", 
            "title": "PermuteDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#pipedistance", 
            "text": "Distances in series.  The  Template  are compared using each  Distance  in order.\nIf the result of the comparison with any given distance is -FLOAT_MAX then this result is returned early.\nOtherwise the returned result is the value of comparing the  Template  using the last  Distance .   file:  distance/pipe.cpp  inherits:   ListDistance  author(s):   Josh Klontz  properties:  None", 
            "title": "PipeDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#rejectdistance", 
            "text": "Sets  Distance  to -FLOAT_MAX if a target  Template  has/doesn't have a key.   file:  distance/reject.cpp  inherits:   UntrainableDistance  author(s):   Scott Klum  properties:  None", 
            "title": "RejectDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#svmdistance", 
            "text": "SVM Regression on  Template  absolute differences.   file:  distance/svm.cpp  inherits:   Distance  author(s):   Josh Klontz  properties:  None", 
            "title": "SVMDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#sumdistance", 
            "text": "Sum match scores across multiple  Distance   file:  distance/sum.cpp  inherits:   ListDistance  author(s):   Scott Klum  properties:  None", 
            "title": "SumDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#thresholddistance", 
            "text": "Applys a hard threshold to similarity values.   file:  distance/threshold.cpp  inherits:   Distance  author(s):   Scott Klum  properties:  None", 
            "title": "ThresholdDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#turkdistance", 
            "text": "Unmaps Turk HITs to be compared against query mats   file:  distance/turk.cpp  inherits:   UntrainableDistance  author(s):   Scott Klum  properties:  None", 
            "title": "TurkDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#unitdistance", 
            "text": "Linear normalizes of a  Distance  so the mean impostor score is 0 and the mean genuine score is 1.   file:  distance/unit.cpp  inherits:   Distance  author(s):   Josh Klontz  properties:  None", 
            "title": "UnitDistance"
        }, 
        {
            "location": "/plugin_docs/distance/#zscoredistance", 
            "text": "Performs zscore normalization on distances at test time by learning mean\nand standard deviation parameters during training.   file:  distance/zscore.cpp  inherits:   Distance  author(s):   Scott Klum  properties:  None", 
            "title": "ZScoreDistance"
        }, 
        {
            "location": "/plugin_docs/format/", 
            "text": "DefaultFormat\n\n\nReads image files.\n\n\n\n\nfile:\n format/video.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nbinaryFormat\n\n\nA simple binary matrix format.\n\n\n\n\nfile:\n format/binary.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nformat:\n First 4 bytes indicate the number of rows. Second 4 bytes indicate the number of columns. The rest of the bytes are 32-bit floating data elements in row-major order. \n\n\nproperties:\n None\n\n\n\n\n\n\ncsvFormat\n\n\nReads a comma separated value file.\n\n\n\n\nfile:\n format/csv.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nebtsFormat\n\n\nReads FBI EBTS transactions.\n\n\n\n\nfile:\n format/ebts.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nScott Klum\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nlffsFormat\n\n\nReads a NIST LFFS file.\n\n\n\n\nfile:\n format/lffs.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nlmFormat\n\n\nLikely matrix format\n\n\n\n\nfile:\n format/lm.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nmaskFormat\n\n\nReads a NIST BEE mask matrix.\n\n\n\n\nfile:\n format/mtx.cpp\n\n\ninherits:\n \nmtxFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nmatFormat\n\n\nMATLAB \n.mat\n format.\n\n\nmatFormat is known not to work with compressed matrices\n\n\n\n\nfile:\n format/mat.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nmtxFormat\n\n\nReads a NIST BEE similarity matrix.\n\n\n\n\nfile:\n format/mtx.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nnullFormat\n\n\nReturns an empty matrix.\n\n\n\n\nfile:\n format/null.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\npostFormat\n\n\nHandle POST requests\n\n\n\n\nfile:\n format/post.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nrawFormat\n\n\nRAW format\n\n\n\n\nfile:\n format/raw.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nscoresFormat\n\n\nReads in scores or ground truth from a text table.\n\n\n\n\nfile:\n format/scores.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nformat:\n Example of the format: \n2.2531514    FALSE   99990377    99990164\n2.2549822    TRUE    99990101    99990101\n\n\n\nproperties:\n None\n\n\n\n\n\n\nurlFormat\n\n\nReads image files from the web.\n\n\n\n\nfile:\n format/url.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nvideoFormat\n\n\nRead all frames of a video using OpenCV\n\n\n\n\nfile:\n format/video.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nwebcamFormat\n\n\nRetrieves an image from a webcam.\n\n\n\n\nfile:\n format/video.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nxmlFormat\n\n\nDecodes images from Base64 xml\n\n\n\n\nfile:\n format/xml.cpp\n\n\ninherits:\n \nFormat\n\n\nauthor(s):\n \nScott Klum\n, \nJosh Klontz\n\n\nproperties:\n None", 
            "title": "Format"
        }, 
        {
            "location": "/plugin_docs/format/#defaultformat", 
            "text": "Reads image files.   file:  format/video.cpp  inherits:   Format  author(s):   Josh Klontz  properties:  None", 
            "title": "DefaultFormat"
        }, 
        {
            "location": "/plugin_docs/format/#binaryformat", 
            "text": "A simple binary matrix format.   file:  format/binary.cpp  inherits:   Format  author(s):   Josh Klontz  format:  First 4 bytes indicate the number of rows. Second 4 bytes indicate the number of columns. The rest of the bytes are 32-bit floating data elements in row-major order.   properties:  None", 
            "title": "binaryFormat"
        }, 
        {
            "location": "/plugin_docs/format/#csvformat", 
            "text": "Reads a comma separated value file.   file:  format/csv.cpp  inherits:   Format  author(s):   Josh Klontz  properties:  None", 
            "title": "csvFormat"
        }, 
        {
            "location": "/plugin_docs/format/#ebtsformat", 
            "text": "Reads FBI EBTS transactions.   file:  format/ebts.cpp  inherits:   Format  author(s):   Scott Klum  see:    properties:  None", 
            "title": "ebtsFormat"
        }, 
        {
            "location": "/plugin_docs/format/#lffsformat", 
            "text": "Reads a NIST LFFS file.   file:  format/lffs.cpp  inherits:   Format  author(s):   Josh Klontz  properties:  None", 
            "title": "lffsFormat"
        }, 
        {
            "location": "/plugin_docs/format/#lmformat", 
            "text": "Likely matrix format   file:  format/lm.cpp  inherits:   Format  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "lmFormat"
        }, 
        {
            "location": "/plugin_docs/format/#maskformat", 
            "text": "Reads a NIST BEE mask matrix.   file:  format/mtx.cpp  inherits:   mtxFormat  author(s):   Josh Klontz  properties:  None", 
            "title": "maskFormat"
        }, 
        {
            "location": "/plugin_docs/format/#matformat", 
            "text": "MATLAB  .mat  format.  matFormat is known not to work with compressed matrices   file:  format/mat.cpp  inherits:   Format  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "matFormat"
        }, 
        {
            "location": "/plugin_docs/format/#mtxformat", 
            "text": "Reads a NIST BEE similarity matrix.   file:  format/mtx.cpp  inherits:   Format  author(s):   Josh Klontz  properties:  None", 
            "title": "mtxFormat"
        }, 
        {
            "location": "/plugin_docs/format/#nullformat", 
            "text": "Returns an empty matrix.   file:  format/null.cpp  inherits:   Format  author(s):   Josh Klontz  properties:  None", 
            "title": "nullFormat"
        }, 
        {
            "location": "/plugin_docs/format/#postformat", 
            "text": "Handle POST requests   file:  format/post.cpp  inherits:   Format  author(s):   Josh Klontz  properties:  None", 
            "title": "postFormat"
        }, 
        {
            "location": "/plugin_docs/format/#rawformat", 
            "text": "RAW format   file:  format/raw.cpp  inherits:   Format  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "rawFormat"
        }, 
        {
            "location": "/plugin_docs/format/#scoresformat", 
            "text": "Reads in scores or ground truth from a text table.   file:  format/scores.cpp  inherits:   Format  author(s):   Josh Klontz  format:  Example of the format:  2.2531514    FALSE   99990377    99990164\n2.2549822    TRUE    99990101    99990101  properties:  None", 
            "title": "scoresFormat"
        }, 
        {
            "location": "/plugin_docs/format/#urlformat", 
            "text": "Reads image files from the web.   file:  format/url.cpp  inherits:   Format  author(s):   Josh Klontz  properties:  None", 
            "title": "urlFormat"
        }, 
        {
            "location": "/plugin_docs/format/#videoformat", 
            "text": "Read all frames of a video using OpenCV   file:  format/video.cpp  inherits:   Format  author(s):   Charles Otto  properties:  None", 
            "title": "videoFormat"
        }, 
        {
            "location": "/plugin_docs/format/#webcamformat", 
            "text": "Retrieves an image from a webcam.   file:  format/video.cpp  inherits:   Format  author(s):   Josh Klontz  properties:  None", 
            "title": "webcamFormat"
        }, 
        {
            "location": "/plugin_docs/format/#xmlformat", 
            "text": "Decodes images from Base64 xml   file:  format/xml.cpp  inherits:   Format  author(s):   Scott Klum ,  Josh Klontz  properties:  None", 
            "title": "xmlFormat"
        }, 
        {
            "location": "/plugin_docs/gallery/", 
            "text": "BinaryGallery\n\n\nAn abstract gallery for handling binary data\n\n\n\n\nfile:\n gallery/binary.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDefaultGallery\n\n\nTreats the gallery as a \nFormat\n.\n\n\n\n\nfile:\n gallery/default.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nEmptyGallery\n\n\nReads/writes templates to/from folders.\n\n\n\n\nfile:\n gallery/empty.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nregexp\n\n\nQString\n\n\nAn optional regular expression to match against the files extension.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFDDBGallery\n\n\nImplements the FDDB detection format.\n\n\n\n\nfile:\n gallery/fddb.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\narffGallery\n\n\nWeka ARFF file format.\n\n\n\n\nfile:\n gallery/arff.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\naviGallery\n\n\nRead videos of format .avi\n\n\n\n\nfile:\n gallery/video.cpp\n\n\ninherits:\n \nvideoGallery\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\ncrawlGallery\n\n\nCrawl a root location for image files.\n\n\n\n\nfile:\n gallery/crawl.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\ncsvGallery\n\n\nTreats each line as a file.\n\n\n\n\nfile:\n gallery/csv.cpp\n\n\ninherits:\n \nFileGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nformat:\n Columns should be comma separated with first row containing headers. The first column in the file should be the path to the file to enroll. Other columns will be treated as file metadata. \n\n\nproperties:\n None\n\n\n\n\n\n\ndbGallery\n\n\nDatabase input.\n\n\n\n\nfile:\n gallery/db.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nflatGallery\n\n\nTreats each line as a call to \nFile\n::flat()\n\n\n\n\nfile:\n gallery/flat.cpp\n\n\ninherits:\n \nFileGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\ngalGallery\n\n\nA binary gallery.\n\n\nDesigned to be a literal translation of templates to disk.\nCompatible with \nTemplateList\n::fromBuffer.\n\n\n\n\nfile:\n gallery/binary.cpp\n\n\ninherits:\n \nBinaryGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\ngoogleGallery\n\n\nInput from a google image search.\n\n\n\n\nfile:\n gallery/google.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\njsonGallery\n\n\nNewline-separated JSON objects.\n\n\n\n\nfile:\n gallery/binary.cpp\n\n\ninherits:\n \nBinaryGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nkeyframesGallery\n\n\nRead key frames of a video with LibAV\n\n\n\n\nfile:\n gallery/keyframes.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n [Ben Klein][bhklein]\n\n\nproperties:\n None\n\n\n\n\n\n\nlandmarksGallery\n\n\nText format for associating anonymous landmarks with images.\n\n\n\n\nfile:\n gallery/landmarks.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nformat:\n The input should be formatted as follows: \nfile_name:x1,y1,x2,y2,...,xn,yn\nfile_name:x1,y1,x2,y2,...,xn,yn\n...\nfile_name:x1,y1,x2,y2,...,xn,yn\n\n\n\nproperties:\n None\n\n\n\n\n\n\nlmGallery\n\n\nLikely matrix format\n\n\nwww.liblikely.org\n\n\n\n\nfile:\n gallery/lm.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nmatrixGallery\n\n\nCombine all \nTemplate\n into one large matrix and process it as a \nFormat\n\n\n\n\nfile:\n gallery/matrix.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nmemGallery\n\n\nA gallery held in memory.\n\n\n\n\nfile:\n gallery/mem.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nmp4Gallery\n\n\nRead key frames of a .mp4 video file with LibAV\n\n\n\n\nfile:\n gallery/keyframes.cpp\n\n\ninherits:\n \nkeyframesGallery\n\n\nauthor(s):\n [Ben Klein][bhklein]\n\n\nproperties:\n None\n\n\n\n\n\n\npostGallery\n\n\nHandle POST requests\n\n\n\n\nfile:\n gallery/post.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nseqGallery\n\n\nDOCUMENT ME\n\n\n\n\nfile:\n gallery/seq.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nstatGallery\n\n\nPrint \nTemplate\n statistics.\n\n\n\n\nfile:\n gallery/stat.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\ntemplateGallery\n\n\nTreat the file as a single binary \nTemplate\n.\n\n\n\n\nfile:\n gallery/template.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nturkGallery\n\n\nFor Amazon Mechanical Turk datasets\n\n\n\n\nfile:\n gallery/turk.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\ntxtGallery\n\n\nTreats each line as a file.\n\n\n\n\nfile:\n gallery/txt.cpp\n\n\ninherits:\n \nFileGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nformat:\n The entire line is treated as the file path. \nFILE\n\n\nFILE\n\n...\n\nFILE\n\n\nAn optional label may be specified using a space ' ' separator: \nFILE\n \nLABEL\n\n\nFILE\n \nLABEL\n\n...\n\nFILE\n \nLABEL\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\nurlGallery\n\n\nNewline-separated URLs.\n\n\n\n\nfile:\n gallery/binary.cpp\n\n\ninherits:\n \nBinaryGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nutGallery\n\n\nA contiguous array of br_universal_template.\n\n\n\n\nfile:\n gallery/binary.cpp\n\n\ninherits:\n \nBinaryGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nvbbGallery\n\n\nDOCUMENT ME\n\n\n\n\nfile:\n gallery/vbb.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nvideoGallery\n\n\nRead a video frame by frame using cv::VideoCapture\n\n\n\n\nfile:\n gallery/video.cpp\n\n\ninherits:\n \nGallery\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nwebcamGallery\n\n\nRead a video from the webcam\n\n\n\n\nfile:\n gallery/video.cpp\n\n\ninherits:\n \nvideoGallery\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nwmvGallery\n\n\nRead videos of format .wmv\n\n\n\n\nfile:\n gallery/video.cpp\n\n\ninherits:\n \nvideoGallery\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nxmlGallery\n\n\nA sigset input.\n\n\n\n\nfile:\n gallery/xml.cpp\n\n\ninherits:\n \nFileGallery\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None", 
            "title": "Gallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#binarygallery", 
            "text": "An abstract gallery for handling binary data   file:  gallery/binary.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "BinaryGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#defaultgallery", 
            "text": "Treats the gallery as a  Format .   file:  gallery/default.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "DefaultGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#emptygallery", 
            "text": "Reads/writes templates to/from folders.   file:  gallery/empty.cpp  inherits:   Gallery  author(s):   Josh Klontz   properties:     Property  Type  Description      regexp  QString  An optional regular expression to match against the files extension.", 
            "title": "EmptyGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#fddbgallery", 
            "text": "Implements the FDDB detection format.   file:  gallery/fddb.cpp  inherits:   Gallery  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "FDDBGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#arffgallery", 
            "text": "Weka ARFF file format.   file:  gallery/arff.cpp  inherits:   Gallery  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "arffGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#avigallery", 
            "text": "Read videos of format .avi   file:  gallery/video.cpp  inherits:   videoGallery  author(s):   Unknown  properties:  None", 
            "title": "aviGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#crawlgallery", 
            "text": "Crawl a root location for image files.   file:  gallery/crawl.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "crawlGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#csvgallery", 
            "text": "Treats each line as a file.   file:  gallery/csv.cpp  inherits:   FileGallery  author(s):   Josh Klontz  format:  Columns should be comma separated with first row containing headers. The first column in the file should be the path to the file to enroll. Other columns will be treated as file metadata.   properties:  None", 
            "title": "csvGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#dbgallery", 
            "text": "Database input.   file:  gallery/db.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "dbGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#flatgallery", 
            "text": "Treats each line as a call to  File ::flat()   file:  gallery/flat.cpp  inherits:   FileGallery  author(s):   Josh Klontz  properties:  None", 
            "title": "flatGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#galgallery", 
            "text": "A binary gallery.  Designed to be a literal translation of templates to disk.\nCompatible with  TemplateList ::fromBuffer.   file:  gallery/binary.cpp  inherits:   BinaryGallery  author(s):   Josh Klontz  properties:  None", 
            "title": "galGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#googlegallery", 
            "text": "Input from a google image search.   file:  gallery/google.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "googleGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#jsongallery", 
            "text": "Newline-separated JSON objects.   file:  gallery/binary.cpp  inherits:   BinaryGallery  author(s):   Josh Klontz  properties:  None", 
            "title": "jsonGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#keyframesgallery", 
            "text": "Read key frames of a video with LibAV   file:  gallery/keyframes.cpp  inherits:   Gallery  author(s):  [Ben Klein][bhklein]  properties:  None", 
            "title": "keyframesGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#landmarksgallery", 
            "text": "Text format for associating anonymous landmarks with images.   file:  gallery/landmarks.cpp  inherits:   Gallery  author(s):   Josh Klontz  format:  The input should be formatted as follows:  file_name:x1,y1,x2,y2,...,xn,yn\nfile_name:x1,y1,x2,y2,...,xn,yn\n...\nfile_name:x1,y1,x2,y2,...,xn,yn  properties:  None", 
            "title": "landmarksGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#lmgallery", 
            "text": "Likely matrix format  www.liblikely.org   file:  gallery/lm.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "lmGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#matrixgallery", 
            "text": "Combine all  Template  into one large matrix and process it as a  Format   file:  gallery/matrix.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "matrixGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#memgallery", 
            "text": "A gallery held in memory.   file:  gallery/mem.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "memGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#mp4gallery", 
            "text": "Read key frames of a .mp4 video file with LibAV   file:  gallery/keyframes.cpp  inherits:   keyframesGallery  author(s):  [Ben Klein][bhklein]  properties:  None", 
            "title": "mp4Gallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#postgallery", 
            "text": "Handle POST requests   file:  gallery/post.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "postGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#seqgallery", 
            "text": "DOCUMENT ME   file:  gallery/seq.cpp  inherits:   Gallery  author(s):   Unknown  properties:  None", 
            "title": "seqGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#statgallery", 
            "text": "Print  Template  statistics.   file:  gallery/stat.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "statGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#templategallery", 
            "text": "Treat the file as a single binary  Template .   file:  gallery/template.cpp  inherits:   Gallery  author(s):   Josh Klontz  properties:  None", 
            "title": "templateGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#turkgallery", 
            "text": "For Amazon Mechanical Turk datasets   file:  gallery/turk.cpp  inherits:   Gallery  author(s):   Scott Klum  properties:  None", 
            "title": "turkGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#txtgallery", 
            "text": "Treats each line as a file.   file:  gallery/txt.cpp  inherits:   FileGallery  author(s):   Josh Klontz  format:  The entire line is treated as the file path.  FILE  FILE \n... FILE  An optional label may be specified using a space ' ' separator:  FILE   LABEL  FILE   LABEL \n... FILE   LABEL   properties:  None", 
            "title": "txtGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#urlgallery", 
            "text": "Newline-separated URLs.   file:  gallery/binary.cpp  inherits:   BinaryGallery  author(s):   Josh Klontz  properties:  None", 
            "title": "urlGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#utgallery", 
            "text": "A contiguous array of br_universal_template.   file:  gallery/binary.cpp  inherits:   BinaryGallery  author(s):   Josh Klontz  properties:  None", 
            "title": "utGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#vbbgallery", 
            "text": "DOCUMENT ME   file:  gallery/vbb.cpp  inherits:   Gallery  author(s):   Unknown  properties:  None", 
            "title": "vbbGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#videogallery", 
            "text": "Read a video frame by frame using cv::VideoCapture   file:  gallery/video.cpp  inherits:   Gallery  author(s):   Unknown  properties:  None", 
            "title": "videoGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#webcamgallery", 
            "text": "Read a video from the webcam   file:  gallery/video.cpp  inherits:   videoGallery  author(s):   Unknown  properties:  None", 
            "title": "webcamGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#wmvgallery", 
            "text": "Read videos of format .wmv   file:  gallery/video.cpp  inherits:   videoGallery  author(s):   Unknown  properties:  None", 
            "title": "wmvGallery"
        }, 
        {
            "location": "/plugin_docs/gallery/#xmlgallery", 
            "text": "A sigset input.   file:  gallery/xml.cpp  inherits:   FileGallery  author(s):   Josh Klontz  properties:  None", 
            "title": "xmlGallery"
        }, 
        {
            "location": "/plugin_docs/gui/", 
            "text": "AdjacentOverlayTransform\n\n\nLoad the image named in the specified property, draw it on the current matrix adjacent to the rect specified in the other property.\n\n\n\n\nfile:\n gui/adjacentoverlay.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nDrawDelaunayTransform\n\n\nCreates a Delaunay triangulation based on a set of points\n\n\n\n\nfile:\n gui/drawdelaunay.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nDrawGridLinesTransform\n\n\nDraws a grid on the image\n\n\n\n\nfile:\n gui/drawgridlines.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDrawOpticalFlow\n\n\nDraw a line representing the direction and magnitude of optical flow at the specified points.\n\n\n\n\nfile:\n gui/drawopticalflow.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None\n\n\n\n\n\n\nDrawPropertiesPointTransform\n\n\nDraw the values of a list of properties at the specified point on the image\n\n\nThe inPlace argument controls whether or not the image is cloned before it is drawn on.\n\n\n\n\nfile:\n gui/drawpropertiespoint.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nDrawPropertyPointTransform\n\n\nDraw the value of the specified property at the specified point on the image\n\n\nThe inPlace argument controls whether or not the image is cloned before it is drawn on.\n\n\n\n\nfile:\n gui/drawpropertypoint.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nDrawSegmentation\n\n\nFill in the segmentations or draw a line between intersecting segments.\n\n\n\n\nfile:\n gui/drawsegmentation.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None\n\n\n\n\n\n\nDrawTransform\n\n\nRenders metadata onto the image.\n\n\nThe inPlace argument controls whether or not the image is cloned before the metadata is drawn.\n\n\n\n\nfile:\n gui/draw.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nElicitTransform\n\n\nElicits metadata for templates in a pretty GUI\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nShowTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nFPSCalc\n\n\nCalculates the average FPS of projects going through this transform, stores the result in AvgFPS\nReports an average FPS from the initialization of this transform onwards.\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nFPSLimit\n\n\nLimits the frequency of projects going through this transform to the input targetFPS\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nFilterTransform\n\n\nDOCUMENT ME\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nShowTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nManualRectsTransform\n\n\nManual select rectangular regions on an image.\nStores marked rectangles as anonymous rectangles, or if a set of labels is provided, prompt the user\nto select one of those labels after drawing each rectangle.\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nShowTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nManualTransform\n\n\nManual selection of landmark locations\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nShowTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nShowTrainingTransform\n\n\nShow the training data\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nShowTransform\n\n\nDisplays templates in a GUI pop-up window using QT.\n\n\nCan be used with parallelism enabled, although it is considered TimeVarying.\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nSurveyTransform\n\n\nDisplay an image, and asks a yes/no question about it\n\n\n\n\nfile:\n gui/show.cpp\n\n\ninherits:\n \nShowTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None", 
            "title": "GUI"
        }, 
        {
            "location": "/plugin_docs/gui/#adjacentoverlaytransform", 
            "text": "Load the image named in the specified property, draw it on the current matrix adjacent to the rect specified in the other property.   file:  gui/adjacentoverlay.cpp  inherits:   Transform  author(s):   Charles Otto  properties:  None", 
            "title": "AdjacentOverlayTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#drawdelaunaytransform", 
            "text": "Creates a Delaunay triangulation based on a set of points   file:  gui/drawdelaunay.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "DrawDelaunayTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#drawgridlinestransform", 
            "text": "Draws a grid on the image   file:  gui/drawgridlines.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "DrawGridLinesTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#drawopticalflow", 
            "text": "Draw a line representing the direction and magnitude of optical flow at the specified points.   file:  gui/drawopticalflow.cpp  inherits:   UntrainableTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "DrawOpticalFlow"
        }, 
        {
            "location": "/plugin_docs/gui/#drawpropertiespointtransform", 
            "text": "Draw the values of a list of properties at the specified point on the image  The inPlace argument controls whether or not the image is cloned before it is drawn on.   file:  gui/drawpropertiespoint.cpp  inherits:   UntrainableTransform  author(s):   Charles Otto  properties:  None", 
            "title": "DrawPropertiesPointTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#drawpropertypointtransform", 
            "text": "Draw the value of the specified property at the specified point on the image  The inPlace argument controls whether or not the image is cloned before it is drawn on.   file:  gui/drawpropertypoint.cpp  inherits:   UntrainableTransform  author(s):   Charles Otto  properties:  None", 
            "title": "DrawPropertyPointTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#drawsegmentation", 
            "text": "Fill in the segmentations or draw a line between intersecting segments.   file:  gui/drawsegmentation.cpp  inherits:   UntrainableTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "DrawSegmentation"
        }, 
        {
            "location": "/plugin_docs/gui/#drawtransform", 
            "text": "Renders metadata onto the image.  The inPlace argument controls whether or not the image is cloned before the metadata is drawn.   file:  gui/draw.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "DrawTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#elicittransform", 
            "text": "Elicits metadata for templates in a pretty GUI   file:  gui/show.cpp  inherits:   ShowTransform  author(s):   Scott Klum  properties:  None", 
            "title": "ElicitTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#fpscalc", 
            "text": "Calculates the average FPS of projects going through this transform, stores the result in AvgFPS\nReports an average FPS from the initialization of this transform onwards.   file:  gui/show.cpp  inherits:   TimeVaryingTransform  author(s):   Charles Otto  properties:  None", 
            "title": "FPSCalc"
        }, 
        {
            "location": "/plugin_docs/gui/#fpslimit", 
            "text": "Limits the frequency of projects going through this transform to the input targetFPS   file:  gui/show.cpp  inherits:   TimeVaryingTransform  author(s):   Charles Otto  properties:  None", 
            "title": "FPSLimit"
        }, 
        {
            "location": "/plugin_docs/gui/#filtertransform", 
            "text": "DOCUMENT ME   file:  gui/show.cpp  inherits:   ShowTransform  author(s):   Unknown  properties:  None", 
            "title": "FilterTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#manualrectstransform", 
            "text": "Manual select rectangular regions on an image.\nStores marked rectangles as anonymous rectangles, or if a set of labels is provided, prompt the user\nto select one of those labels after drawing each rectangle.   file:  gui/show.cpp  inherits:   ShowTransform  author(s):   Charles Otto  properties:  None", 
            "title": "ManualRectsTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#manualtransform", 
            "text": "Manual selection of landmark locations   file:  gui/show.cpp  inherits:   ShowTransform  author(s):   Scott Klum  properties:  None", 
            "title": "ManualTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#showtrainingtransform", 
            "text": "Show the training data   file:  gui/show.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "ShowTrainingTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#showtransform", 
            "text": "Displays templates in a GUI pop-up window using QT.  Can be used with parallelism enabled, although it is considered TimeVarying.   file:  gui/show.cpp  inherits:   TimeVaryingTransform  author(s):   Charles Otto  properties:  None", 
            "title": "ShowTransform"
        }, 
        {
            "location": "/plugin_docs/gui/#surveytransform", 
            "text": "Display an image, and asks a yes/no question about it   file:  gui/show.cpp  inherits:   ShowTransform  author(s):   Charles Otto  properties:  None", 
            "title": "SurveyTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/", 
            "text": "AbsDiffTransform\n\n\nTake the absolute difference of two matrices.\n\n\n\n\nfile:\n imgproc/absdiff.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nAbsTransform\n\n\nComputes the absolute value of each element.\n\n\n\n\nfile:\n imgproc/abs.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nAdaptiveThresholdTransform\n\n\nWraps OpenCV's adaptive thresholding.\n\n\n\n\nfile:\n imgproc/adaptivethreshold.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nAffineTransform\n\n\nPerforms a two or three point registration.\n\n\n\n\nfile:\n imgproc/affine.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nAndTransform\n\n\nLogical AND of two matrices.\n\n\n\n\nfile:\n imgproc/and.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nApplyMaskTransform\n\n\nApplies a mask from the metadata.\n\n\n\n\nfile:\n imgproc/applymask.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None\n\n\n\n\n\n\nBayesianQuantizationTransform\n\n\nQuantize into a space where L1 distance approximates log-likelihood.\n\n\n\n\nfile:\n imgproc/bayesianquantization.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nBinarizeTransform\n\n\nApproximate floats as signed bit.\n\n\n\n\nfile:\n imgproc/binarize.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nBlendTransform\n\n\nAlpha-blend matrices\n\n\n\n\nfile:\n imgproc/blend.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nBlurTransform\n\n\nGaussian blur\n\n\n\n\nfile:\n imgproc/blur.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nBuildScalesTransform\n\n\nDOCUMENT ME\n\n\n\n\nfile:\n imgproc/multiscale.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None\n\n\n\n\n\n\nByRowTransform\n\n\nTurns each row into its own matrix.\n\n\n\n\nfile:\n imgproc/byrow.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCannyTransform\n\n\nWrapper to OpenCV Canny edge detector\n\n\n\n\nfile:\n imgproc/canny.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nCatColsTransform\n\n\nConcatenates all input matrices by column into a single matrix.\nUse after a fork to concatenate two feature matrices by column.\n\n\n\n\nfile:\n imgproc/catcols.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None\n\n\n\n\n\n\nCatRowsTransform\n\n\nConcatenates all input matrices by row into a single matrix.\nAll matricies must have the same column counts.\n\n\n\n\nfile:\n imgproc/catrows.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCatTransform\n\n\nConcatenates all input matrices into a single matrix.\n\n\n\n\nfile:\n imgproc/cat.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCenterTransform\n\n\nNormalize each dimension based on training data.\n\n\n\n\nfile:\n imgproc/center.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nContrastEqTransform\n\n\nPerform contrast equalization\n\n\n\n\nfile:\n imgproc/contrasteq.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nXiaoyang Tan; Triggs, B.;\n\n \n\"Enhanced Local Texture Feature Sets for Face Recognition Under Difficult Lighting Conditions,\"\n\n Image Processing, IEEE Transactions on , vol.19, no.6, pp.1635-1650, June 2010\n\n\n\n\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\n\n\nConvexHullTransform\n\n\nSet the template's label to the area of the largest convex hull.\n\n\n\n\nfile:\n imgproc/convexhull.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCropBlackTransform\n\n\nCrop out black borders\n\n\n\n\nfile:\n imgproc/cropblack.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCropFromMaskTransform\n\n\nCrops image based on mask metadata\n\n\n\n\nfile:\n imgproc/cropfrommask.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nCropSquareTransform\n\n\nTrim the image so the width and the height are the same size.\n\n\n\n\nfile:\n imgproc/cropsquare.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCropTransform\n\n\nCrops about the specified region of interest.\n\n\n\n\nfile:\n imgproc/crop.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCryptographicHashTransform\n\n\nWraps QCryptographicHash\n\n\n\n\nfile:\n imgproc/cryptographichash.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nCustomSIFTTransform\n\n\nSpecialize wrapper OpenCV SIFT wrapper\n\n\n\n\nfile:\n imgproc/custom_sift.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCvtFloatTransform\n\n\nConvert to floating point format.\n\n\n\n\nfile:\n imgproc/cvtfloat.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCvtTransform\n\n\nColorspace conversion.\n\n\n\n\nfile:\n imgproc/cvt.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nCvtUCharTransform\n\n\nConvert to uchar format\n\n\n\n\nfile:\n imgproc/cvtuchar.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDiscardAlphaTransform\n\n\nDrop the alpha channel (if exists).\n\n\n\n\nfile:\n imgproc/discardalpha.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None\n\n\n\n\n\n\nDivTransform\n\n\nEnforce a multiple of n columns.\n\n\n\n\nfile:\n imgproc/div.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDoGTransform\n\n\nDifference of gaussians\n\n\n\n\nfile:\n imgproc/dog.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDownsampleTransform\n\n\nDownsample the rows and columns of a matrix.\n\n\n\n\nfile:\n imgproc/downsample.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nLacey Best-Rowden\n\n\nproperties:\n None\n\n\n\n\n\n\nDupTransform\n\n\nDuplicates the \nTemplate\n data.\n\n\n\n\nfile:\n imgproc/dup.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nEnsureChannelsTransform\n\n\nEnforce the matrix has a certain number of channels by adding or removing channels.\n\n\n\n\nfile:\n imgproc/ensurechannels.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nEqualizeHistTransform\n\n\nHistogram equalization\n\n\n\n\nfile:\n imgproc/equalizehist.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nFillContoursTransform\n\n\nFills contours with white pixels.\n\n\n\n\nfile:\n imgproc/fillcontours.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nFlipTransform\n\n\nFlips the image about an axis.\n\n\n\n\nfile:\n imgproc/flip.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nFloodTransform\n\n\nFill black pixels with the specified color.\n\n\n\n\nfile:\n imgproc/flood.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nGaborJetTransform\n\n\nA vector of gabor wavelets applied at a point.\n\n\n\n\nfile:\n imgproc/gabor.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nGaborTransform\n\n\nImplements a Gabor Filter\n\n\n\n\nfile:\n imgproc/gabor.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nGammaTransform\n\n\nGamma correction\n\n\n\n\nfile:\n imgproc/gamma.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nGradientMaskTransform\n\n\nMasks image according to pixel change.\n\n\n\n\nfile:\n imgproc/gradientmask.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nGradientTransform\n\n\nComputes magnitude and/or angle of image.\n\n\n\n\nfile:\n imgproc/gradient.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nGroupTransform\n\n\nGroup all input matrices into a single matrix.\n\n\nSimilar to CatTransfrom but groups every \nsize\n adjacent matricies.\n\n\n\n\nfile:\n imgproc/group.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nHeatmapTransform\n\n\nApplies a colormap to src.\n\n\n\n\nfile:\n imgproc/heatmap.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nHistBinTransform\n\n\nQuantizes the values into bins.\n\n\n\n\nfile:\n imgproc/histbin.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nHistEqQuantizationTransform\n\n\nApproximate floats as uchar with different scalings for each dimension.\n\n\n\n\nfile:\n imgproc/histeqquantization.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nHistTransform\n\n\nHistograms the matrix\n\n\n\n\nfile:\n imgproc/hist.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nHoGDescriptorTransform\n\n\nOpenCV HOGDescriptor wrapper\n\n\n\n\nfile:\n imgproc/hog.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nHuMomentsTransform\n\n\nComputes the seven Hu moments of a shape.\n\n\n\n\nfile:\n imgproc/humoments.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nInpaintTransform\n\n\nWraps OpenCV inpainting\n\n\n\n\nfile:\n imgproc/inpaint.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nIntegralHistTransform\n\n\nAn integral histogram\n\n\n\n\nfile:\n imgproc/integralhist.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nIntegralSamplerTransform\n\n\nSliding window feature extraction from a multi-channel integral image.\n\n\n\n\nfile:\n imgproc/integralsampler.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nIntegralTransform\n\n\nComputes integral image.\n\n\n\n\nfile:\n imgproc/integral.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nKernelHashTransform\n\n\nKernel hash\n\n\n\n\nfile:\n imgproc/kernelhash.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nKeyPointDescriptorTransform\n\n\nWraps OpenCV Key Point Descriptor\n\n\n\n\nfile:\n imgproc/keypointdescriptor.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nLBPTransform\n\n\nConvert the image into a feature vector using Local Binary Patterns\n\n\n\n\nfile:\n imgproc/lbp.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nAhonen, T.; Hadid, A.; Pietikainen, M.;\n\n \n\"Face Description with Local Binary Patterns: Application to Face Recognition\"\n\n Pattern Analysis and Machine Intelligence, IEEE Transactions, vol.28, no.12, pp.2037-2041, Dec. 2006\n\n\n\n\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\n\n\nLTPTransform\n\n\nDOCUMENT ME\n\n\n\n\nfile:\n imgproc/ltp.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nBrendan Klare\n, \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nTan, Xiaoyang, and Bill Triggs.\n\n \n\"Enhanced local texture feature sets for face recognition under difficult lighting conditions.\"\n\n Analysis and Modeling of Faces and Gestures. Springer Berlin Heidelberg, 2007. 168-182.\n\n\n\n\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\n\n\nLargestConvexAreaTransform\n\n\nSet the template's label to the area of the largest convex hull.\n\n\n\n\nfile:\n imgproc/largestconvexarea.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nLimitSizeTransform\n\n\nLimit the size of the template\n\n\n\n\nfile:\n imgproc/limitsize.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nMAddTransform\n\n\ndst = a*src+b\n\n\n\n\nfile:\n imgproc/madd.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nMaskTransform\n\n\nApplies an eliptical mask\n\n\n\n\nfile:\n imgproc/mask.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nMatStatsTransform\n\n\nStatistics\n\n\n\n\nfile:\n imgproc/matstats.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nMeanFillTransform\n\n\nFill 0 pixels with the mean of non-0 pixels.\n\n\n\n\nfile:\n imgproc/meanfill.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nMeanTransform\n\n\nComputes the mean of a set of templates.\n\n\nSuitable for visualization only as it sets every projected template to the mean template.\n\n\n\n\nfile:\n imgproc/mean.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nMergeTransform\n\n\nWraps OpenCV merge\n\n\n\n\nfile:\n imgproc/merge.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nMorphTransform\n\n\nMorphological operator\n\n\n\n\nfile:\n imgproc/morph.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nNLMeansDenoisingTransform\n\n\nWraps OpenCV Non-Local Means Denoising\n\n\n\n\nfile:\n imgproc/denoising.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nNormalizeTransform\n\n\nNormalize matrix to unit length\n\n\n\n\nfile:\n imgproc/normalize.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNormType\n\n\nenum\n\n\nValues are:\nNORM_INF\nNORM_L1\nNORM_L2\nNORM_MINMAX\n\n\n\n\n\n\nByRow\n\n\nbool\n\n\nIf true normalize each row independently otherwise normalize the entire matrix.\n\n\n\n\n\n\nalpha\n\n\nint\n\n\nLower bound if using NORM_MINMAX. Value to normalize to otherwise.\n\n\n\n\n\n\nbeta\n\n\nint\n\n\nUpper bound if using NORM_MINMAX. Not used otherwise.\n\n\n\n\n\n\nsquareRoot\n\n\nbool\n\n\nIf true compute the signed square root of the output after normalization.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrigLinearRegressionTransform\n\n\nPrediction with magic numbers from jmp; must get input as blue;green;red\n\n\n\n\nfile:\n imgproc/origlinearregression.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nE. Taborsky\n\n\nproperties:\n None\n\n\n\n\n\n\nPackTransform\n\n\nCompress two uchar into one uchar.\n\n\n\n\nfile:\n imgproc/pack.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nPowTransform\n\n\nRaise each element to the specified power.\n\n\n\n\nfile:\n imgproc/pow.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nProductQuantizationDistance\n\n\nDistance in a product quantized space\n\n\n\n\nfile:\n imgproc/productquantization.cpp\n\n\ninherits:\n \nUntrainableDistance\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nJegou, Herve, Matthijs Douze, and Cordelia Schmid.\n\n \n\"Product quantization for nearest neighbor search.\"\n\n Pattern Analysis and Machine Intelligence, IEEE Transactions on 33.1 (2011): 117-128\n\n\n\n\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\n\n\nProductQuantizationTransform\n\n\nProduct quantization\n\n\n\n\nfile:\n imgproc/productquantization.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nJegou, Herve, Matthijs Douze, and Cordelia Schmid.\n\n \n\"Product quantization for nearest neighbor search.\"\n\n Pattern Analysis and Machine Intelligence, IEEE Transactions on 33.1 (2011): 117-128\n\n\n\n\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\n\n\nQuantizeTransform\n\n\nApproximate floats as uchar.\n\n\n\n\nfile:\n imgproc/quantize.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRGTransform\n\n\nNormalized RG color space.\n\n\n\n\nfile:\n imgproc/rg.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nROIFromPtsTransform\n\n\nCrops the rectangular regions of interest from given points and sizes.\n\n\n\n\nfile:\n imgproc/roifrompoints.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None\n\n\n\n\n\n\nROITransform\n\n\nCrops the rectangular regions of interest.\n\n\n\n\nfile:\n imgproc/roi.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRankTransform\n\n\nConverts each element to its rank-ordered value.\n\n\n\n\nfile:\n imgproc/rank.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRectRegionsTransform\n\n\nSubdivide matrix into rectangular subregions.\n\n\n\n\nfile:\n imgproc/rectregions.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRecursiveIntegralSamplerTransform\n\n\nConstruct \nTemplate\n in a recursive decent manner.\n\n\n\n\nfile:\n imgproc/recursiveintegralsampler.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRedLinearRegressionTransform\n\n\nPrediction using only the red wavelength; magic numbers from jmp\n\n\n\n\nfile:\n imgproc/redlinearregression.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nE. Taborsky\n\n\nproperties:\n None\n\n\n\n\n\n\nReshapeTransform\n\n\nReshape each matrix to the specified number of rows.\n\n\n\n\nfile:\n imgproc/reshape.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nResizeFilterTransform\n\n\nResize the template depending on its metadata\n\n\n\n\nfile:\n imgproc/resizefilter.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n [Jordan Cheney][JordanCheney]\n\n\nproperties:\n None\n\n\n\n\n\n\nResizeTransform\n\n\nResize the template\n\n\n\n\nfile:\n imgproc/resize.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmethod\n\n\nenum\n\n\nResize method. Good options are:\nArea should be used for shrinking an image\nCubic for slow but accurate enlargment\nBilin for fast enlargement\n\n\n\n\n\n\npreserveAspect\n\n\nbool\n\n\nIf true, the image will be sized per specification, but a border will be applied to preserve aspect ratio.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRevertAffineTransform\n\n\nDesigned for use after eye detection + Stasm, this will\nrevert the detected landmarks to the original coordinate space\nbefore affine alignment to the stasm mean shape. The storeAffine\nparameter must be set to true when calling AffineTransform before this.\n\n\n\n\nfile:\n imgproc/revertaffine.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nRndPointTransform\n\n\nGenerates a random landmark.\n\n\n\n\nfile:\n imgproc/rndpoint.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRndRegionTransform\n\n\nSelects a random region.\n\n\n\n\nfile:\n imgproc/rndregion.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRndRotateTransform\n\n\nRandomly rotates an image in a specified range.\n\n\n\n\nfile:\n imgproc/rndrotate.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nRndSubspaceTransform\n\n\nGenerates a random subspace.\n\n\n\n\nfile:\n imgproc/rndsubspace.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRootNormTransform\n\n\ndst=sqrt(norm_L1(src)) proposed as RootSIFT (see paper)\n\n\n\n\nfile:\n imgproc/rootnorm.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nArandjelovic, Relja, and Andrew Zisserman.\n\n \n\"Three things everyone should know to improve object retrieval.\"\n\n Computer Vision and Pattern Recognition (CVPR), 2012 IEEE Conference on. IEEE, 2012.\n\n\n\n\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\n\n\nRowWiseMeanCenterTransform\n\n\nRemove the row-wise training set average.\n\n\n\n\nfile:\n imgproc/rowwisemeancenter.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nSIFTDescriptorTransform\n\n\nSpecialize wrapper OpenCV SIFT wrapper\n\n\n\n\nfile:\n imgproc/sift.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nSampleFromMaskTransform\n\n\nSamples pixels from a mask.\n\n\n\n\nfile:\n imgproc/samplefrommask.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nScaleTransform\n\n\nScales using the given factor\n\n\n\n\nfile:\n imgproc/scale.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nSkinMaskTransform\n\n\nMake a mask over skin in an image\n\n\n\n\nfile:\n imgproc/skinmask.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nSobelTransform\n\n\nApproximates the gradient in an image using sobel operator.\n\n\n\n\nfile:\n imgproc/sobel.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nSplitChannelsTransform\n\n\nSplit a multi-channel matrix into several single-channel matrices.\n\n\n\n\nfile:\n imgproc/splitchannels.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nSubdivideTransform\n\n\nDivide the matrix into 4 smaller matricies of equal size.\n\n\n\n\nfile:\n imgproc/subdivide.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nSubtractTransform\n\n\nSubtract two matrices.\n\n\n\n\nfile:\n imgproc/subtract.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nSynthesizePointsTransform\n\n\nSynthesize additional points via triangulation.\n\n\n\n\nfile:\n imgproc/synthesizekeypoints.cpp\n\n\ninherits:\n \nMetadataTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nThresholdTransform\n\n\nWraps OpenCV's thresholding.\n\n\n\n\nfile:\n imgproc/threshold.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nTransposeTransform\n\n\nGet the transpose of the \nTemplate\n matrix\n\n\n\n\nfile:\n imgproc/transpose.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nTrimTransform\n\n\nTrims a percentage of width and height from the border of a matrix.\n\n\n\n\nfile:\n imgproc/trim.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nWatershedSegmentationTransform\n\n\nApplies watershed segmentation.\n\n\n\n\nfile:\n imgproc/watershedsegmentation.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None", 
            "title": "Image Processing"
        }, 
        {
            "location": "/plugin_docs/imgproc/#absdifftransform", 
            "text": "Take the absolute difference of two matrices.   file:  imgproc/absdiff.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "AbsDiffTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#abstransform", 
            "text": "Computes the absolute value of each element.   file:  imgproc/abs.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "AbsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#adaptivethresholdtransform", 
            "text": "Wraps OpenCV's adaptive thresholding.   file:  imgproc/adaptivethreshold.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  see:    properties:  None", 
            "title": "AdaptiveThresholdTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#affinetransform", 
            "text": "Performs a two or three point registration.   file:  imgproc/affine.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "AffineTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#andtransform", 
            "text": "Logical AND of two matrices.   file:  imgproc/and.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "AndTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#applymasktransform", 
            "text": "Applies a mask from the metadata.   file:  imgproc/applymask.cpp  inherits:   UntrainableTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "ApplyMaskTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#bayesianquantizationtransform", 
            "text": "Quantize into a space where L1 distance approximates log-likelihood.   file:  imgproc/bayesianquantization.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "BayesianQuantizationTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#binarizetransform", 
            "text": "Approximate floats as signed bit.   file:  imgproc/binarize.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "BinarizeTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#blendtransform", 
            "text": "Alpha-blend matrices   file:  imgproc/blend.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "BlendTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#blurtransform", 
            "text": "Gaussian blur   file:  imgproc/blur.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "BlurTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#buildscalestransform", 
            "text": "DOCUMENT ME   file:  imgproc/multiscale.cpp  inherits:   Transform  author(s):   Austin Blanton  properties:  None", 
            "title": "BuildScalesTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#byrowtransform", 
            "text": "Turns each row into its own matrix.   file:  imgproc/byrow.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "ByRowTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cannytransform", 
            "text": "Wrapper to OpenCV Canny edge detector   file:  imgproc/canny.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  see:    properties:  None", 
            "title": "CannyTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#catcolstransform", 
            "text": "Concatenates all input matrices by column into a single matrix.\nUse after a fork to concatenate two feature matrices by column.   file:  imgproc/catcols.cpp  inherits:   UntrainableMetaTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "CatColsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#catrowstransform", 
            "text": "Concatenates all input matrices by row into a single matrix.\nAll matricies must have the same column counts.   file:  imgproc/catrows.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CatRowsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cattransform", 
            "text": "Concatenates all input matrices into a single matrix.   file:  imgproc/cat.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CatTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#centertransform", 
            "text": "Normalize each dimension based on training data.   file:  imgproc/center.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "CenterTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#contrasteqtransform", 
            "text": "Perform contrast equalization   file:  imgproc/contrasteq.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz   read:   Xiaoyang Tan; Triggs, B.; \n  \"Enhanced Local Texture Feature Sets for Face Recognition Under Difficult Lighting Conditions,\" \n Image Processing, IEEE Transactions on , vol.19, no.6, pp.1635-1650, June 2010     properties:  None", 
            "title": "ContrastEqTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#convexhulltransform", 
            "text": "Set the template's label to the area of the largest convex hull.   file:  imgproc/convexhull.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "ConvexHullTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cropblacktransform", 
            "text": "Crop out black borders   file:  imgproc/cropblack.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CropBlackTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cropfrommasktransform", 
            "text": "Crops image based on mask metadata   file:  imgproc/cropfrommask.cpp  inherits:   UntrainableTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "CropFromMaskTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cropsquaretransform", 
            "text": "Trim the image so the width and the height are the same size.   file:  imgproc/cropsquare.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CropSquareTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#croptransform", 
            "text": "Crops about the specified region of interest.   file:  imgproc/crop.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CropTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cryptographichashtransform", 
            "text": "Wraps QCryptographicHash   file:  imgproc/cryptographichash.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "CryptographicHashTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#customsifttransform", 
            "text": "Specialize wrapper OpenCV SIFT wrapper   file:  imgproc/custom_sift.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CustomSIFTTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cvtfloattransform", 
            "text": "Convert to floating point format.   file:  imgproc/cvtfloat.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CvtFloatTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cvttransform", 
            "text": "Colorspace conversion.   file:  imgproc/cvt.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CvtTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#cvtuchartransform", 
            "text": "Convert to uchar format   file:  imgproc/cvtuchar.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CvtUCharTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#discardalphatransform", 
            "text": "Drop the alpha channel (if exists).   file:  imgproc/discardalpha.cpp  inherits:   UntrainableTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "DiscardAlphaTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#divtransform", 
            "text": "Enforce a multiple of n columns.   file:  imgproc/div.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "DivTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#dogtransform", 
            "text": "Difference of gaussians   file:  imgproc/dog.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "DoGTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#downsampletransform", 
            "text": "Downsample the rows and columns of a matrix.   file:  imgproc/downsample.cpp  inherits:   UntrainableTransform  author(s):   Lacey Best-Rowden  properties:  None", 
            "title": "DownsampleTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#duptransform", 
            "text": "Duplicates the  Template  data.   file:  imgproc/dup.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "DupTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#ensurechannelstransform", 
            "text": "Enforce the matrix has a certain number of channels by adding or removing channels.   file:  imgproc/ensurechannels.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "EnsureChannelsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#equalizehisttransform", 
            "text": "Histogram equalization   file:  imgproc/equalizehist.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "EqualizeHistTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#fillcontourstransform", 
            "text": "Fills contours with white pixels.   file:  imgproc/fillcontours.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "FillContoursTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#fliptransform", 
            "text": "Flips the image about an axis.   file:  imgproc/flip.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "FlipTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#floodtransform", 
            "text": "Fill black pixels with the specified color.   file:  imgproc/flood.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "FloodTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#gaborjettransform", 
            "text": "A vector of gabor wavelets applied at a point.   file:  imgproc/gabor.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "GaborJetTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#gabortransform", 
            "text": "Implements a Gabor Filter   file:  imgproc/gabor.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "GaborTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#gammatransform", 
            "text": "Gamma correction   file:  imgproc/gamma.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "GammaTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#gradientmasktransform", 
            "text": "Masks image according to pixel change.   file:  imgproc/gradientmask.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "GradientMaskTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#gradienttransform", 
            "text": "Computes magnitude and/or angle of image.   file:  imgproc/gradient.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "GradientTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#grouptransform", 
            "text": "Group all input matrices into a single matrix.  Similar to CatTransfrom but groups every  size  adjacent matricies.   file:  imgproc/group.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "GroupTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#heatmaptransform", 
            "text": "Applies a colormap to src.   file:  imgproc/heatmap.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "HeatmapTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#histbintransform", 
            "text": "Quantizes the values into bins.   file:  imgproc/histbin.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "HistBinTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#histeqquantizationtransform", 
            "text": "Approximate floats as uchar with different scalings for each dimension.   file:  imgproc/histeqquantization.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "HistEqQuantizationTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#histtransform", 
            "text": "Histograms the matrix   file:  imgproc/hist.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "HistTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#hogdescriptortransform", 
            "text": "OpenCV HOGDescriptor wrapper   file:  imgproc/hog.cpp  inherits:   UntrainableTransform  author(s):   Austin Blanton  see:    properties:  None", 
            "title": "HoGDescriptorTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#humomentstransform", 
            "text": "Computes the seven Hu moments of a shape.   file:  imgproc/humoments.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "HuMomentsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#inpainttransform", 
            "text": "Wraps OpenCV inpainting   file:  imgproc/inpaint.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "InpaintTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#integralhisttransform", 
            "text": "An integral histogram   file:  imgproc/integralhist.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "IntegralHistTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#integralsamplertransform", 
            "text": "Sliding window feature extraction from a multi-channel integral image.   file:  imgproc/integralsampler.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "IntegralSamplerTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#integraltransform", 
            "text": "Computes integral image.   file:  imgproc/integral.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "IntegralTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#kernelhashtransform", 
            "text": "Kernel hash   file:  imgproc/kernelhash.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "KernelHashTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#keypointdescriptortransform", 
            "text": "Wraps OpenCV Key Point Descriptor   file:  imgproc/keypointdescriptor.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "KeyPointDescriptorTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#lbptransform", 
            "text": "Convert the image into a feature vector using Local Binary Patterns   file:  imgproc/lbp.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz   read:   Ahonen, T.; Hadid, A.; Pietikainen, M.; \n  \"Face Description with Local Binary Patterns: Application to Face Recognition\" \n Pattern Analysis and Machine Intelligence, IEEE Transactions, vol.28, no.12, pp.2037-2041, Dec. 2006     properties:  None", 
            "title": "LBPTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#ltptransform", 
            "text": "DOCUMENT ME   file:  imgproc/ltp.cpp  inherits:   UntrainableTransform  author(s):   Brendan Klare ,  Josh Klontz   read:   Tan, Xiaoyang, and Bill Triggs. \n  \"Enhanced local texture feature sets for face recognition under difficult lighting conditions.\" \n Analysis and Modeling of Faces and Gestures. Springer Berlin Heidelberg, 2007. 168-182.     properties:  None", 
            "title": "LTPTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#largestconvexareatransform", 
            "text": "Set the template's label to the area of the largest convex hull.   file:  imgproc/largestconvexarea.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "LargestConvexAreaTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#limitsizetransform", 
            "text": "Limit the size of the template   file:  imgproc/limitsize.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "LimitSizeTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#maddtransform", 
            "text": "dst = a*src+b   file:  imgproc/madd.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "MAddTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#masktransform", 
            "text": "Applies an eliptical mask   file:  imgproc/mask.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "MaskTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#matstatstransform", 
            "text": "Statistics   file:  imgproc/matstats.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "MatStatsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#meanfilltransform", 
            "text": "Fill 0 pixels with the mean of non-0 pixels.   file:  imgproc/meanfill.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "MeanFillTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#meantransform", 
            "text": "Computes the mean of a set of templates.  Suitable for visualization only as it sets every projected template to the mean template.   file:  imgproc/mean.cpp  inherits:   Transform  author(s):   Scott Klum  properties:  None", 
            "title": "MeanTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#mergetransform", 
            "text": "Wraps OpenCV merge   file:  imgproc/merge.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "MergeTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#morphtransform", 
            "text": "Morphological operator   file:  imgproc/morph.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "MorphTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#nlmeansdenoisingtransform", 
            "text": "Wraps OpenCV Non-Local Means Denoising   file:  imgproc/denoising.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "NLMeansDenoisingTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#normalizetransform", 
            "text": "Normalize matrix to unit length   file:  imgproc/normalize.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz   properties:     Property  Type  Description      NormType  enum  Values are: NORM_INF NORM_L1 NORM_L2 NORM_MINMAX    ByRow  bool  If true normalize each row independently otherwise normalize the entire matrix.    alpha  int  Lower bound if using NORM_MINMAX. Value to normalize to otherwise.    beta  int  Upper bound if using NORM_MINMAX. Not used otherwise.    squareRoot  bool  If true compute the signed square root of the output after normalization.", 
            "title": "NormalizeTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#origlinearregressiontransform", 
            "text": "Prediction with magic numbers from jmp; must get input as blue;green;red   file:  imgproc/origlinearregression.cpp  inherits:   UntrainableMetaTransform  author(s):   E. Taborsky  properties:  None", 
            "title": "OrigLinearRegressionTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#packtransform", 
            "text": "Compress two uchar into one uchar.   file:  imgproc/pack.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "PackTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#powtransform", 
            "text": "Raise each element to the specified power.   file:  imgproc/pow.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "PowTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#productquantizationdistance", 
            "text": "Distance in a product quantized space   file:  imgproc/productquantization.cpp  inherits:   UntrainableDistance  author(s):   Josh Klontz   read:   Jegou, Herve, Matthijs Douze, and Cordelia Schmid. \n  \"Product quantization for nearest neighbor search.\" \n Pattern Analysis and Machine Intelligence, IEEE Transactions on 33.1 (2011): 117-128     properties:  None", 
            "title": "ProductQuantizationDistance"
        }, 
        {
            "location": "/plugin_docs/imgproc/#productquantizationtransform", 
            "text": "Product quantization   file:  imgproc/productquantization.cpp  inherits:   Transform  author(s):   Josh Klontz   read:   Jegou, Herve, Matthijs Douze, and Cordelia Schmid. \n  \"Product quantization for nearest neighbor search.\" \n Pattern Analysis and Machine Intelligence, IEEE Transactions on 33.1 (2011): 117-128     properties:  None", 
            "title": "ProductQuantizationTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#quantizetransform", 
            "text": "Approximate floats as uchar.   file:  imgproc/quantize.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "QuantizeTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#rgtransform", 
            "text": "Normalized RG color space.   file:  imgproc/rg.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RGTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#roifromptstransform", 
            "text": "Crops the rectangular regions of interest from given points and sizes.   file:  imgproc/roifrompoints.cpp  inherits:   UntrainableTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "ROIFromPtsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#roitransform", 
            "text": "Crops the rectangular regions of interest.   file:  imgproc/roi.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "ROITransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#ranktransform", 
            "text": "Converts each element to its rank-ordered value.   file:  imgproc/rank.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RankTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#rectregionstransform", 
            "text": "Subdivide matrix into rectangular subregions.   file:  imgproc/rectregions.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RectRegionsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#recursiveintegralsamplertransform", 
            "text": "Construct  Template  in a recursive decent manner.   file:  imgproc/recursiveintegralsampler.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "RecursiveIntegralSamplerTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#redlinearregressiontransform", 
            "text": "Prediction using only the red wavelength; magic numbers from jmp   file:  imgproc/redlinearregression.cpp  inherits:   UntrainableTransform  author(s):   E. Taborsky  properties:  None", 
            "title": "RedLinearRegressionTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#reshapetransform", 
            "text": "Reshape each matrix to the specified number of rows.   file:  imgproc/reshape.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "ReshapeTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#resizefiltertransform", 
            "text": "Resize the template depending on its metadata   file:  imgproc/resizefilter.cpp  inherits:   UntrainableTransform  author(s):  [Jordan Cheney][JordanCheney]  properties:  None", 
            "title": "ResizeFilterTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#resizetransform", 
            "text": "Resize the template   file:  imgproc/resize.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz   properties:     Property  Type  Description      method  enum  Resize method. Good options are: Area should be used for shrinking an image Cubic for slow but accurate enlargment Bilin for fast enlargement    preserveAspect  bool  If true, the image will be sized per specification, but a border will be applied to preserve aspect ratio.", 
            "title": "ResizeTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#revertaffinetransform", 
            "text": "Designed for use after eye detection + Stasm, this will\nrevert the detected landmarks to the original coordinate space\nbefore affine alignment to the stasm mean shape. The storeAffine\nparameter must be set to true when calling AffineTransform before this.   file:  imgproc/revertaffine.cpp  inherits:   UntrainableTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "RevertAffineTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#rndpointtransform", 
            "text": "Generates a random landmark.   file:  imgproc/rndpoint.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "RndPointTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#rndregiontransform", 
            "text": "Selects a random region.   file:  imgproc/rndregion.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RndRegionTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#rndrotatetransform", 
            "text": "Randomly rotates an image in a specified range.   file:  imgproc/rndrotate.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "RndRotateTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#rndsubspacetransform", 
            "text": "Generates a random subspace.   file:  imgproc/rndsubspace.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "RndSubspaceTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#rootnormtransform", 
            "text": "dst=sqrt(norm_L1(src)) proposed as RootSIFT (see paper)   file:  imgproc/rootnorm.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz   read:   Arandjelovic, Relja, and Andrew Zisserman. \n  \"Three things everyone should know to improve object retrieval.\" \n Computer Vision and Pattern Recognition (CVPR), 2012 IEEE Conference on. IEEE, 2012.     properties:  None", 
            "title": "RootNormTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#rowwisemeancentertransform", 
            "text": "Remove the row-wise training set average.   file:  imgproc/rowwisemeancenter.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "RowWiseMeanCenterTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#siftdescriptortransform", 
            "text": "Specialize wrapper OpenCV SIFT wrapper   file:  imgproc/sift.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "SIFTDescriptorTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#samplefrommasktransform", 
            "text": "Samples pixels from a mask.   file:  imgproc/samplefrommask.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "SampleFromMaskTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#scaletransform", 
            "text": "Scales using the given factor   file:  imgproc/scale.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "ScaleTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#skinmasktransform", 
            "text": "Make a mask over skin in an image   file:  imgproc/skinmask.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "SkinMaskTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#sobeltransform", 
            "text": "Approximates the gradient in an image using sobel operator.   file:  imgproc/sobel.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "SobelTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#splitchannelstransform", 
            "text": "Split a multi-channel matrix into several single-channel matrices.   file:  imgproc/splitchannels.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "SplitChannelsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#subdividetransform", 
            "text": "Divide the matrix into 4 smaller matricies of equal size.   file:  imgproc/subdivide.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "SubdivideTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#subtracttransform", 
            "text": "Subtract two matrices.   file:  imgproc/subtract.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "SubtractTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#synthesizepointstransform", 
            "text": "Synthesize additional points via triangulation.   file:  imgproc/synthesizekeypoints.cpp  inherits:   MetadataTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "SynthesizePointsTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#thresholdtransform", 
            "text": "Wraps OpenCV's thresholding.   file:  imgproc/threshold.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  see:    properties:  None", 
            "title": "ThresholdTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#transposetransform", 
            "text": "Get the transpose of the  Template  matrix   file:  imgproc/transpose.cpp  inherits:   UntrainableTransform  author(s):   Unknown  properties:  None", 
            "title": "TransposeTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#trimtransform", 
            "text": "Trims a percentage of width and height from the border of a matrix.   file:  imgproc/trim.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "TrimTransform"
        }, 
        {
            "location": "/plugin_docs/imgproc/#watershedsegmentationtransform", 
            "text": "Applies watershed segmentation.   file:  imgproc/watershedsegmentation.cpp  inherits:   UntrainableTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "WatershedSegmentationTransform"
        }, 
        {
            "location": "/plugin_docs/io/", 
            "text": "DecodeTransform\n\n\nDecodes images\n\n\n\n\nfile:\n io/decode.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDownloadTransform\n\n\nDownloads an image from a URL\n\n\n\n\nfile:\n io/download.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nGalleryOutputTransform\n\n\nDOCUMENT ME CHARLES\n\n\n\n\nfile:\n io/galleryoutput.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nIncrementalOutputTransform\n\n\nIncrementally output templates received to a gallery, based on the current filename\n\n\nWhen a template is received in projectUpdate for the first time since a finalize, open a new gallery based on the\ntemplate's filename, and the galleryFormat property.\n\n\nTemplate\n received in projectUpdate will be output to the gallery with a filename combining their original filename and\ntheir FrameNumber property, with the file extension specified by the fileFormat property.\n\n\n\n\nfile:\n io/incrementaloutput.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nOpenTransform\n\n\nApplies \nFormat\n to \nTemplate\n filename and appends results.\n\n\n\n\nfile:\n io/open.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nOutputTransform\n\n\nDOCUMENT ME CHARLES\n\n\n\n\nfile:\n io/out.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nPrintTransform\n\n\nPrints the file of the input \nTemplate\n to stdout or stderr.\n\n\n\n\nfile:\n io/print.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nReadLandmarksTransform\n\n\nRead landmarks from a file and associate them with the correct \nTemplate\n.\n\n\n\n\nfile:\n io/readlandmarks.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nformat:\n Example of the format: \nimage_001.jpg:146.000000,190.000000,227.000000,186.000000,202.000000,256.000000\nimage_002.jpg:75.000000,235.000000,140.000000,225.000000,91.000000,300.000000\nimage_003.jpg:158.000000,186.000000,246.000000,188.000000,208.000000,233.000000\n\n\n\nproperties:\n None\n\n\n\n\n\n\nReadTransform\n\n\nRead images\n\n\n\n\nfile:\n io/read.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nWriteTransform\n\n\nWrite all mats to disk as images.\n\n\n\n\nfile:\n io/write.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nYouTubeFacesDBTransform\n\n\nImplements the YouTubesFaceDB\n\n\n\n\nfile:\n io/youtubefacesdb.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nWolf, Lior, Tal Hassner, and Itay Maoz.\n\n \n\"Face recognition in unconstrained videos with matched background similarity.\"\n\n Computer Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on. IEEE, 2011.\n\n\n\n\n\n\n\n\nproperties:\n None", 
            "title": "I/O"
        }, 
        {
            "location": "/plugin_docs/io/#decodetransform", 
            "text": "Decodes images   file:  io/decode.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "DecodeTransform"
        }, 
        {
            "location": "/plugin_docs/io/#downloadtransform", 
            "text": "Downloads an image from a URL   file:  io/download.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "DownloadTransform"
        }, 
        {
            "location": "/plugin_docs/io/#galleryoutputtransform", 
            "text": "DOCUMENT ME CHARLES   file:  io/galleryoutput.cpp  inherits:   TimeVaryingTransform  author(s):   Unknown  properties:  None", 
            "title": "GalleryOutputTransform"
        }, 
        {
            "location": "/plugin_docs/io/#incrementaloutputtransform", 
            "text": "Incrementally output templates received to a gallery, based on the current filename  When a template is received in projectUpdate for the first time since a finalize, open a new gallery based on the\ntemplate's filename, and the galleryFormat property.  Template  received in projectUpdate will be output to the gallery with a filename combining their original filename and\ntheir FrameNumber property, with the file extension specified by the fileFormat property.   file:  io/incrementaloutput.cpp  inherits:   TimeVaryingTransform  author(s):   Charles Otto  properties:  None", 
            "title": "IncrementalOutputTransform"
        }, 
        {
            "location": "/plugin_docs/io/#opentransform", 
            "text": "Applies  Format  to  Template  filename and appends results.   file:  io/open.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "OpenTransform"
        }, 
        {
            "location": "/plugin_docs/io/#outputtransform", 
            "text": "DOCUMENT ME CHARLES   file:  io/out.cpp  inherits:   TimeVaryingTransform  author(s):   Unknown  properties:  None", 
            "title": "OutputTransform"
        }, 
        {
            "location": "/plugin_docs/io/#printtransform", 
            "text": "Prints the file of the input  Template  to stdout or stderr.   file:  io/print.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "PrintTransform"
        }, 
        {
            "location": "/plugin_docs/io/#readlandmarkstransform", 
            "text": "Read landmarks from a file and associate them with the correct  Template .   file:  io/readlandmarks.cpp  inherits:   UntrainableMetadataTransform  author(s):   Scott Klum  format:  Example of the format:  image_001.jpg:146.000000,190.000000,227.000000,186.000000,202.000000,256.000000\nimage_002.jpg:75.000000,235.000000,140.000000,225.000000,91.000000,300.000000\nimage_003.jpg:158.000000,186.000000,246.000000,188.000000,208.000000,233.000000  properties:  None", 
            "title": "ReadLandmarksTransform"
        }, 
        {
            "location": "/plugin_docs/io/#readtransform", 
            "text": "Read images   file:  io/read.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "ReadTransform"
        }, 
        {
            "location": "/plugin_docs/io/#writetransform", 
            "text": "Write all mats to disk as images.   file:  io/write.cpp  inherits:   TimeVaryingTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "WriteTransform"
        }, 
        {
            "location": "/plugin_docs/io/#youtubefacesdbtransform", 
            "text": "Implements the YouTubesFaceDB   file:  io/youtubefacesdb.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz   read:   Wolf, Lior, Tal Hassner, and Itay Maoz. \n  \"Face recognition in unconstrained videos with matched background similarity.\" \n Computer Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on. IEEE, 2011.     properties:  None", 
            "title": "YouTubeFacesDBTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/", 
            "text": "ASEFEyesTransform\n\n\nFind eye locations using an ASEF filter\n\n\n\n\nfile:\n metadata/eyes.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\n\n\nread:\n\n\n\n\nBolme, D.S.; Draper, B.A.; Beveridge, J.R.;\n\n \n\"Average of Synthetic Exact Filters,\"\n\n Computer Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on , vol., no., pp.2105-2112, 20-25 June 2009\n\n\n\n\n\n\n\n\nproperties:\n None\n\n\n\n\n\n\n\n\nAnonymizeLandmarksTransform\n\n\nRemove a name from a point/rect\n\n\n\n\nfile:\n metadata/anonymizelandmarks.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nAsTransform\n\n\nChange the \nTemplate\n file extension\n\n\n\n\nfile:\n metadata/as.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nAveragePointsTransform\n\n\nAverages a set of landmarks into a new landmark\n\n\n\n\nfile:\n metadata/averagepoints.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nCascadeTransform\n\n\nWraps OpenCV cascade classifier\n\n\n\n\nfile:\n metadata/cascade.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n, \nDavid Crouse\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nCheckTransform\n\n\nChecks the \nTemplate\n for NaN values.\n\n\n\n\nfile:\n metadata/check.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nClearPointsTransform\n\n\nClears the points from a \nTemplate\n\n\n\n\nfile:\n metadata/clearpoints.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nConsolidateDetectionsTransform\n\n\nConsolidate redundant/overlapping detections.\n\n\n\n\nfile:\n metadata/consolidatedetections.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nCropRectTransform\n\n\nCrops the width and height of a \nTemplate\n rects by input width and height factors.\n\n\n\n\nfile:\n metadata/croprect.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nDelaunayTransform\n\n\nCreates a Delaunay triangulation based on a set of points\n\n\n\n\nfile:\n metadata/delaunay.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nExpandRectTransform\n\n\nExpand the width and height of a \nTemplate\n rects by input width and height factors.\n\n\n\n\nfile:\n metadata/expandrect.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nExtractMetadataTransform\n\n\nCreate matrix from metadata values.\n\n\n\n\nfile:\n metadata/extractmetadata.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nFaceFromEyesTransform\n\n\nCreate face bounding box from two eye locations.\n\n\n\n\nfile:\n metadata/facefromeyes.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\n\n\nproperties:\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwidthPadding\n\n\ndouble\n\n\nSpecifies what percentage of the interpupliary distance (ipd) will be padded in both horizontal directions.\n\n\n\n\n\n\nverticalLocation\n\n\ndouble\n\n\nspecifies where vertically the eyes are within the bounding box (0.5 would be the center).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileExclusionTransform\n\n\nDOCUMENT ME CHARLES\n\n\n\n\nfile:\n metadata/fileexclusion.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nUnknown\n\n\nproperties:\n None\n\n\n\n\n\n\nFilterDupeMetadataTransform\n\n\nRemoves duplicate \nTemplate\n based on a unique metadata key\n\n\n\n\nfile:\n metadata/filterdupemetadata.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None\n\n\n\n\n\n\nGridTransform\n\n\nAdd landmarks to the \nTemplate\n in a grid layout\n\n\n\n\nfile:\n metadata/grid.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nGroundTruthTransform\n\n\nAdd any ground truth to the \nTemplate\n using the file's base name.\n\n\n\n\nfile:\n metadata/groundtruth.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nHOGPersonDetectorTransform\n\n\nDetects objects with OpenCV's built-in HOG detection.\n\n\n\n\nfile:\n metadata/hogpersondetector.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nIfMetadataTransform\n\n\nClear \nTemplate\n without the required metadata.\n\n\n\n\nfile:\n metadata/ifmetadata.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nImpostorUniquenessMeasureTransform\n\n\nImpostor Uniqueness Measure\n\n\n\n\nfile:\n metadata/imposteruniquenessmeasure.cpp\n\n\ninherits:\n \nTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nJSONTransform\n\n\nRepresent the metadata as JSON template data.\n\n\n\n\nfile:\n metadata/json.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nKeepMetadataTransform\n\n\nRetains only the values for the keys listed, to reduce template size\n\n\n\n\nfile:\n metadata/keepmetadata.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nKeyPointDetectorTransform\n\n\nWraps OpenCV Key Point Detector\n\n\n\n\nfile:\n metadata/keypointdetector.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nsee:\n \n\n\nproperties:\n None\n\n\n\n\n\n\nKeyToRectTransform\n\n\nConvert values of key_X, key_Y, key_Width, key_Height to a rect.\n\n\n\n\nfile:\n metadata/keytorect.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n [Jordan Cheney][JordanCheney]\n\n\nproperties:\n None\n\n\n\n\n\n\nNameLandmarksTransform\n\n\nName a point/rect\n\n\n\n\nfile:\n metadata/namelandmarks.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nNameTransform\n\n\nSets the \nTemplate\n matrix data to the br::File::name.\n\n\n\n\nfile:\n metadata/name.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nNormalizePointsTransform\n\n\nNormalize points to be relative to a single point\n\n\n\n\nfile:\n metadata/normalizepoints.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nPointDisplacementTransform\n\n\nNormalize points to be relative to a single point\n\n\n\n\nfile:\n metadata/pointdisplacement.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nPointsToMatrixTransform\n\n\nConverts either the file::points() list or a QList\n metadata item to be the template's matrix\n\n\n\n\nfile:\n metadata/pointstomatrix.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nProcrustesTransform\n\n\nProcrustes alignment of points\n\n\n\n\nfile:\n metadata/procrustes.cpp\n\n\ninherits:\n \nMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nRectsToTemplatesTransform\n\n\nFor each rectangle bounding box in src, a new \nTemplate\n is created.\n\n\n\n\nfile:\n metadata/rectstotemplates.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nRegexPropertyTransform\n\n\nApply the input regular expression to the value of inputProperty, store the matched portion in outputProperty.\n\n\n\n\nfile:\n metadata/regexproperty.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nRemoveMetadataTransform\n\n\nRemoves a metadata field from all \nTemplate\n\n\n\n\nfile:\n metadata/removemetadata.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nRemoveTemplatesTransform\n\n\nRemove \nTemplate\n with the specified file extension or metadata value.\n\n\n\n\nfile:\n metadata/removetemplates.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRenameFirstTransform\n\n\nRename first found metadata key\n\n\n\n\nfile:\n metadata/renamefirst.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nRenameTransform\n\n\nRename metadata key\n\n\n\n\nfile:\n metadata/rename.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nReorderPointsTransform\n\n\nReorder the points such that points[from[i]] becomes points[to[i]] and\nvice versa\n\n\n\n\nfile:\n metadata/reorderpoints.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nRestoreMatTransform\n\n\nSet the last matrix of the input \nTemplate\n to a matrix stored as metadata with input propName.\n\n\nAlso removes the property from the \nTemplate\ns metadata after restoring it.\n\n\n\n\nfile:\n metadata/restoremat.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nSaveMatTransform\n\n\nStore the last matrix of the input \nTemplate\n as a metadata key with input property name.\n\n\n\n\nfile:\n metadata/savemat.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nSelectPointsTransform\n\n\nRetains only landmarks/points at the provided indices\n\n\n\n\nfile:\n metadata/selectpoints.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nBrendan Klare\n\n\nproperties:\n None\n\n\n\n\n\n\nSetMetadataTransform\n\n\nSets the metadata key/value pair.\n\n\n\n\nfile:\n metadata/setmetadata.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nSetPointsInRectTransform\n\n\nSet points relative to a rect\n\n\n\n\nfile:\n metadata/setpointsinrect.cpp\n\n\ninherits:\n \nUntrainableMetadataTransform\n\n\nauthor(s):\n [Jordan Cheney][JordanCheney]\n\n\nproperties:\n None\n\n\n\n\n\n\nStasmTransform\n\n\nWraps STASM key point detector\n\n\n\n\nfile:\n metadata/stasm4.cpp\n\n\ninherits:\n \nUntrainableTransform\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nStopWatchTransform\n\n\nGives time elapsed over a specified \nTransform\n as a function of both images (or frames) and pixels.\n\n\n\n\nfile:\n metadata/stopwatch.cpp\n\n\ninherits:\n \nMetaTransform\n\n\nauthor(s):\n [Jordan Cheney][JordanCheney], \nJosh Klontz\n\n\nproperties:\n None", 
            "title": "Metadata"
        }, 
        {
            "location": "/plugin_docs/metadata/#asefeyestransform", 
            "text": "Find eye locations using an ASEF filter   file:  metadata/eyes.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz   read:   Bolme, D.S.; Draper, B.A.; Beveridge, J.R.; \n  \"Average of Synthetic Exact Filters,\" \n Computer Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on , vol., no., pp.2105-2112, 20-25 June 2009     properties:  None", 
            "title": "ASEFEyesTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#anonymizelandmarkstransform", 
            "text": "Remove a name from a point/rect   file:  metadata/anonymizelandmarks.cpp  inherits:   UntrainableMetadataTransform  author(s):   Scott Klum  properties:  None", 
            "title": "AnonymizeLandmarksTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#astransform", 
            "text": "Change the  Template  file extension   file:  metadata/as.cpp  inherits:   UntrainableMetadataTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "AsTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#averagepointstransform", 
            "text": "Averages a set of landmarks into a new landmark   file:  metadata/averagepoints.cpp  inherits:   UntrainableMetadataTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "AveragePointsTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#cascadetransform", 
            "text": "Wraps OpenCV cascade classifier   file:  metadata/cascade.cpp  inherits:   MetaTransform  author(s):   Josh Klontz ,  David Crouse  see:    properties:  None", 
            "title": "CascadeTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#checktransform", 
            "text": "Checks the  Template  for NaN values.   file:  metadata/check.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "CheckTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#clearpointstransform", 
            "text": "Clears the points from a  Template   file:  metadata/clearpoints.cpp  inherits:   UntrainableMetadataTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "ClearPointsTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#consolidatedetectionstransform", 
            "text": "Consolidate redundant/overlapping detections.   file:  metadata/consolidatedetections.cpp  inherits:   UntrainableMetadataTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "ConsolidateDetectionsTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#croprecttransform", 
            "text": "Crops the width and height of a  Template  rects by input width and height factors.   file:  metadata/croprect.cpp  inherits:   UntrainableMetadataTransform  author(s):   Scott Klum  properties:  None", 
            "title": "CropRectTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#delaunaytransform", 
            "text": "Creates a Delaunay triangulation based on a set of points   file:  metadata/delaunay.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "DelaunayTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#expandrecttransform", 
            "text": "Expand the width and height of a  Template  rects by input width and height factors.   file:  metadata/expandrect.cpp  inherits:   UntrainableTransform  author(s):   Charles Otto  properties:  None", 
            "title": "ExpandRectTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#extractmetadatatransform", 
            "text": "Create matrix from metadata values.   file:  metadata/extractmetadata.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "ExtractMetadataTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#facefromeyestransform", 
            "text": "Create face bounding box from two eye locations.   file:  metadata/facefromeyes.cpp  inherits:   UntrainableMetadataTransform  author(s):   Brendan Klare   properties:     Property  Type  Description      widthPadding  double  Specifies what percentage of the interpupliary distance (ipd) will be padded in both horizontal directions.    verticalLocation  double  specifies where vertically the eyes are within the bounding box (0.5 would be the center).", 
            "title": "FaceFromEyesTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#fileexclusiontransform", 
            "text": "DOCUMENT ME CHARLES   file:  metadata/fileexclusion.cpp  inherits:   UntrainableMetaTransform  author(s):   Unknown  properties:  None", 
            "title": "FileExclusionTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#filterdupemetadatatransform", 
            "text": "Removes duplicate  Template  based on a unique metadata key   file:  metadata/filterdupemetadata.cpp  inherits:   TimeVaryingTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "FilterDupeMetadataTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#gridtransform", 
            "text": "Add landmarks to the  Template  in a grid layout   file:  metadata/grid.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "GridTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#groundtruthtransform", 
            "text": "Add any ground truth to the  Template  using the file's base name.   file:  metadata/groundtruth.cpp  inherits:   UntrainableMetadataTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "GroundTruthTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#hogpersondetectortransform", 
            "text": "Detects objects with OpenCV's built-in HOG detection.   file:  metadata/hogpersondetector.cpp  inherits:   UntrainableTransform  author(s):   Austin Blanton  see:    properties:  None", 
            "title": "HOGPersonDetectorTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#ifmetadatatransform", 
            "text": "Clear  Template  without the required metadata.   file:  metadata/ifmetadata.cpp  inherits:   UntrainableMetadataTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "IfMetadataTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#impostoruniquenessmeasuretransform", 
            "text": "Impostor Uniqueness Measure   file:  metadata/imposteruniquenessmeasure.cpp  inherits:   Transform  author(s):   Josh Klontz  properties:  None", 
            "title": "ImpostorUniquenessMeasureTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#jsontransform", 
            "text": "Represent the metadata as JSON template data.   file:  metadata/json.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "JSONTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#keepmetadatatransform", 
            "text": "Retains only the values for the keys listed, to reduce template size   file:  metadata/keepmetadata.cpp  inherits:   UntrainableMetadataTransform  author(s):   Scott Klum  properties:  None", 
            "title": "KeepMetadataTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#keypointdetectortransform", 
            "text": "Wraps OpenCV Key Point Detector   file:  metadata/keypointdetector.cpp  inherits:   UntrainableTransform  author(s):   Josh Klontz  see:    properties:  None", 
            "title": "KeyPointDetectorTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#keytorecttransform", 
            "text": "Convert values of key_X, key_Y, key_Width, key_Height to a rect.   file:  metadata/keytorect.cpp  inherits:   UntrainableMetadataTransform  author(s):  [Jordan Cheney][JordanCheney]  properties:  None", 
            "title": "KeyToRectTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#namelandmarkstransform", 
            "text": "Name a point/rect   file:  metadata/namelandmarks.cpp  inherits:   UntrainableMetadataTransform  author(s):   Scott Klum  properties:  None", 
            "title": "NameLandmarksTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#nametransform", 
            "text": "Sets the  Template  matrix data to the br::File::name.   file:  metadata/name.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "NameTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#normalizepointstransform", 
            "text": "Normalize points to be relative to a single point   file:  metadata/normalizepoints.cpp  inherits:   UntrainableMetadataTransform  author(s):   Scott Klum  properties:  None", 
            "title": "NormalizePointsTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#pointdisplacementtransform", 
            "text": "Normalize points to be relative to a single point   file:  metadata/pointdisplacement.cpp  inherits:   UntrainableMetadataTransform  author(s):   Scott Klum  properties:  None", 
            "title": "PointDisplacementTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#pointstomatrixtransform", 
            "text": "Converts either the file::points() list or a QList  metadata item to be the template's matrix   file:  metadata/pointstomatrix.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "PointsToMatrixTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#procrustestransform", 
            "text": "Procrustes alignment of points   file:  metadata/procrustes.cpp  inherits:   MetadataTransform  author(s):   Scott Klum  properties:  None", 
            "title": "ProcrustesTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#rectstotemplatestransform", 
            "text": "For each rectangle bounding box in src, a new  Template  is created.   file:  metadata/rectstotemplates.cpp  inherits:   UntrainableMetaTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "RectsToTemplatesTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#regexpropertytransform", 
            "text": "Apply the input regular expression to the value of inputProperty, store the matched portion in outputProperty.   file:  metadata/regexproperty.cpp  inherits:   UntrainableMetadataTransform  author(s):   Charles Otto  properties:  None", 
            "title": "RegexPropertyTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#removemetadatatransform", 
            "text": "Removes a metadata field from all  Template   file:  metadata/removemetadata.cpp  inherits:   UntrainableMetadataTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "RemoveMetadataTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#removetemplatestransform", 
            "text": "Remove  Template  with the specified file extension or metadata value.   file:  metadata/removetemplates.cpp  inherits:   UntrainableMetaTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RemoveTemplatesTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#renamefirsttransform", 
            "text": "Rename first found metadata key   file:  metadata/renamefirst.cpp  inherits:   UntrainableMetadataTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RenameFirstTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#renametransform", 
            "text": "Rename metadata key   file:  metadata/rename.cpp  inherits:   UntrainableMetadataTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "RenameTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#reorderpointstransform", 
            "text": "Reorder the points such that points[from[i]] becomes points[to[i]] and\nvice versa   file:  metadata/reorderpoints.cpp  inherits:   UntrainableMetadataTransform  author(s):   Scott Klum  properties:  None", 
            "title": "ReorderPointsTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#restoremattransform", 
            "text": "Set the last matrix of the input  Template  to a matrix stored as metadata with input propName.  Also removes the property from the  Template s metadata after restoring it.   file:  metadata/restoremat.cpp  inherits:   UntrainableMetaTransform  author(s):   Charles Otto  properties:  None", 
            "title": "RestoreMatTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#savemattransform", 
            "text": "Store the last matrix of the input  Template  as a metadata key with input property name.   file:  metadata/savemat.cpp  inherits:   UntrainableMetaTransform  author(s):   Charles Otto  properties:  None", 
            "title": "SaveMatTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#selectpointstransform", 
            "text": "Retains only landmarks/points at the provided indices   file:  metadata/selectpoints.cpp  inherits:   UntrainableMetadataTransform  author(s):   Brendan Klare  properties:  None", 
            "title": "SelectPointsTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#setmetadatatransform", 
            "text": "Sets the metadata key/value pair.   file:  metadata/setmetadata.cpp  inherits:   UntrainableMetadataTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "SetMetadataTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#setpointsinrecttransform", 
            "text": "Set points relative to a rect   file:  metadata/setpointsinrect.cpp  inherits:   UntrainableMetadataTransform  author(s):  [Jordan Cheney][JordanCheney]  properties:  None", 
            "title": "SetPointsInRectTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#stasmtransform", 
            "text": "Wraps STASM key point detector   file:  metadata/stasm4.cpp  inherits:   UntrainableTransform  author(s):   Scott Klum  properties:  None", 
            "title": "StasmTransform"
        }, 
        {
            "location": "/plugin_docs/metadata/#stopwatchtransform", 
            "text": "Gives time elapsed over a specified  Transform  as a function of both images (or frames) and pixels.   file:  metadata/stopwatch.cpp  inherits:   MetaTransform  author(s):  [Jordan Cheney][JordanCheney],  Josh Klontz  properties:  None", 
            "title": "StopWatchTransform"
        }, 
        {
            "location": "/plugin_docs/output/", 
            "text": "DefaultOutput\n\n\nAdaptor class -- write a matrix output using \nFormat\n classes.\n\n\n\n\nfile:\n output/default.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nCharles Otto\n\n\nproperties:\n None\n\n\n\n\n\n\nEmptyOutput\n\n\nOutput to the terminal.\n\n\n\n\nfile:\n output/empty.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nbestOutput\n\n\nThe highest scoring matches.\n\n\n\n\nfile:\n output/best.cpp\n\n\ninherits:\n \nOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\ncsvOutput\n\n\nComma separated values output.\n\n\n\n\nfile:\n output/csv.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nevalOutput\n\n\nEvaluate the output matrix.\n\n\n\n\nfile:\n output/eval.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nheatOutput\n\n\nMatrix-like output for heat maps.\n\n\n\n\nfile:\n output/heat.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nhistOutput\n\n\nScore histogram.\n\n\n\n\nfile:\n output/hist.cpp\n\n\ninherits:\n \nOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nmeltOutput\n\n\nOne score per row.\n\n\n\n\nfile:\n output/melt.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nmtxOutput\n\n\nsimmat output.\n\n\n\n\nfile:\n output/mtx.cpp\n\n\ninherits:\n \nOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nnullOutput\n\n\nDiscards the scores.\n\n\n\n\nfile:\n output/null.cpp\n\n\ninherits:\n \nOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nrankOutput\n\n\nOutputs highest ranked matches with scores.\n\n\n\n\nfile:\n output/rank.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nrrOutput\n\n\nRank retrieval output.\n\n\n\n\nfile:\n output/rr.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nJosh Klontz\n, \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\ntailOutput\n\n\nThe highest scoring matches.\n\n\n\n\nfile:\n output/tail.cpp\n\n\ninherits:\n \nOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\ntxtOutput\n\n\nText file output.\n\n\n\n\nfile:\n output/txt.cpp\n\n\ninherits:\n \nMatrixOutput\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None", 
            "title": "Output"
        }, 
        {
            "location": "/plugin_docs/output/#defaultoutput", 
            "text": "Adaptor class -- write a matrix output using  Format  classes.   file:  output/default.cpp  inherits:   MatrixOutput  author(s):   Charles Otto  properties:  None", 
            "title": "DefaultOutput"
        }, 
        {
            "location": "/plugin_docs/output/#emptyoutput", 
            "text": "Output to the terminal.   file:  output/empty.cpp  inherits:   MatrixOutput  author(s):   Josh Klontz  properties:  None", 
            "title": "EmptyOutput"
        }, 
        {
            "location": "/plugin_docs/output/#bestoutput", 
            "text": "The highest scoring matches.   file:  output/best.cpp  inherits:   Output  author(s):   Josh Klontz  properties:  None", 
            "title": "bestOutput"
        }, 
        {
            "location": "/plugin_docs/output/#csvoutput", 
            "text": "Comma separated values output.   file:  output/csv.cpp  inherits:   MatrixOutput  author(s):   Josh Klontz  properties:  None", 
            "title": "csvOutput"
        }, 
        {
            "location": "/plugin_docs/output/#evaloutput", 
            "text": "Evaluate the output matrix.   file:  output/eval.cpp  inherits:   MatrixOutput  author(s):   Josh Klontz  properties:  None", 
            "title": "evalOutput"
        }, 
        {
            "location": "/plugin_docs/output/#heatoutput", 
            "text": "Matrix-like output for heat maps.   file:  output/heat.cpp  inherits:   MatrixOutput  author(s):   Scott Klum  properties:  None", 
            "title": "heatOutput"
        }, 
        {
            "location": "/plugin_docs/output/#histoutput", 
            "text": "Score histogram.   file:  output/hist.cpp  inherits:   Output  author(s):   Josh Klontz  properties:  None", 
            "title": "histOutput"
        }, 
        {
            "location": "/plugin_docs/output/#meltoutput", 
            "text": "One score per row.   file:  output/melt.cpp  inherits:   MatrixOutput  author(s):   Josh Klontz  properties:  None", 
            "title": "meltOutput"
        }, 
        {
            "location": "/plugin_docs/output/#mtxoutput", 
            "text": "simmat output.   file:  output/mtx.cpp  inherits:   Output  author(s):   Josh Klontz  properties:  None", 
            "title": "mtxOutput"
        }, 
        {
            "location": "/plugin_docs/output/#nulloutput", 
            "text": "Discards the scores.   file:  output/null.cpp  inherits:   Output  author(s):   Josh Klontz  properties:  None", 
            "title": "nullOutput"
        }, 
        {
            "location": "/plugin_docs/output/#rankoutput", 
            "text": "Outputs highest ranked matches with scores.   file:  output/rank.cpp  inherits:   MatrixOutput  author(s):   Scott Klum  properties:  None", 
            "title": "rankOutput"
        }, 
        {
            "location": "/plugin_docs/output/#rroutput", 
            "text": "Rank retrieval output.   file:  output/rr.cpp  inherits:   MatrixOutput  author(s):   Josh Klontz ,  Scott Klum  properties:  None", 
            "title": "rrOutput"
        }, 
        {
            "location": "/plugin_docs/output/#tailoutput", 
            "text": "The highest scoring matches.   file:  output/tail.cpp  inherits:   Output  author(s):   Josh Klontz  properties:  None", 
            "title": "tailOutput"
        }, 
        {
            "location": "/plugin_docs/output/#txtoutput", 
            "text": "Text file output.   file:  output/txt.cpp  inherits:   MatrixOutput  author(s):   Josh Klontz  properties:  None", 
            "title": "txtOutput"
        }, 
        {
            "location": "/plugin_docs/representation/", 
            "text": "GradientHistogramRepresentation\n\n\nComputes first order gradient histogram features using an integral image\n\n\n\n\nfile:\n representation/gradienthistogram.cpp\n\n\ninherits:\n \nRepresentation\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None\n\n\n\n\n\n\nRandomRepresentation\n\n\nComputes first order gradient histogram features using an integral image\n\n\n\n\nfile:\n representation/random.cpp\n\n\ninherits:\n \nRepresentation\n\n\nauthor(s):\n \nScott Klum\n\n\nproperties:\n None", 
            "title": "Representation"
        }, 
        {
            "location": "/plugin_docs/representation/#gradienthistogramrepresentation", 
            "text": "Computes first order gradient histogram features using an integral image   file:  representation/gradienthistogram.cpp  inherits:   Representation  author(s):   Scott Klum  properties:  None", 
            "title": "GradientHistogramRepresentation"
        }, 
        {
            "location": "/plugin_docs/representation/#randomrepresentation", 
            "text": "Computes first order gradient histogram features using an integral image   file:  representation/random.cpp  inherits:   Representation  author(s):   Scott Klum  properties:  None", 
            "title": "RandomRepresentation"
        }, 
        {
            "location": "/plugin_docs/video/", 
            "text": "AggregateFrames\n\n\nPasses along n sequential frames to the next \nTransform\n.\n\n\nFor a video with m frames, AggregateFrames would create a total of m-n+1 sequences ([0,n] ... [m-n+1, m])\n\n\n\n\nfile:\n video/aggregate.cpp\n\n\ninherits:\n \nTimeVaryingTransform\n\n\nauthor(s):\n \nJosh Klontz\n\n\nproperties:\n None\n\n\n\n\n\n\nDropFrames\n\n\nOnly use one frame every n frames.\n\n\n\n\nfile:\n video/drop.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n [Austin Blanton][imaus10\n\n\n\n\nFor a video with m frames, DropFrames will pass on m/n frames.]\n* \nproperties:\n None\n\n\n\n\nOpticalFlowTransform\n\n\nGets a one-channel dense optical flow from two images\n\n\n\n\nfile:\n video/opticalflow.cpp\n\n\ninherits:\n \nUntrainableMetaTransform\n\n\nauthor(s):\n \nAustin Blanton\n\n\nproperties:\n None", 
            "title": "Video"
        }, 
        {
            "location": "/plugin_docs/video/#aggregateframes", 
            "text": "Passes along n sequential frames to the next  Transform .  For a video with m frames, AggregateFrames would create a total of m-n+1 sequences ([0,n] ... [m-n+1, m])   file:  video/aggregate.cpp  inherits:   TimeVaryingTransform  author(s):   Josh Klontz  properties:  None", 
            "title": "AggregateFrames"
        }, 
        {
            "location": "/plugin_docs/video/#dropframes", 
            "text": "Only use one frame every n frames.   file:  video/drop.cpp  inherits:   UntrainableMetaTransform  author(s):  [Austin Blanton][imaus10   For a video with m frames, DropFrames will pass on m/n frames.]\n*  properties:  None", 
            "title": "DropFrames"
        }, 
        {
            "location": "/plugin_docs/video/#opticalflowtransform", 
            "text": "Gets a one-channel dense optical flow from two images   file:  video/opticalflow.cpp  inherits:   UntrainableMetaTransform  author(s):   Austin Blanton  properties:  None", 
            "title": "OpticalFlowTransform"
        }
    ]
}